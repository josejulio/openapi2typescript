// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`src/cli/schema execute for ./tests/__fixtures__/integrations-openapi.json execute accepts urls 1`] = `
"/* eslint-disable */
/**
 * Generated code, DO NOT modify directly.
 */
import * as z from 'zod';
import { ValidatedResponse } from 'openapi2typescript';
import { Action } from 'react-fetching-library';
import { ValidateRule } from 'openapi2typescript';
import {
    actionBuilder,
    ActionValidatableConfig
} from 'openapi2typescript/react-fetching-library';

export namespace Schemas {
  export const AddAccessRequest = zodSchemaAddAccessRequest();
  export type AddAccessRequest = z.infer<typeof AddAccessRequest>;

  export const AddApplicationRequest = zodSchemaAddApplicationRequest();
  export type AddApplicationRequest = z.infer<typeof AddApplicationRequest>;

  export const AggregationEmailTemplate = zodSchemaAggregationEmailTemplate();
  export type AggregationEmailTemplate = z.infer<
    typeof AggregationEmailTemplate
  >;

  export const Application = zodSchemaApplication();
  export type Application = z.infer<typeof Application>;

  export const Application1 = zodSchemaApplication1();
  export type Application1 = z.infer<typeof Application1>;

  export const BasicAuthentication = zodSchemaBasicAuthentication();
  export type BasicAuthentication = z.infer<typeof BasicAuthentication>;

  export const BehaviorGroup = zodSchemaBehaviorGroup();
  export type BehaviorGroup = z.infer<typeof BehaviorGroup>;

  export const BehaviorGroupAction = zodSchemaBehaviorGroupAction();
  export type BehaviorGroupAction = z.infer<typeof BehaviorGroupAction>;

  export const BehaviorGroupActionId = zodSchemaBehaviorGroupActionId();
  export type BehaviorGroupActionId = z.infer<typeof BehaviorGroupActionId>;

  export const Bundle = zodSchemaBundle();
  export type Bundle = z.infer<typeof Bundle>;

  export const CamelProperties = zodSchemaCamelProperties();
  export type CamelProperties = z.infer<typeof CamelProperties>;

  export const CurrentStatus = zodSchemaCurrentStatus();
  export type CurrentStatus = z.infer<typeof CurrentStatus>;

  export const EmailSubscriptionProperties =
    zodSchemaEmailSubscriptionProperties();
  export type EmailSubscriptionProperties = z.infer<
    typeof EmailSubscriptionProperties
  >;

  export const EmailSubscriptionType = zodSchemaEmailSubscriptionType();
  export type EmailSubscriptionType = z.infer<typeof EmailSubscriptionType>;

  export const Endpoint = zodSchemaEndpoint();
  export type Endpoint = z.infer<typeof Endpoint>;

  export const EndpointPage = zodSchemaEndpointPage();
  export type EndpointPage = z.infer<typeof EndpointPage>;

  export const EndpointProperties = zodSchemaEndpointProperties();
  export type EndpointProperties = z.infer<typeof EndpointProperties>;

  export const EndpointType = zodSchemaEndpointType();
  export type EndpointType = z.infer<typeof EndpointType>;

  export const Environment = zodSchemaEnvironment();
  export type Environment = z.infer<typeof Environment>;

  export const EventLogEntry = zodSchemaEventLogEntry();
  export type EventLogEntry = z.infer<typeof EventLogEntry>;

  export const EventLogEntryAction = zodSchemaEventLogEntryAction();
  export type EventLogEntryAction = z.infer<typeof EventLogEntryAction>;

  export const EventType = zodSchemaEventType();
  export type EventType = z.infer<typeof EventType>;

  export const Facet = zodSchemaFacet();
  export type Facet = z.infer<typeof Facet>;

  export const HttpType = zodSchemaHttpType();
  export type HttpType = z.infer<typeof HttpType>;

  export const InstantEmailTemplate = zodSchemaInstantEmailTemplate();
  export type InstantEmailTemplate = z.infer<typeof InstantEmailTemplate>;

  export const InternalApplicationUserPermission =
    zodSchemaInternalApplicationUserPermission();
  export type InternalApplicationUserPermission = z.infer<
    typeof InternalApplicationUserPermission
  >;

  export const InternalRoleAccess = zodSchemaInternalRoleAccess();
  export type InternalRoleAccess = z.infer<typeof InternalRoleAccess>;

  export const InternalUserPermissions = zodSchemaInternalUserPermissions();
  export type InternalUserPermissions = z.infer<typeof InternalUserPermissions>;

  export const Meta = zodSchemaMeta();
  export type Meta = z.infer<typeof Meta>;

  export const NotificationHistory = zodSchemaNotificationHistory();
  export type NotificationHistory = z.infer<typeof NotificationHistory>;

  export const PageEventLogEntry = zodSchemaPageEventLogEntry();
  export type PageEventLogEntry = z.infer<typeof PageEventLogEntry>;

  export const PageEventType = zodSchemaPageEventType();
  export type PageEventType = z.infer<typeof PageEventType>;

  export const RenderEmailTemplateRequest =
    zodSchemaRenderEmailTemplateRequest();
  export type RenderEmailTemplateRequest = z.infer<
    typeof RenderEmailTemplateRequest
  >;

  export const RequestDefaultBehaviorGroupPropertyList =
    zodSchemaRequestDefaultBehaviorGroupPropertyList();
  export type RequestDefaultBehaviorGroupPropertyList = z.infer<
    typeof RequestDefaultBehaviorGroupPropertyList
  >;

  export const RequestEmailSubscriptionProperties =
    zodSchemaRequestEmailSubscriptionProperties();
  export type RequestEmailSubscriptionProperties = z.infer<
    typeof RequestEmailSubscriptionProperties
  >;

  export const ServerInfo = zodSchemaServerInfo();
  export type ServerInfo = z.infer<typeof ServerInfo>;

  export const Status = zodSchemaStatus();
  export type Status = z.infer<typeof Status>;

  export const Template = zodSchemaTemplate();
  export type Template = z.infer<typeof Template>;

  export const UUID = zodSchemaUUID();
  export type UUID = z.infer<typeof UUID>;

  export const WebhookProperties = zodSchemaWebhookProperties();
  export type WebhookProperties = z.infer<typeof WebhookProperties>;

  export const __Empty = zodSchema__Empty();
  export type __Empty = z.infer<typeof __Empty>;

  function zodSchemaAddAccessRequest() {
      return z.object({
          application_id: zodSchemaUUID().optional().nullable(),
          role: z.string().optional().nullable()
      });
  }

  function zodSchemaAddApplicationRequest() {
      return z.object({
          bundle_id: zodSchemaUUID(),
          display_name: z.string(),
          name: z.string(),
          owner_role: z.string().optional().nullable()
      });
  }

  function zodSchemaAggregationEmailTemplate() {
      return z.object({
          application: zodSchemaApplication().optional().nullable(),
          application_id: zodSchemaUUID().optional().nullable(),
          body_template: zodSchemaTemplate().optional().nullable(),
          body_template_id: zodSchemaUUID(),
          created: z.string().optional().nullable(),
          id: zodSchemaUUID().optional().nullable(),
          subject_template: zodSchemaTemplate().optional().nullable(),
          subject_template_id: zodSchemaUUID(),
          subscription_type: zodSchemaEmailSubscriptionType(),
          updated: z.string().optional().nullable()
      });
  }

  function zodSchemaApplication() {
      return z.object({
          bundle_id: zodSchemaUUID(),
          created: z.string().optional().nullable(),
          display_name: z.string(),
          id: zodSchemaUUID().optional().nullable(),
          name: z.string(),
          updated: z.string().optional().nullable()
      });
  }

  function zodSchemaApplication1() {
      return z.object({
          display_name: z.string(),
          id: zodSchemaUUID()
      });
  }

  function zodSchemaBasicAuthentication() {
      return z.object({
          password: z.string().optional().nullable(),
          username: z.string().optional().nullable()
      });
  }

  function zodSchemaBehaviorGroup() {
      return z.object({
          actions: z.array(zodSchemaBehaviorGroupAction()).optional().nullable(),
          bundle: zodSchemaBundle().optional().nullable(),
          bundle_id: zodSchemaUUID(),
          created: z.string().optional().nullable(),
          default_behavior: z.boolean().optional().nullable(),
          display_name: z.string(),
          id: zodSchemaUUID().optional().nullable(),
          updated: z.string().optional().nullable()
      });
  }

  function zodSchemaBehaviorGroupAction() {
      return z.object({
          created: z.string().optional().nullable(),
          endpoint: zodSchemaEndpoint().optional().nullable(),
          id: zodSchemaBehaviorGroupActionId().optional().nullable()
      });
  }

  function zodSchemaBehaviorGroupActionId() {
      return z.object({
          behaviorGroupId: zodSchemaUUID(),
          endpointId: zodSchemaUUID()
      });
  }

  function zodSchemaBundle() {
      return z.object({
          created: z.string().optional().nullable(),
          display_name: z.string(),
          id: zodSchemaUUID().optional().nullable(),
          name: z.string(),
          updated: z.string().optional().nullable()
      });
  }

  function zodSchemaCamelProperties() {
      return z.object({
          basic_authentication: zodSchemaBasicAuthentication()
          .optional()
          .nullable(),
          disable_ssl_verification: z.boolean(),
          extras: z.record(z.string()).optional().nullable(),
          secret_token: z.string().optional().nullable(),
          sub_type: z.string().optional().nullable(),
          url: z.string()
      });
  }

  function zodSchemaCurrentStatus() {
      return z.object({
          end_time: z.string().optional().nullable(),
          start_time: z.string().optional().nullable(),
          status: zodSchemaStatus()
      });
  }

  function zodSchemaEmailSubscriptionProperties() {
      return z.object({
          group_id: zodSchemaUUID().optional().nullable(),
          ignore_preferences: z.boolean(),
          only_admins: z.boolean()
      });
  }

  function zodSchemaEmailSubscriptionType() {
      return z.enum([ 'INSTANT', 'DAILY' ]);
  }

  function zodSchemaEndpoint() {
      return z.object({
          created: z.string().optional().nullable(),
          description: z.string(),
          enabled: z.boolean().optional().nullable(),
          id: zodSchemaUUID().optional().nullable(),
          name: z.string(),
          properties: z
          .union([
              zodSchemaWebhookProperties(),
              zodSchemaEmailSubscriptionProperties(),
              zodSchemaCamelProperties()
          ])
          .optional()
          .nullable(),
          sub_type: z.string().optional().nullable(),
          type: zodSchemaEndpointType(),
          updated: z.string().optional().nullable()
      });
  }

  function zodSchemaEndpointPage() {
      return z.object({
          data: z.array(zodSchemaEndpoint()),
          links: z.record(z.string()),
          meta: zodSchemaMeta()
      });
  }

  function zodSchemaEndpointProperties() {
      return z.unknown();
  }

  function zodSchemaEndpointType() {
      return z.enum([ 'webhook', 'email_subscription', 'default', 'camel' ]);
  }

  function zodSchemaEnvironment() {
      return z.enum([ 'PROD', 'STAGE', 'EPHEMERAL', 'LOCAL_SERVER' ]);
  }

  function zodSchemaEventLogEntry() {
      return z.object({
          actions: z.array(zodSchemaEventLogEntryAction()),
          application: z.string(),
          bundle: z.string(),
          created: z.string(),
          event_type: z.string(),
          id: zodSchemaUUID(),
          payload: z.string().optional().nullable()
      });
  }

  function zodSchemaEventLogEntryAction() {
      return z.object({
          details: z.record(z.unknown()).optional().nullable(),
          endpoint_id: zodSchemaUUID().optional().nullable(),
          endpoint_sub_type: z.string().optional().nullable(),
          endpoint_type: zodSchemaEndpointType(),
          id: zodSchemaUUID(),
          invocation_result: z.boolean()
      });
  }

  function zodSchemaEventType() {
      return z.object({
          application: zodSchemaApplication().optional().nullable(),
          application_id: zodSchemaUUID(),
          description: z.string().optional().nullable(),
          display_name: z.string(),
          id: zodSchemaUUID().optional().nullable(),
          name: z.string()
      });
  }

  function zodSchemaFacet() {
      return z.object({
          children: z
          .array(z.lazy(() => zodSchemaFacet()))
          .optional()
          .nullable(),
          displayName: z.string(),
          id: z.string(),
          name: z.string()
      });
  }

  function zodSchemaHttpType() {
      return z.enum([ 'GET', 'POST', 'PUT' ]);
  }

  function zodSchemaInstantEmailTemplate() {
      return z.object({
          body_template: zodSchemaTemplate().optional().nullable(),
          body_template_id: zodSchemaUUID(),
          created: z.string().optional().nullable(),
          event_type: zodSchemaEventType().optional().nullable(),
          event_type_id: zodSchemaUUID().optional().nullable(),
          id: zodSchemaUUID().optional().nullable(),
          subject_template: zodSchemaTemplate().optional().nullable(),
          subject_template_id: zodSchemaUUID(),
          updated: z.string().optional().nullable()
      });
  }

  function zodSchemaInternalApplicationUserPermission() {
      return z.object({
          application_display_name: z.string(),
          application_id: zodSchemaUUID(),
          role: z.string()
      });
  }

  function zodSchemaInternalRoleAccess() {
      return z.object({
          application_id: zodSchemaUUID(),
          id: zodSchemaUUID().optional().nullable(),
          role: z.string()
      });
  }

  function zodSchemaInternalUserPermissions() {
      return z.object({
          applications: z.array(zodSchemaApplication1()),
          is_admin: z.boolean(),
          roles: z.array(z.string())
      });
  }

  function zodSchemaMeta() {
      return z.object({
          count: z.number().int()
      });
  }

  function zodSchemaNotificationHistory() {
      return z.object({
          created: z.string().optional().nullable(),
          details: z.record(z.unknown()).optional().nullable(),
          endpointId: zodSchemaUUID().optional().nullable(),
          endpointSubType: z.string().optional().nullable(),
          endpointType: zodSchemaEndpointType().optional().nullable(),
          id: zodSchemaUUID().optional().nullable(),
          invocationResult: z.boolean(),
          invocationTime: z.number().int()
      });
  }

  function zodSchemaPageEventLogEntry() {
      return z.object({
          data: z.array(zodSchemaEventLogEntry()),
          links: z.record(z.string()),
          meta: zodSchemaMeta()
      });
  }

  function zodSchemaPageEventType() {
      return z.object({
          data: z.array(zodSchemaEventType()),
          links: z.record(z.string()),
          meta: zodSchemaMeta()
      });
  }

  function zodSchemaRenderEmailTemplateRequest() {
      return z.object({
          body_template: z.string(),
          payload: z.string(),
          subject_template: z.string()
      });
  }

  function zodSchemaRequestDefaultBehaviorGroupPropertyList() {
      return z.object({
          ignore_preferences: z.boolean(),
          only_admins: z.boolean()
      });
  }

  function zodSchemaRequestEmailSubscriptionProperties() {
      return z.object({
          group_id: zodSchemaUUID().optional().nullable(),
          only_admins: z.boolean()
      });
  }

  function zodSchemaServerInfo() {
      return z.object({
          environment: zodSchemaEnvironment().optional().nullable()
      });
  }

  function zodSchemaStatus() {
      return z.enum([ 'UP', 'MAINTENANCE' ]);
  }

  function zodSchemaTemplate() {
      return z.object({
          created: z.string().optional().nullable(),
          data: z.string(),
          description: z.string(),
          id: zodSchemaUUID().optional().nullable(),
          name: z.string(),
          updated: z.string().optional().nullable()
      });
  }

  function zodSchemaUUID() {
      return z.string();
  }

  function zodSchemaWebhookProperties() {
      return z.object({
          basic_authentication: zodSchemaBasicAuthentication()
          .optional()
          .nullable(),
          disable_ssl_verification: z.boolean(),
          method: zodSchemaHttpType(),
          secret_token: z.string().optional().nullable(),
          url: z.string()
      });
  }

  function zodSchema__Empty() {
      return z.string().max(0).optional();
  }
}

export namespace Operations {
  // GET /endpoints
  export namespace EndpointResourceGetEndpoints {
    const Active = z.boolean();
    type Active = z.infer<typeof Active>;
    const Limit = z.number().int();
    type Limit = z.infer<typeof Limit>;
    const Name = z.string();
    type Name = z.infer<typeof Name>;
    const Offset = z.number().int();
    type Offset = z.infer<typeof Offset>;
    const PageNumber = z.number().int();
    type PageNumber = z.infer<typeof PageNumber>;
    const SortBy = z.string();
    type SortBy = z.infer<typeof SortBy>;
    const Type = z.array(z.string());
    type Type = z.infer<typeof Type>;
    export interface Params {
      active?: Active;
      limit?: Limit;
      name?: Name;
      offset?: Offset;
      pageNumber?: PageNumber;
      sortBy?: SortBy;
      type?: Type;
    }

    export type Payload =
      | ValidatedResponse<'EndpointPage', 200, Schemas.EndpointPage>
      | ValidatedResponse<'__Empty', 401, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 403, Schemas.__Empty>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/api/integrations/v1.0/endpoints';
        const query = {} as Record<string, any>;
        if (params.active !== undefined) {
            query.active = params.active;
        }

        if (params.limit !== undefined) {
            query.limit = params.limit;
        }

        if (params.name !== undefined) {
            query.name = params.name;
        }

        if (params.offset !== undefined) {
            query.offset = params.offset;
        }

        if (params.pageNumber !== undefined) {
            query.pageNumber = params.pageNumber;
        }

        if (params.sortBy !== undefined) {
            query.sort_by = params.sortBy;
        }

        if (params.type !== undefined) {
            query.type = params.type;
        }

        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Schemas.EndpointPage, 'EndpointPage', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.__Empty, '__Empty', 403)
            ]
        })
        .build();
    };
  }
  // POST /endpoints
  export namespace EndpointResourceCreateEndpoint {
    export interface Params {
      body: Schemas.Endpoint;
    }

    export type Payload =
      | ValidatedResponse<'Endpoint', 200, Schemas.Endpoint>
      | ValidatedResponse<'__Empty', 401, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 403, Schemas.__Empty>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/api/integrations/v1.0/endpoints';
        const query = {} as Record<string, any>;
        return actionBuilder('POST', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [
                new ValidateRule(Schemas.Endpoint, 'Endpoint', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.__Empty, '__Empty', 403)
            ]
        })
        .build();
    };
  }
  // PUT /endpoints/email/subscription/{bundleName}/{applicationName}/{type}
  export namespace EndpointResourceSubscribeEmail {
    const ApplicationName = z.string();
    type ApplicationName = z.infer<typeof ApplicationName>;
    const BundleName = z.string();
    type BundleName = z.infer<typeof BundleName>;
    const Response200 = z.boolean();
    type Response200 = z.infer<typeof Response200>;
    export interface Params {
      applicationName: ApplicationName;
      bundleName: BundleName;
      type: Schemas.EmailSubscriptionType;
    }

    export type Payload =
      | ValidatedResponse<'unknown', 200, Response200>
      | ValidatedResponse<'__Empty', 401, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 403, Schemas.__Empty>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path =
        '/api/integrations/v1.0/endpoints/email/subscription/{bundleName}/{applicationName}/{type}'
        .replace('{applicationName}', params.applicationName.toString())
        .replace('{bundleName}', params.bundleName.toString())
        .replace('{type}', params.type.toString());
        const query = {} as Record<string, any>;
        return actionBuilder('PUT', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Response200, 'unknown', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.__Empty, '__Empty', 403)
            ]
        })
        .build();
    };
  }
  // DELETE /endpoints/email/subscription/{bundleName}/{applicationName}/{type}
  export namespace EndpointResourceUnsubscribeEmail {
    const ApplicationName = z.string();
    type ApplicationName = z.infer<typeof ApplicationName>;
    const BundleName = z.string();
    type BundleName = z.infer<typeof BundleName>;
    const Response200 = z.boolean();
    type Response200 = z.infer<typeof Response200>;
    export interface Params {
      applicationName: ApplicationName;
      bundleName: BundleName;
      type: Schemas.EmailSubscriptionType;
    }

    export type Payload =
      | ValidatedResponse<'unknown', 200, Response200>
      | ValidatedResponse<'__Empty', 401, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 403, Schemas.__Empty>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path =
        '/api/integrations/v1.0/endpoints/email/subscription/{bundleName}/{applicationName}/{type}'
        .replace('{applicationName}', params.applicationName.toString())
        .replace('{bundleName}', params.bundleName.toString())
        .replace('{type}', params.type.toString());
        const query = {} as Record<string, any>;
        return actionBuilder('DELETE', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Response200, 'unknown', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.__Empty, '__Empty', 403)
            ]
        })
        .build();
    };
  }
  // POST /endpoints/system/email_subscription
  export namespace EndpointResourceGetOrCreateEmailSubscriptionEndpoint {
    export interface Params {
      body: Schemas.RequestEmailSubscriptionProperties;
    }

    export type Payload =
      | ValidatedResponse<'Endpoint', 200, Schemas.Endpoint>
      | ValidatedResponse<'__Empty', 401, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 403, Schemas.__Empty>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/api/integrations/v1.0/endpoints/system/email_subscription';
        const query = {} as Record<string, any>;
        return actionBuilder('POST', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [
                new ValidateRule(Schemas.Endpoint, 'Endpoint', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.__Empty, '__Empty', 403)
            ]
        })
        .build();
    };
  }
  // GET /endpoints/{id}
  export namespace EndpointResourceGetEndpoint {
    export interface Params {
      id: Schemas.UUID;
    }

    export type Payload =
      | ValidatedResponse<'Endpoint', 200, Schemas.Endpoint>
      | ValidatedResponse<'__Empty', 401, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 403, Schemas.__Empty>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/api/integrations/v1.0/endpoints/{id}'.replace(
            '{id}',
            params.id.toString()
        );
        const query = {} as Record<string, any>;
        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Schemas.Endpoint, 'Endpoint', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.__Empty, '__Empty', 403)
            ]
        })
        .build();
    };
  }
  // PUT /endpoints/{id}
  export namespace EndpointResourceUpdateEndpoint {
    const Response200 = z.string();
    type Response200 = z.infer<typeof Response200>;
    export interface Params {
      id: Schemas.UUID;
      body: Schemas.Endpoint;
    }

    export type Payload =
      | ValidatedResponse<'unknown', 200, Response200>
      | ValidatedResponse<'__Empty', 401, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 403, Schemas.__Empty>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/api/integrations/v1.0/endpoints/{id}'.replace(
            '{id}',
            params.id.toString()
        );
        const query = {} as Record<string, any>;
        return actionBuilder('PUT', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [
                new ValidateRule(Response200, 'unknown', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.__Empty, '__Empty', 403)
            ]
        })
        .build();
    };
  }
  // DELETE /endpoints/{id}
  export namespace EndpointResourceDeleteEndpoint {
    export interface Params {
      id: Schemas.UUID;
    }

    export type Payload =
      | ValidatedResponse<'__Empty', 204, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 401, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 403, Schemas.__Empty>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/api/integrations/v1.0/endpoints/{id}'.replace(
            '{id}',
            params.id.toString()
        );
        const query = {} as Record<string, any>;
        return actionBuilder('DELETE', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Schemas.__Empty, '__Empty', 204),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.__Empty, '__Empty', 403)
            ]
        })
        .build();
    };
  }
  // PUT /endpoints/{id}/enable
  export namespace EndpointResourceEnableEndpoint {
    const Response200 = z.string();
    type Response200 = z.infer<typeof Response200>;
    export interface Params {
      id: Schemas.UUID;
    }

    export type Payload =
      | ValidatedResponse<'unknown', 200, Response200>
      | ValidatedResponse<'__Empty', 401, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 403, Schemas.__Empty>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/api/integrations/v1.0/endpoints/{id}/enable'.replace(
            '{id}',
            params.id.toString()
        );
        const query = {} as Record<string, any>;
        return actionBuilder('PUT', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Response200, 'unknown', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.__Empty, '__Empty', 403)
            ]
        })
        .build();
    };
  }
  // DELETE /endpoints/{id}/enable
  export namespace EndpointResourceDisableEndpoint {
    export interface Params {
      id: Schemas.UUID;
    }

    export type Payload =
      | ValidatedResponse<'__Empty', 204, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 401, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 403, Schemas.__Empty>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/api/integrations/v1.0/endpoints/{id}/enable'.replace(
            '{id}',
            params.id.toString()
        );
        const query = {} as Record<string, any>;
        return actionBuilder('DELETE', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Schemas.__Empty, '__Empty', 204),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.__Empty, '__Empty', 403)
            ]
        })
        .build();
    };
  }
  // GET /endpoints/{id}/history
  export namespace EndpointResourceGetEndpointHistory {
    const IncludeDetail = z.boolean();
    type IncludeDetail = z.infer<typeof IncludeDetail>;
    const Limit = z.number().int();
    type Limit = z.infer<typeof Limit>;
    const Offset = z.number().int();
    type Offset = z.infer<typeof Offset>;
    const PageNumber = z.number().int();
    type PageNumber = z.infer<typeof PageNumber>;
    const SortBy = z.string();
    type SortBy = z.infer<typeof SortBy>;
    const Response200 = z.array(Schemas.NotificationHistory);
    type Response200 = z.infer<typeof Response200>;
    export interface Params {
      id: Schemas.UUID;
      includeDetail?: IncludeDetail;
      limit?: Limit;
      offset?: Offset;
      pageNumber?: PageNumber;
      sortBy?: SortBy;
    }

    export type Payload =
      | ValidatedResponse<'unknown', 200, Response200>
      | ValidatedResponse<'__Empty', 401, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 403, Schemas.__Empty>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/api/integrations/v1.0/endpoints/{id}/history'.replace(
            '{id}',
            params.id.toString()
        );
        const query = {} as Record<string, any>;
        if (params.includeDetail !== undefined) {
            query.includeDetail = params.includeDetail;
        }

        if (params.limit !== undefined) {
            query.limit = params.limit;
        }

        if (params.offset !== undefined) {
            query.offset = params.offset;
        }

        if (params.pageNumber !== undefined) {
            query.pageNumber = params.pageNumber;
        }

        if (params.sortBy !== undefined) {
            query.sort_by = params.sortBy;
        }

        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Response200, 'unknown', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.__Empty, '__Empty', 403)
            ]
        })
        .build();
    };
  }
  // GET /endpoints/{id}/history/{history_id}/details
  export namespace EndpointResourceGetDetailedEndpointHistory {
    const Response200 = z.string();
    type Response200 = z.infer<typeof Response200>;
    export interface Params {
      historyId: Schemas.UUID;
      id: Schemas.UUID;
    }

    export type Payload =
      | ValidatedResponse<'unknown', 200, Response200>
      | ValidatedResponse<'__Empty', 401, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 403, Schemas.__Empty>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path =
        '/api/integrations/v1.0/endpoints/{id}/history/{history_id}/details'
        .replace('{history_id}', params.historyId.toString())
        .replace('{id}', params.id.toString());
        const query = {} as Record<string, any>;
        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Response200, 'unknown', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.__Empty, '__Empty', 403)
            ]
        })
        .build();
    };
  }
}
"
`;

exports[`src/cli/schema execute for ./tests/__fixtures__/integrations-openapi.json execute input file accepts path: compiled 1`] = `
"\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.Operations = exports.Schemas = void 0;
/* eslint-disable */
/**
 * Generated code, DO NOT modify directly.
 */
var z = require(\\"zod\\");
var openapi2typescript_1 = require(\\"openapi2typescript\\");
var react_fetching_library_1 = require(\\"openapi2typescript/react-fetching-library\\");
var Schemas;
(function (Schemas) {
    Schemas.AddAccessRequest = zodSchemaAddAccessRequest();
    Schemas.AddApplicationRequest = zodSchemaAddApplicationRequest();
    Schemas.AggregationEmailTemplate = zodSchemaAggregationEmailTemplate();
    Schemas.Application = zodSchemaApplication();
    Schemas.Application1 = zodSchemaApplication1();
    Schemas.BasicAuthentication = zodSchemaBasicAuthentication();
    Schemas.BehaviorGroup = zodSchemaBehaviorGroup();
    Schemas.BehaviorGroupAction = zodSchemaBehaviorGroupAction();
    Schemas.BehaviorGroupActionId = zodSchemaBehaviorGroupActionId();
    Schemas.Bundle = zodSchemaBundle();
    Schemas.CamelProperties = zodSchemaCamelProperties();
    Schemas.CurrentStatus = zodSchemaCurrentStatus();
    Schemas.EmailSubscriptionProperties = zodSchemaEmailSubscriptionProperties();
    Schemas.EmailSubscriptionType = zodSchemaEmailSubscriptionType();
    Schemas.Endpoint = zodSchemaEndpoint();
    Schemas.EndpointPage = zodSchemaEndpointPage();
    Schemas.EndpointProperties = zodSchemaEndpointProperties();
    Schemas.EndpointType = zodSchemaEndpointType();
    Schemas.Environment = zodSchemaEnvironment();
    Schemas.EventLogEntry = zodSchemaEventLogEntry();
    Schemas.EventLogEntryAction = zodSchemaEventLogEntryAction();
    Schemas.EventType = zodSchemaEventType();
    Schemas.Facet = zodSchemaFacet();
    Schemas.HttpType = zodSchemaHttpType();
    Schemas.InstantEmailTemplate = zodSchemaInstantEmailTemplate();
    Schemas.InternalApplicationUserPermission = zodSchemaInternalApplicationUserPermission();
    Schemas.InternalRoleAccess = zodSchemaInternalRoleAccess();
    Schemas.InternalUserPermissions = zodSchemaInternalUserPermissions();
    Schemas.Meta = zodSchemaMeta();
    Schemas.NotificationHistory = zodSchemaNotificationHistory();
    Schemas.PageEventLogEntry = zodSchemaPageEventLogEntry();
    Schemas.PageEventType = zodSchemaPageEventType();
    Schemas.RenderEmailTemplateRequest = zodSchemaRenderEmailTemplateRequest();
    Schemas.RequestDefaultBehaviorGroupPropertyList = zodSchemaRequestDefaultBehaviorGroupPropertyList();
    Schemas.RequestEmailSubscriptionProperties = zodSchemaRequestEmailSubscriptionProperties();
    Schemas.ServerInfo = zodSchemaServerInfo();
    Schemas.Status = zodSchemaStatus();
    Schemas.Template = zodSchemaTemplate();
    Schemas.UUID = zodSchemaUUID();
    Schemas.WebhookProperties = zodSchemaWebhookProperties();
    Schemas.__Empty = zodSchema__Empty();
    function zodSchemaAddAccessRequest() {
        return z.object({
            application_id: zodSchemaUUID().optional().nullable(),
            role: z.string().optional().nullable()
        });
    }
    function zodSchemaAddApplicationRequest() {
        return z.object({
            bundle_id: zodSchemaUUID(),
            display_name: z.string(),
            name: z.string(),
            owner_role: z.string().optional().nullable()
        });
    }
    function zodSchemaAggregationEmailTemplate() {
        return z.object({
            application: zodSchemaApplication().optional().nullable(),
            application_id: zodSchemaUUID().optional().nullable(),
            body_template: zodSchemaTemplate().optional().nullable(),
            body_template_id: zodSchemaUUID(),
            created: z.string().optional().nullable(),
            id: zodSchemaUUID().optional().nullable(),
            subject_template: zodSchemaTemplate().optional().nullable(),
            subject_template_id: zodSchemaUUID(),
            subscription_type: zodSchemaEmailSubscriptionType(),
            updated: z.string().optional().nullable()
        });
    }
    function zodSchemaApplication() {
        return z.object({
            bundle_id: zodSchemaUUID(),
            created: z.string().optional().nullable(),
            display_name: z.string(),
            id: zodSchemaUUID().optional().nullable(),
            name: z.string(),
            updated: z.string().optional().nullable()
        });
    }
    function zodSchemaApplication1() {
        return z.object({
            display_name: z.string(),
            id: zodSchemaUUID()
        });
    }
    function zodSchemaBasicAuthentication() {
        return z.object({
            password: z.string().optional().nullable(),
            username: z.string().optional().nullable()
        });
    }
    function zodSchemaBehaviorGroup() {
        return z.object({
            actions: z.array(zodSchemaBehaviorGroupAction()).optional().nullable(),
            bundle: zodSchemaBundle().optional().nullable(),
            bundle_id: zodSchemaUUID(),
            created: z.string().optional().nullable(),
            default_behavior: z.boolean().optional().nullable(),
            display_name: z.string(),
            id: zodSchemaUUID().optional().nullable(),
            updated: z.string().optional().nullable()
        });
    }
    function zodSchemaBehaviorGroupAction() {
        return z.object({
            created: z.string().optional().nullable(),
            endpoint: zodSchemaEndpoint().optional().nullable(),
            id: zodSchemaBehaviorGroupActionId().optional().nullable()
        });
    }
    function zodSchemaBehaviorGroupActionId() {
        return z.object({
            behaviorGroupId: zodSchemaUUID(),
            endpointId: zodSchemaUUID()
        });
    }
    function zodSchemaBundle() {
        return z.object({
            created: z.string().optional().nullable(),
            display_name: z.string(),
            id: zodSchemaUUID().optional().nullable(),
            name: z.string(),
            updated: z.string().optional().nullable()
        });
    }
    function zodSchemaCamelProperties() {
        return z.object({
            basic_authentication: zodSchemaBasicAuthentication()
                .optional()
                .nullable(),
            disable_ssl_verification: z.boolean(),
            extras: z.record(z.string()).optional().nullable(),
            secret_token: z.string().optional().nullable(),
            sub_type: z.string().optional().nullable(),
            url: z.string()
        });
    }
    function zodSchemaCurrentStatus() {
        return z.object({
            end_time: z.string().optional().nullable(),
            start_time: z.string().optional().nullable(),
            status: zodSchemaStatus()
        });
    }
    function zodSchemaEmailSubscriptionProperties() {
        return z.object({
            group_id: zodSchemaUUID().optional().nullable(),
            ignore_preferences: z.boolean(),
            only_admins: z.boolean()
        });
    }
    function zodSchemaEmailSubscriptionType() {
        return z.enum(['INSTANT', 'DAILY']);
    }
    function zodSchemaEndpoint() {
        return z.object({
            created: z.string().optional().nullable(),
            description: z.string(),
            enabled: z.boolean().optional().nullable(),
            id: zodSchemaUUID().optional().nullable(),
            name: z.string(),
            properties: z
                .union([
                zodSchemaWebhookProperties(),
                zodSchemaEmailSubscriptionProperties(),
                zodSchemaCamelProperties()
            ])
                .optional()
                .nullable(),
            sub_type: z.string().optional().nullable(),
            type: zodSchemaEndpointType(),
            updated: z.string().optional().nullable()
        });
    }
    function zodSchemaEndpointPage() {
        return z.object({
            data: z.array(zodSchemaEndpoint()),
            links: z.record(z.string()),
            meta: zodSchemaMeta()
        });
    }
    function zodSchemaEndpointProperties() {
        return z.unknown();
    }
    function zodSchemaEndpointType() {
        return z.enum(['webhook', 'email_subscription', 'default', 'camel']);
    }
    function zodSchemaEnvironment() {
        return z.enum(['PROD', 'STAGE', 'EPHEMERAL', 'LOCAL_SERVER']);
    }
    function zodSchemaEventLogEntry() {
        return z.object({
            actions: z.array(zodSchemaEventLogEntryAction()),
            application: z.string(),
            bundle: z.string(),
            created: z.string(),
            event_type: z.string(),
            id: zodSchemaUUID(),
            payload: z.string().optional().nullable()
        });
    }
    function zodSchemaEventLogEntryAction() {
        return z.object({
            details: z.record(z.unknown()).optional().nullable(),
            endpoint_id: zodSchemaUUID().optional().nullable(),
            endpoint_sub_type: z.string().optional().nullable(),
            endpoint_type: zodSchemaEndpointType(),
            id: zodSchemaUUID(),
            invocation_result: z.boolean()
        });
    }
    function zodSchemaEventType() {
        return z.object({
            application: zodSchemaApplication().optional().nullable(),
            application_id: zodSchemaUUID(),
            description: z.string().optional().nullable(),
            display_name: z.string(),
            id: zodSchemaUUID().optional().nullable(),
            name: z.string()
        });
    }
    function zodSchemaFacet() {
        return z.object({
            children: z
                .array(z.lazy(function () { return zodSchemaFacet(); }))
                .optional()
                .nullable(),
            displayName: z.string(),
            id: z.string(),
            name: z.string()
        });
    }
    function zodSchemaHttpType() {
        return z.enum(['GET', 'POST', 'PUT']);
    }
    function zodSchemaInstantEmailTemplate() {
        return z.object({
            body_template: zodSchemaTemplate().optional().nullable(),
            body_template_id: zodSchemaUUID(),
            created: z.string().optional().nullable(),
            event_type: zodSchemaEventType().optional().nullable(),
            event_type_id: zodSchemaUUID().optional().nullable(),
            id: zodSchemaUUID().optional().nullable(),
            subject_template: zodSchemaTemplate().optional().nullable(),
            subject_template_id: zodSchemaUUID(),
            updated: z.string().optional().nullable()
        });
    }
    function zodSchemaInternalApplicationUserPermission() {
        return z.object({
            application_display_name: z.string(),
            application_id: zodSchemaUUID(),
            role: z.string()
        });
    }
    function zodSchemaInternalRoleAccess() {
        return z.object({
            application_id: zodSchemaUUID(),
            id: zodSchemaUUID().optional().nullable(),
            role: z.string()
        });
    }
    function zodSchemaInternalUserPermissions() {
        return z.object({
            applications: z.array(zodSchemaApplication1()),
            is_admin: z.boolean(),
            roles: z.array(z.string())
        });
    }
    function zodSchemaMeta() {
        return z.object({
            count: z.number().int()
        });
    }
    function zodSchemaNotificationHistory() {
        return z.object({
            created: z.string().optional().nullable(),
            details: z.record(z.unknown()).optional().nullable(),
            endpointId: zodSchemaUUID().optional().nullable(),
            endpointSubType: z.string().optional().nullable(),
            endpointType: zodSchemaEndpointType().optional().nullable(),
            id: zodSchemaUUID().optional().nullable(),
            invocationResult: z.boolean(),
            invocationTime: z.number().int()
        });
    }
    function zodSchemaPageEventLogEntry() {
        return z.object({
            data: z.array(zodSchemaEventLogEntry()),
            links: z.record(z.string()),
            meta: zodSchemaMeta()
        });
    }
    function zodSchemaPageEventType() {
        return z.object({
            data: z.array(zodSchemaEventType()),
            links: z.record(z.string()),
            meta: zodSchemaMeta()
        });
    }
    function zodSchemaRenderEmailTemplateRequest() {
        return z.object({
            body_template: z.string(),
            payload: z.string(),
            subject_template: z.string()
        });
    }
    function zodSchemaRequestDefaultBehaviorGroupPropertyList() {
        return z.object({
            ignore_preferences: z.boolean(),
            only_admins: z.boolean()
        });
    }
    function zodSchemaRequestEmailSubscriptionProperties() {
        return z.object({
            group_id: zodSchemaUUID().optional().nullable(),
            only_admins: z.boolean()
        });
    }
    function zodSchemaServerInfo() {
        return z.object({
            environment: zodSchemaEnvironment().optional().nullable()
        });
    }
    function zodSchemaStatus() {
        return z.enum(['UP', 'MAINTENANCE']);
    }
    function zodSchemaTemplate() {
        return z.object({
            created: z.string().optional().nullable(),
            data: z.string(),
            description: z.string(),
            id: zodSchemaUUID().optional().nullable(),
            name: z.string(),
            updated: z.string().optional().nullable()
        });
    }
    function zodSchemaUUID() {
        return z.string();
    }
    function zodSchemaWebhookProperties() {
        return z.object({
            basic_authentication: zodSchemaBasicAuthentication()
                .optional()
                .nullable(),
            disable_ssl_verification: z.boolean(),
            method: zodSchemaHttpType(),
            secret_token: z.string().optional().nullable(),
            url: z.string()
        });
    }
    function zodSchema__Empty() {
        return z.string().max(0).optional();
    }
})(Schemas = exports.Schemas || (exports.Schemas = {}));
var Operations;
(function (Operations) {
    // GET /endpoints
    var EndpointResourceGetEndpoints;
    (function (EndpointResourceGetEndpoints) {
        var Active = z.boolean();
        var Limit = z.number().int();
        var Name = z.string();
        var Offset = z.number().int();
        var PageNumber = z.number().int();
        var SortBy = z.string();
        var Type = z.array(z.string());
        /*
     Params
    'active'?:Active,
    'limit'?:Limit,
    'name'?:Name,
    'offset'?:Offset,
    'pageNumber'?:PageNumber,
    'sortBy'?:SortBy,
    'type'?:Type
    */
        EndpointResourceGetEndpoints.actionCreator = function (params) {
            var path = '/api/integrations/v1.0/endpoints';
            var query = {};
            if (params.active !== undefined) {
                query.active = params.active;
            }
            if (params.limit !== undefined) {
                query.limit = params.limit;
            }
            if (params.name !== undefined) {
                query.name = params.name;
            }
            if (params.offset !== undefined) {
                query.offset = params.offset;
            }
            if (params.pageNumber !== undefined) {
                query.pageNumber = params.pageNumber;
            }
            if (params.sortBy !== undefined) {
                query.sort_by = params.sortBy;
            }
            if (params.type !== undefined) {
                query.type = params.type;
            }
            return (0, react_fetching_library_1.actionBuilder)('GET', path)
                .queryParams(query)
                .config({
                rules: [
                    new openapi2typescript_1.ValidateRule(Schemas.EndpointPage, 'EndpointPage', 200),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 401),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 403)
                ]
            })
                .build();
        };
    })(EndpointResourceGetEndpoints = Operations.EndpointResourceGetEndpoints || (Operations.EndpointResourceGetEndpoints = {}));
    // POST /endpoints
    var EndpointResourceCreateEndpoint;
    (function (EndpointResourceCreateEndpoint) {
        /*
     Params
    body: Schemas.Endpoint
    */
        EndpointResourceCreateEndpoint.actionCreator = function (params) {
            var path = '/api/integrations/v1.0/endpoints';
            var query = {};
            return (0, react_fetching_library_1.actionBuilder)('POST', path)
                .queryParams(query)
                .data(params.body)
                .config({
                rules: [
                    new openapi2typescript_1.ValidateRule(Schemas.Endpoint, 'Endpoint', 200),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 401),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 403)
                ]
            })
                .build();
        };
    })(EndpointResourceCreateEndpoint = Operations.EndpointResourceCreateEndpoint || (Operations.EndpointResourceCreateEndpoint = {}));
    // PUT /endpoints/email/subscription/{bundleName}/{applicationName}/{type}
    var EndpointResourceSubscribeEmail;
    (function (EndpointResourceSubscribeEmail) {
        var ApplicationName = z.string();
        var BundleName = z.string();
        var Response200 = z.boolean();
        /*
     Params
    'applicationName':ApplicationName,
    'bundleName':BundleName,
    'type':Schemas.EmailSubscriptionType
    */
        EndpointResourceSubscribeEmail.actionCreator = function (params) {
            var path = '/api/integrations/v1.0/endpoints/email/subscription/{bundleName}/{applicationName}/{type}'
                .replace('{applicationName}', params.applicationName.toString())
                .replace('{bundleName}', params.bundleName.toString())
                .replace('{type}', params.type.toString());
            var query = {};
            return (0, react_fetching_library_1.actionBuilder)('PUT', path)
                .queryParams(query)
                .config({
                rules: [
                    new openapi2typescript_1.ValidateRule(Response200, 'unknown', 200),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 401),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 403)
                ]
            })
                .build();
        };
    })(EndpointResourceSubscribeEmail = Operations.EndpointResourceSubscribeEmail || (Operations.EndpointResourceSubscribeEmail = {}));
    // DELETE /endpoints/email/subscription/{bundleName}/{applicationName}/{type}
    var EndpointResourceUnsubscribeEmail;
    (function (EndpointResourceUnsubscribeEmail) {
        var ApplicationName = z.string();
        var BundleName = z.string();
        var Response200 = z.boolean();
        /*
     Params
    'applicationName':ApplicationName,
    'bundleName':BundleName,
    'type':Schemas.EmailSubscriptionType
    */
        EndpointResourceUnsubscribeEmail.actionCreator = function (params) {
            var path = '/api/integrations/v1.0/endpoints/email/subscription/{bundleName}/{applicationName}/{type}'
                .replace('{applicationName}', params.applicationName.toString())
                .replace('{bundleName}', params.bundleName.toString())
                .replace('{type}', params.type.toString());
            var query = {};
            return (0, react_fetching_library_1.actionBuilder)('DELETE', path)
                .queryParams(query)
                .config({
                rules: [
                    new openapi2typescript_1.ValidateRule(Response200, 'unknown', 200),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 401),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 403)
                ]
            })
                .build();
        };
    })(EndpointResourceUnsubscribeEmail = Operations.EndpointResourceUnsubscribeEmail || (Operations.EndpointResourceUnsubscribeEmail = {}));
    // POST /endpoints/system/email_subscription
    var EndpointResourceGetOrCreateEmailSubscriptionEndpoint;
    (function (EndpointResourceGetOrCreateEmailSubscriptionEndpoint) {
        /*
     Params
    body: Schemas.RequestEmailSubscriptionProperties
    */
        EndpointResourceGetOrCreateEmailSubscriptionEndpoint.actionCreator = function (params) {
            var path = '/api/integrations/v1.0/endpoints/system/email_subscription';
            var query = {};
            return (0, react_fetching_library_1.actionBuilder)('POST', path)
                .queryParams(query)
                .data(params.body)
                .config({
                rules: [
                    new openapi2typescript_1.ValidateRule(Schemas.Endpoint, 'Endpoint', 200),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 401),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 403)
                ]
            })
                .build();
        };
    })(EndpointResourceGetOrCreateEmailSubscriptionEndpoint = Operations.EndpointResourceGetOrCreateEmailSubscriptionEndpoint || (Operations.EndpointResourceGetOrCreateEmailSubscriptionEndpoint = {}));
    // GET /endpoints/{id}
    var EndpointResourceGetEndpoint;
    (function (EndpointResourceGetEndpoint) {
        /*
     Params
    'id':Schemas.UUID
    */
        EndpointResourceGetEndpoint.actionCreator = function (params) {
            var path = '/api/integrations/v1.0/endpoints/{id}'.replace('{id}', params.id.toString());
            var query = {};
            return (0, react_fetching_library_1.actionBuilder)('GET', path)
                .queryParams(query)
                .config({
                rules: [
                    new openapi2typescript_1.ValidateRule(Schemas.Endpoint, 'Endpoint', 200),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 401),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 403)
                ]
            })
                .build();
        };
    })(EndpointResourceGetEndpoint = Operations.EndpointResourceGetEndpoint || (Operations.EndpointResourceGetEndpoint = {}));
    // PUT /endpoints/{id}
    var EndpointResourceUpdateEndpoint;
    (function (EndpointResourceUpdateEndpoint) {
        var Response200 = z.string();
        /*
     Params
    'id':Schemas.UUID,
    body: Schemas.Endpoint
    */
        EndpointResourceUpdateEndpoint.actionCreator = function (params) {
            var path = '/api/integrations/v1.0/endpoints/{id}'.replace('{id}', params.id.toString());
            var query = {};
            return (0, react_fetching_library_1.actionBuilder)('PUT', path)
                .queryParams(query)
                .data(params.body)
                .config({
                rules: [
                    new openapi2typescript_1.ValidateRule(Response200, 'unknown', 200),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 401),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 403)
                ]
            })
                .build();
        };
    })(EndpointResourceUpdateEndpoint = Operations.EndpointResourceUpdateEndpoint || (Operations.EndpointResourceUpdateEndpoint = {}));
    // DELETE /endpoints/{id}
    var EndpointResourceDeleteEndpoint;
    (function (EndpointResourceDeleteEndpoint) {
        /*
     Params
    'id':Schemas.UUID
    */
        EndpointResourceDeleteEndpoint.actionCreator = function (params) {
            var path = '/api/integrations/v1.0/endpoints/{id}'.replace('{id}', params.id.toString());
            var query = {};
            return (0, react_fetching_library_1.actionBuilder)('DELETE', path)
                .queryParams(query)
                .config({
                rules: [
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 204),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 401),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 403)
                ]
            })
                .build();
        };
    })(EndpointResourceDeleteEndpoint = Operations.EndpointResourceDeleteEndpoint || (Operations.EndpointResourceDeleteEndpoint = {}));
    // PUT /endpoints/{id}/enable
    var EndpointResourceEnableEndpoint;
    (function (EndpointResourceEnableEndpoint) {
        var Response200 = z.string();
        /*
     Params
    'id':Schemas.UUID
    */
        EndpointResourceEnableEndpoint.actionCreator = function (params) {
            var path = '/api/integrations/v1.0/endpoints/{id}/enable'.replace('{id}', params.id.toString());
            var query = {};
            return (0, react_fetching_library_1.actionBuilder)('PUT', path)
                .queryParams(query)
                .config({
                rules: [
                    new openapi2typescript_1.ValidateRule(Response200, 'unknown', 200),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 401),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 403)
                ]
            })
                .build();
        };
    })(EndpointResourceEnableEndpoint = Operations.EndpointResourceEnableEndpoint || (Operations.EndpointResourceEnableEndpoint = {}));
    // DELETE /endpoints/{id}/enable
    var EndpointResourceDisableEndpoint;
    (function (EndpointResourceDisableEndpoint) {
        /*
     Params
    'id':Schemas.UUID
    */
        EndpointResourceDisableEndpoint.actionCreator = function (params) {
            var path = '/api/integrations/v1.0/endpoints/{id}/enable'.replace('{id}', params.id.toString());
            var query = {};
            return (0, react_fetching_library_1.actionBuilder)('DELETE', path)
                .queryParams(query)
                .config({
                rules: [
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 204),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 401),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 403)
                ]
            })
                .build();
        };
    })(EndpointResourceDisableEndpoint = Operations.EndpointResourceDisableEndpoint || (Operations.EndpointResourceDisableEndpoint = {}));
    // GET /endpoints/{id}/history
    var EndpointResourceGetEndpointHistory;
    (function (EndpointResourceGetEndpointHistory) {
        var IncludeDetail = z.boolean();
        var Limit = z.number().int();
        var Offset = z.number().int();
        var PageNumber = z.number().int();
        var SortBy = z.string();
        var Response200 = z.array(Schemas.NotificationHistory);
        /*
     Params
    'id':Schemas.UUID,
    'includeDetail'?:IncludeDetail,
    'limit'?:Limit,
    'offset'?:Offset,
    'pageNumber'?:PageNumber,
    'sortBy'?:SortBy
    */
        EndpointResourceGetEndpointHistory.actionCreator = function (params) {
            var path = '/api/integrations/v1.0/endpoints/{id}/history'.replace('{id}', params.id.toString());
            var query = {};
            if (params.includeDetail !== undefined) {
                query.includeDetail = params.includeDetail;
            }
            if (params.limit !== undefined) {
                query.limit = params.limit;
            }
            if (params.offset !== undefined) {
                query.offset = params.offset;
            }
            if (params.pageNumber !== undefined) {
                query.pageNumber = params.pageNumber;
            }
            if (params.sortBy !== undefined) {
                query.sort_by = params.sortBy;
            }
            return (0, react_fetching_library_1.actionBuilder)('GET', path)
                .queryParams(query)
                .config({
                rules: [
                    new openapi2typescript_1.ValidateRule(Response200, 'unknown', 200),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 401),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 403)
                ]
            })
                .build();
        };
    })(EndpointResourceGetEndpointHistory = Operations.EndpointResourceGetEndpointHistory || (Operations.EndpointResourceGetEndpointHistory = {}));
    // GET /endpoints/{id}/history/{history_id}/details
    var EndpointResourceGetDetailedEndpointHistory;
    (function (EndpointResourceGetDetailedEndpointHistory) {
        var Response200 = z.string();
        /*
     Params
    'historyId':Schemas.UUID,
    'id':Schemas.UUID
    */
        EndpointResourceGetDetailedEndpointHistory.actionCreator = function (params) {
            var path = '/api/integrations/v1.0/endpoints/{id}/history/{history_id}/details'
                .replace('{history_id}', params.historyId.toString())
                .replace('{id}', params.id.toString());
            var query = {};
            return (0, react_fetching_library_1.actionBuilder)('GET', path)
                .queryParams(query)
                .config({
                rules: [
                    new openapi2typescript_1.ValidateRule(Response200, 'unknown', 200),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 401),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 403)
                ]
            })
                .build();
        };
    })(EndpointResourceGetDetailedEndpointHistory = Operations.EndpointResourceGetDetailedEndpointHistory || (Operations.EndpointResourceGetDetailedEndpointHistory = {}));
})(Operations = exports.Operations || (exports.Operations = {}));
"
`;

exports[`src/cli/schema execute for ./tests/__fixtures__/integrations-openapi.json execute input file accepts path: generated 1`] = `
"/* eslint-disable */
/**
 * Generated code, DO NOT modify directly.
 */
import * as z from 'zod';
import { ValidateRule } from 'openapi2typescript';
import { actionBuilder } from 'openapi2typescript/react-fetching-library';

export namespace Schemas {
  export const AddAccessRequest = zodSchemaAddAccessRequest();

  export const AddApplicationRequest = zodSchemaAddApplicationRequest();

  export const AggregationEmailTemplate = zodSchemaAggregationEmailTemplate();

  export const Application = zodSchemaApplication();

  export const Application1 = zodSchemaApplication1();

  export const BasicAuthentication = zodSchemaBasicAuthentication();

  export const BehaviorGroup = zodSchemaBehaviorGroup();

  export const BehaviorGroupAction = zodSchemaBehaviorGroupAction();

  export const BehaviorGroupActionId = zodSchemaBehaviorGroupActionId();

  export const Bundle = zodSchemaBundle();

  export const CamelProperties = zodSchemaCamelProperties();

  export const CurrentStatus = zodSchemaCurrentStatus();

  export const EmailSubscriptionProperties =
    zodSchemaEmailSubscriptionProperties();

  export const EmailSubscriptionType = zodSchemaEmailSubscriptionType();

  export const Endpoint = zodSchemaEndpoint();

  export const EndpointPage = zodSchemaEndpointPage();

  export const EndpointProperties = zodSchemaEndpointProperties();

  export const EndpointType = zodSchemaEndpointType();

  export const Environment = zodSchemaEnvironment();

  export const EventLogEntry = zodSchemaEventLogEntry();

  export const EventLogEntryAction = zodSchemaEventLogEntryAction();

  export const EventType = zodSchemaEventType();

  export const Facet = zodSchemaFacet();

  export const HttpType = zodSchemaHttpType();

  export const InstantEmailTemplate = zodSchemaInstantEmailTemplate();

  export const InternalApplicationUserPermission =
    zodSchemaInternalApplicationUserPermission();

  export const InternalRoleAccess = zodSchemaInternalRoleAccess();

  export const InternalUserPermissions = zodSchemaInternalUserPermissions();

  export const Meta = zodSchemaMeta();

  export const NotificationHistory = zodSchemaNotificationHistory();

  export const PageEventLogEntry = zodSchemaPageEventLogEntry();

  export const PageEventType = zodSchemaPageEventType();

  export const RenderEmailTemplateRequest =
    zodSchemaRenderEmailTemplateRequest();

  export const RequestDefaultBehaviorGroupPropertyList =
    zodSchemaRequestDefaultBehaviorGroupPropertyList();

  export const RequestEmailSubscriptionProperties =
    zodSchemaRequestEmailSubscriptionProperties();

  export const ServerInfo = zodSchemaServerInfo();

  export const Status = zodSchemaStatus();

  export const Template = zodSchemaTemplate();

  export const UUID = zodSchemaUUID();

  export const WebhookProperties = zodSchemaWebhookProperties();

  export const __Empty = zodSchema__Empty();

  function zodSchemaAddAccessRequest() {
      return z.object({
          application_id: zodSchemaUUID().optional().nullable(),
          role: z.string().optional().nullable()
      });
  }

  function zodSchemaAddApplicationRequest() {
      return z.object({
          bundle_id: zodSchemaUUID(),
          display_name: z.string(),
          name: z.string(),
          owner_role: z.string().optional().nullable()
      });
  }

  function zodSchemaAggregationEmailTemplate() {
      return z.object({
          application: zodSchemaApplication().optional().nullable(),
          application_id: zodSchemaUUID().optional().nullable(),
          body_template: zodSchemaTemplate().optional().nullable(),
          body_template_id: zodSchemaUUID(),
          created: z.string().optional().nullable(),
          id: zodSchemaUUID().optional().nullable(),
          subject_template: zodSchemaTemplate().optional().nullable(),
          subject_template_id: zodSchemaUUID(),
          subscription_type: zodSchemaEmailSubscriptionType(),
          updated: z.string().optional().nullable()
      });
  }

  function zodSchemaApplication() {
      return z.object({
          bundle_id: zodSchemaUUID(),
          created: z.string().optional().nullable(),
          display_name: z.string(),
          id: zodSchemaUUID().optional().nullable(),
          name: z.string(),
          updated: z.string().optional().nullable()
      });
  }

  function zodSchemaApplication1() {
      return z.object({
          display_name: z.string(),
          id: zodSchemaUUID()
      });
  }

  function zodSchemaBasicAuthentication() {
      return z.object({
          password: z.string().optional().nullable(),
          username: z.string().optional().nullable()
      });
  }

  function zodSchemaBehaviorGroup() {
      return z.object({
          actions: z.array(zodSchemaBehaviorGroupAction()).optional().nullable(),
          bundle: zodSchemaBundle().optional().nullable(),
          bundle_id: zodSchemaUUID(),
          created: z.string().optional().nullable(),
          default_behavior: z.boolean().optional().nullable(),
          display_name: z.string(),
          id: zodSchemaUUID().optional().nullable(),
          updated: z.string().optional().nullable()
      });
  }

  function zodSchemaBehaviorGroupAction() {
      return z.object({
          created: z.string().optional().nullable(),
          endpoint: zodSchemaEndpoint().optional().nullable(),
          id: zodSchemaBehaviorGroupActionId().optional().nullable()
      });
  }

  function zodSchemaBehaviorGroupActionId() {
      return z.object({
          behaviorGroupId: zodSchemaUUID(),
          endpointId: zodSchemaUUID()
      });
  }

  function zodSchemaBundle() {
      return z.object({
          created: z.string().optional().nullable(),
          display_name: z.string(),
          id: zodSchemaUUID().optional().nullable(),
          name: z.string(),
          updated: z.string().optional().nullable()
      });
  }

  function zodSchemaCamelProperties() {
      return z.object({
          basic_authentication: zodSchemaBasicAuthentication()
          .optional()
          .nullable(),
          disable_ssl_verification: z.boolean(),
          extras: z.record(z.string()).optional().nullable(),
          secret_token: z.string().optional().nullable(),
          sub_type: z.string().optional().nullable(),
          url: z.string()
      });
  }

  function zodSchemaCurrentStatus() {
      return z.object({
          end_time: z.string().optional().nullable(),
          start_time: z.string().optional().nullable(),
          status: zodSchemaStatus()
      });
  }

  function zodSchemaEmailSubscriptionProperties() {
      return z.object({
          group_id: zodSchemaUUID().optional().nullable(),
          ignore_preferences: z.boolean(),
          only_admins: z.boolean()
      });
  }

  function zodSchemaEmailSubscriptionType() {
      return z.enum([ 'INSTANT', 'DAILY' ]);
  }

  function zodSchemaEndpoint() {
      return z.object({
          created: z.string().optional().nullable(),
          description: z.string(),
          enabled: z.boolean().optional().nullable(),
          id: zodSchemaUUID().optional().nullable(),
          name: z.string(),
          properties: z
          .union([
              zodSchemaWebhookProperties(),
              zodSchemaEmailSubscriptionProperties(),
              zodSchemaCamelProperties()
          ])
          .optional()
          .nullable(),
          sub_type: z.string().optional().nullable(),
          type: zodSchemaEndpointType(),
          updated: z.string().optional().nullable()
      });
  }

  function zodSchemaEndpointPage() {
      return z.object({
          data: z.array(zodSchemaEndpoint()),
          links: z.record(z.string()),
          meta: zodSchemaMeta()
      });
  }

  function zodSchemaEndpointProperties() {
      return z.unknown();
  }

  function zodSchemaEndpointType() {
      return z.enum([ 'webhook', 'email_subscription', 'default', 'camel' ]);
  }

  function zodSchemaEnvironment() {
      return z.enum([ 'PROD', 'STAGE', 'EPHEMERAL', 'LOCAL_SERVER' ]);
  }

  function zodSchemaEventLogEntry() {
      return z.object({
          actions: z.array(zodSchemaEventLogEntryAction()),
          application: z.string(),
          bundle: z.string(),
          created: z.string(),
          event_type: z.string(),
          id: zodSchemaUUID(),
          payload: z.string().optional().nullable()
      });
  }

  function zodSchemaEventLogEntryAction() {
      return z.object({
          details: z.record(z.unknown()).optional().nullable(),
          endpoint_id: zodSchemaUUID().optional().nullable(),
          endpoint_sub_type: z.string().optional().nullable(),
          endpoint_type: zodSchemaEndpointType(),
          id: zodSchemaUUID(),
          invocation_result: z.boolean()
      });
  }

  function zodSchemaEventType() {
      return z.object({
          application: zodSchemaApplication().optional().nullable(),
          application_id: zodSchemaUUID(),
          description: z.string().optional().nullable(),
          display_name: z.string(),
          id: zodSchemaUUID().optional().nullable(),
          name: z.string()
      });
  }

  function zodSchemaFacet() {
      return z.object({
          children: z
          .array(z.lazy(() => zodSchemaFacet()))
          .optional()
          .nullable(),
          displayName: z.string(),
          id: z.string(),
          name: z.string()
      });
  }

  function zodSchemaHttpType() {
      return z.enum([ 'GET', 'POST', 'PUT' ]);
  }

  function zodSchemaInstantEmailTemplate() {
      return z.object({
          body_template: zodSchemaTemplate().optional().nullable(),
          body_template_id: zodSchemaUUID(),
          created: z.string().optional().nullable(),
          event_type: zodSchemaEventType().optional().nullable(),
          event_type_id: zodSchemaUUID().optional().nullable(),
          id: zodSchemaUUID().optional().nullable(),
          subject_template: zodSchemaTemplate().optional().nullable(),
          subject_template_id: zodSchemaUUID(),
          updated: z.string().optional().nullable()
      });
  }

  function zodSchemaInternalApplicationUserPermission() {
      return z.object({
          application_display_name: z.string(),
          application_id: zodSchemaUUID(),
          role: z.string()
      });
  }

  function zodSchemaInternalRoleAccess() {
      return z.object({
          application_id: zodSchemaUUID(),
          id: zodSchemaUUID().optional().nullable(),
          role: z.string()
      });
  }

  function zodSchemaInternalUserPermissions() {
      return z.object({
          applications: z.array(zodSchemaApplication1()),
          is_admin: z.boolean(),
          roles: z.array(z.string())
      });
  }

  function zodSchemaMeta() {
      return z.object({
          count: z.number().int()
      });
  }

  function zodSchemaNotificationHistory() {
      return z.object({
          created: z.string().optional().nullable(),
          details: z.record(z.unknown()).optional().nullable(),
          endpointId: zodSchemaUUID().optional().nullable(),
          endpointSubType: z.string().optional().nullable(),
          endpointType: zodSchemaEndpointType().optional().nullable(),
          id: zodSchemaUUID().optional().nullable(),
          invocationResult: z.boolean(),
          invocationTime: z.number().int()
      });
  }

  function zodSchemaPageEventLogEntry() {
      return z.object({
          data: z.array(zodSchemaEventLogEntry()),
          links: z.record(z.string()),
          meta: zodSchemaMeta()
      });
  }

  function zodSchemaPageEventType() {
      return z.object({
          data: z.array(zodSchemaEventType()),
          links: z.record(z.string()),
          meta: zodSchemaMeta()
      });
  }

  function zodSchemaRenderEmailTemplateRequest() {
      return z.object({
          body_template: z.string(),
          payload: z.string(),
          subject_template: z.string()
      });
  }

  function zodSchemaRequestDefaultBehaviorGroupPropertyList() {
      return z.object({
          ignore_preferences: z.boolean(),
          only_admins: z.boolean()
      });
  }

  function zodSchemaRequestEmailSubscriptionProperties() {
      return z.object({
          group_id: zodSchemaUUID().optional().nullable(),
          only_admins: z.boolean()
      });
  }

  function zodSchemaServerInfo() {
      return z.object({
          environment: zodSchemaEnvironment().optional().nullable()
      });
  }

  function zodSchemaStatus() {
      return z.enum([ 'UP', 'MAINTENANCE' ]);
  }

  function zodSchemaTemplate() {
      return z.object({
          created: z.string().optional().nullable(),
          data: z.string(),
          description: z.string(),
          id: zodSchemaUUID().optional().nullable(),
          name: z.string(),
          updated: z.string().optional().nullable()
      });
  }

  function zodSchemaUUID() {
      return z.string();
  }

  function zodSchemaWebhookProperties() {
      return z.object({
          basic_authentication: zodSchemaBasicAuthentication()
          .optional()
          .nullable(),
          disable_ssl_verification: z.boolean(),
          method: zodSchemaHttpType(),
          secret_token: z.string().optional().nullable(),
          url: z.string()
      });
  }

  function zodSchema__Empty() {
      return z.string().max(0).optional();
  }
}

export namespace Operations {
  // GET /endpoints
  export namespace EndpointResourceGetEndpoints {
    const Active = z.boolean();
    const Limit = z.number().int();
    const Name = z.string();
    const Offset = z.number().int();
    const PageNumber = z.number().int();
    const SortBy = z.string();
    const Type = z.array(z.string());
    /*
 Params
'active'?:Active,
'limit'?:Limit,
'name'?:Name,
'offset'?:Offset,
'pageNumber'?:PageNumber,
'sortBy'?:SortBy,
'type'?:Type
*/
    export const actionCreator = (params) => {
        const path = '/api/integrations/v1.0/endpoints';
        const query = {};
        if (params.active !== undefined) {
            query.active = params.active;
        }

        if (params.limit !== undefined) {
            query.limit = params.limit;
        }

        if (params.name !== undefined) {
            query.name = params.name;
        }

        if (params.offset !== undefined) {
            query.offset = params.offset;
        }

        if (params.pageNumber !== undefined) {
            query.pageNumber = params.pageNumber;
        }

        if (params.sortBy !== undefined) {
            query.sort_by = params.sortBy;
        }

        if (params.type !== undefined) {
            query.type = params.type;
        }

        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Schemas.EndpointPage, 'EndpointPage', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.__Empty, '__Empty', 403)
            ]
        })
        .build();
    };
  }
  // POST /endpoints
  export namespace EndpointResourceCreateEndpoint {
    /*
 Params
body: Schemas.Endpoint
*/
    export const actionCreator = (params) => {
        const path = '/api/integrations/v1.0/endpoints';
        const query = {};
        return actionBuilder('POST', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [
                new ValidateRule(Schemas.Endpoint, 'Endpoint', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.__Empty, '__Empty', 403)
            ]
        })
        .build();
    };
  }
  // PUT /endpoints/email/subscription/{bundleName}/{applicationName}/{type}
  export namespace EndpointResourceSubscribeEmail {
    const ApplicationName = z.string();
    const BundleName = z.string();
    const Response200 = z.boolean();
    /*
 Params
'applicationName':ApplicationName,
'bundleName':BundleName,
'type':Schemas.EmailSubscriptionType
*/
    export const actionCreator = (params) => {
        const path =
        '/api/integrations/v1.0/endpoints/email/subscription/{bundleName}/{applicationName}/{type}'
        .replace('{applicationName}', params.applicationName.toString())
        .replace('{bundleName}', params.bundleName.toString())
        .replace('{type}', params.type.toString());
        const query = {};
        return actionBuilder('PUT', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Response200, 'unknown', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.__Empty, '__Empty', 403)
            ]
        })
        .build();
    };
  }
  // DELETE /endpoints/email/subscription/{bundleName}/{applicationName}/{type}
  export namespace EndpointResourceUnsubscribeEmail {
    const ApplicationName = z.string();
    const BundleName = z.string();
    const Response200 = z.boolean();
    /*
 Params
'applicationName':ApplicationName,
'bundleName':BundleName,
'type':Schemas.EmailSubscriptionType
*/
    export const actionCreator = (params) => {
        const path =
        '/api/integrations/v1.0/endpoints/email/subscription/{bundleName}/{applicationName}/{type}'
        .replace('{applicationName}', params.applicationName.toString())
        .replace('{bundleName}', params.bundleName.toString())
        .replace('{type}', params.type.toString());
        const query = {};
        return actionBuilder('DELETE', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Response200, 'unknown', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.__Empty, '__Empty', 403)
            ]
        })
        .build();
    };
  }
  // POST /endpoints/system/email_subscription
  export namespace EndpointResourceGetOrCreateEmailSubscriptionEndpoint {
    /*
 Params
body: Schemas.RequestEmailSubscriptionProperties
*/
    export const actionCreator = (params) => {
        const path = '/api/integrations/v1.0/endpoints/system/email_subscription';
        const query = {};
        return actionBuilder('POST', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [
                new ValidateRule(Schemas.Endpoint, 'Endpoint', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.__Empty, '__Empty', 403)
            ]
        })
        .build();
    };
  }
  // GET /endpoints/{id}
  export namespace EndpointResourceGetEndpoint {
    /*
 Params
'id':Schemas.UUID
*/
    export const actionCreator = (params) => {
        const path = '/api/integrations/v1.0/endpoints/{id}'.replace(
            '{id}',
            params.id.toString()
        );
        const query = {};
        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Schemas.Endpoint, 'Endpoint', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.__Empty, '__Empty', 403)
            ]
        })
        .build();
    };
  }
  // PUT /endpoints/{id}
  export namespace EndpointResourceUpdateEndpoint {
    const Response200 = z.string();
    /*
 Params
'id':Schemas.UUID,
body: Schemas.Endpoint
*/
    export const actionCreator = (params) => {
        const path = '/api/integrations/v1.0/endpoints/{id}'.replace(
            '{id}',
            params.id.toString()
        );
        const query = {};
        return actionBuilder('PUT', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [
                new ValidateRule(Response200, 'unknown', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.__Empty, '__Empty', 403)
            ]
        })
        .build();
    };
  }
  // DELETE /endpoints/{id}
  export namespace EndpointResourceDeleteEndpoint {
    /*
 Params
'id':Schemas.UUID
*/
    export const actionCreator = (params) => {
        const path = '/api/integrations/v1.0/endpoints/{id}'.replace(
            '{id}',
            params.id.toString()
        );
        const query = {};
        return actionBuilder('DELETE', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Schemas.__Empty, '__Empty', 204),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.__Empty, '__Empty', 403)
            ]
        })
        .build();
    };
  }
  // PUT /endpoints/{id}/enable
  export namespace EndpointResourceEnableEndpoint {
    const Response200 = z.string();
    /*
 Params
'id':Schemas.UUID
*/
    export const actionCreator = (params) => {
        const path = '/api/integrations/v1.0/endpoints/{id}/enable'.replace(
            '{id}',
            params.id.toString()
        );
        const query = {};
        return actionBuilder('PUT', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Response200, 'unknown', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.__Empty, '__Empty', 403)
            ]
        })
        .build();
    };
  }
  // DELETE /endpoints/{id}/enable
  export namespace EndpointResourceDisableEndpoint {
    /*
 Params
'id':Schemas.UUID
*/
    export const actionCreator = (params) => {
        const path = '/api/integrations/v1.0/endpoints/{id}/enable'.replace(
            '{id}',
            params.id.toString()
        );
        const query = {};
        return actionBuilder('DELETE', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Schemas.__Empty, '__Empty', 204),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.__Empty, '__Empty', 403)
            ]
        })
        .build();
    };
  }
  // GET /endpoints/{id}/history
  export namespace EndpointResourceGetEndpointHistory {
    const IncludeDetail = z.boolean();
    const Limit = z.number().int();
    const Offset = z.number().int();
    const PageNumber = z.number().int();
    const SortBy = z.string();
    const Response200 = z.array(Schemas.NotificationHistory);
    /*
 Params
'id':Schemas.UUID,
'includeDetail'?:IncludeDetail,
'limit'?:Limit,
'offset'?:Offset,
'pageNumber'?:PageNumber,
'sortBy'?:SortBy
*/
    export const actionCreator = (params) => {
        const path = '/api/integrations/v1.0/endpoints/{id}/history'.replace(
            '{id}',
            params.id.toString()
        );
        const query = {};
        if (params.includeDetail !== undefined) {
            query.includeDetail = params.includeDetail;
        }

        if (params.limit !== undefined) {
            query.limit = params.limit;
        }

        if (params.offset !== undefined) {
            query.offset = params.offset;
        }

        if (params.pageNumber !== undefined) {
            query.pageNumber = params.pageNumber;
        }

        if (params.sortBy !== undefined) {
            query.sort_by = params.sortBy;
        }

        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Response200, 'unknown', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.__Empty, '__Empty', 403)
            ]
        })
        .build();
    };
  }
  // GET /endpoints/{id}/history/{history_id}/details
  export namespace EndpointResourceGetDetailedEndpointHistory {
    const Response200 = z.string();
    /*
 Params
'historyId':Schemas.UUID,
'id':Schemas.UUID
*/
    export const actionCreator = (params) => {
        const path =
        '/api/integrations/v1.0/endpoints/{id}/history/{history_id}/details'
        .replace('{history_id}', params.historyId.toString())
        .replace('{id}', params.id.toString());
        const query = {};
        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Response200, 'unknown', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.__Empty, '__Empty', 403)
            ]
        })
        .build();
    };
  }
}
"
`;

exports[`src/cli/schema execute for ./tests/__fixtures__/notifications-openapi.json execute accepts urls 1`] = `
"/* eslint-disable */
/**
 * Generated code, DO NOT modify directly.
 */
import * as z from 'zod';
import { ValidatedResponse } from 'openapi2typescript';
import { Action } from 'react-fetching-library';
import { ValidateRule } from 'openapi2typescript';
import {
    actionBuilder,
    ActionValidatableConfig
} from 'openapi2typescript/react-fetching-library';

export namespace Schemas {
  export const AddAccessRequest = zodSchemaAddAccessRequest();
  export type AddAccessRequest = z.infer<typeof AddAccessRequest>;

  export const AddApplicationRequest = zodSchemaAddApplicationRequest();
  export type AddApplicationRequest = z.infer<typeof AddApplicationRequest>;

  export const AggregationEmailTemplate = zodSchemaAggregationEmailTemplate();
  export type AggregationEmailTemplate = z.infer<
    typeof AggregationEmailTemplate
  >;

  export const Application = zodSchemaApplication();
  export type Application = z.infer<typeof Application>;

  export const Application1 = zodSchemaApplication1();
  export type Application1 = z.infer<typeof Application1>;

  export const BasicAuthentication = zodSchemaBasicAuthentication();
  export type BasicAuthentication = z.infer<typeof BasicAuthentication>;

  export const BehaviorGroup = zodSchemaBehaviorGroup();
  export type BehaviorGroup = z.infer<typeof BehaviorGroup>;

  export const BehaviorGroupAction = zodSchemaBehaviorGroupAction();
  export type BehaviorGroupAction = z.infer<typeof BehaviorGroupAction>;

  export const BehaviorGroupActionId = zodSchemaBehaviorGroupActionId();
  export type BehaviorGroupActionId = z.infer<typeof BehaviorGroupActionId>;

  export const Bundle = zodSchemaBundle();
  export type Bundle = z.infer<typeof Bundle>;

  export const CamelProperties = zodSchemaCamelProperties();
  export type CamelProperties = z.infer<typeof CamelProperties>;

  export const CurrentStatus = zodSchemaCurrentStatus();
  export type CurrentStatus = z.infer<typeof CurrentStatus>;

  export const EmailSubscriptionProperties =
    zodSchemaEmailSubscriptionProperties();
  export type EmailSubscriptionProperties = z.infer<
    typeof EmailSubscriptionProperties
  >;

  export const EmailSubscriptionType = zodSchemaEmailSubscriptionType();
  export type EmailSubscriptionType = z.infer<typeof EmailSubscriptionType>;

  export const Endpoint = zodSchemaEndpoint();
  export type Endpoint = z.infer<typeof Endpoint>;

  export const EndpointPage = zodSchemaEndpointPage();
  export type EndpointPage = z.infer<typeof EndpointPage>;

  export const EndpointProperties = zodSchemaEndpointProperties();
  export type EndpointProperties = z.infer<typeof EndpointProperties>;

  export const EndpointType = zodSchemaEndpointType();
  export type EndpointType = z.infer<typeof EndpointType>;

  export const Environment = zodSchemaEnvironment();
  export type Environment = z.infer<typeof Environment>;

  export const EventLogEntry = zodSchemaEventLogEntry();
  export type EventLogEntry = z.infer<typeof EventLogEntry>;

  export const EventLogEntryAction = zodSchemaEventLogEntryAction();
  export type EventLogEntryAction = z.infer<typeof EventLogEntryAction>;

  export const EventType = zodSchemaEventType();
  export type EventType = z.infer<typeof EventType>;

  export const Facet = zodSchemaFacet();
  export type Facet = z.infer<typeof Facet>;

  export const HttpType = zodSchemaHttpType();
  export type HttpType = z.infer<typeof HttpType>;

  export const InstantEmailTemplate = zodSchemaInstantEmailTemplate();
  export type InstantEmailTemplate = z.infer<typeof InstantEmailTemplate>;

  export const InternalApplicationUserPermission =
    zodSchemaInternalApplicationUserPermission();
  export type InternalApplicationUserPermission = z.infer<
    typeof InternalApplicationUserPermission
  >;

  export const InternalRoleAccess = zodSchemaInternalRoleAccess();
  export type InternalRoleAccess = z.infer<typeof InternalRoleAccess>;

  export const InternalUserPermissions = zodSchemaInternalUserPermissions();
  export type InternalUserPermissions = z.infer<typeof InternalUserPermissions>;

  export const Meta = zodSchemaMeta();
  export type Meta = z.infer<typeof Meta>;

  export const NotificationHistory = zodSchemaNotificationHistory();
  export type NotificationHistory = z.infer<typeof NotificationHistory>;

  export const PageEventLogEntry = zodSchemaPageEventLogEntry();
  export type PageEventLogEntry = z.infer<typeof PageEventLogEntry>;

  export const PageEventType = zodSchemaPageEventType();
  export type PageEventType = z.infer<typeof PageEventType>;

  export const RenderEmailTemplateRequest =
    zodSchemaRenderEmailTemplateRequest();
  export type RenderEmailTemplateRequest = z.infer<
    typeof RenderEmailTemplateRequest
  >;

  export const RequestDefaultBehaviorGroupPropertyList =
    zodSchemaRequestDefaultBehaviorGroupPropertyList();
  export type RequestDefaultBehaviorGroupPropertyList = z.infer<
    typeof RequestDefaultBehaviorGroupPropertyList
  >;

  export const RequestEmailSubscriptionProperties =
    zodSchemaRequestEmailSubscriptionProperties();
  export type RequestEmailSubscriptionProperties = z.infer<
    typeof RequestEmailSubscriptionProperties
  >;

  export const ServerInfo = zodSchemaServerInfo();
  export type ServerInfo = z.infer<typeof ServerInfo>;

  export const Status = zodSchemaStatus();
  export type Status = z.infer<typeof Status>;

  export const Template = zodSchemaTemplate();
  export type Template = z.infer<typeof Template>;

  export const UUID = zodSchemaUUID();
  export type UUID = z.infer<typeof UUID>;

  export const WebhookProperties = zodSchemaWebhookProperties();
  export type WebhookProperties = z.infer<typeof WebhookProperties>;

  export const __Empty = zodSchema__Empty();
  export type __Empty = z.infer<typeof __Empty>;

  function zodSchemaAddAccessRequest() {
      return z.object({
          application_id: zodSchemaUUID().optional().nullable(),
          role: z.string().optional().nullable()
      });
  }

  function zodSchemaAddApplicationRequest() {
      return z.object({
          bundle_id: zodSchemaUUID(),
          display_name: z.string(),
          name: z.string(),
          owner_role: z.string().optional().nullable()
      });
  }

  function zodSchemaAggregationEmailTemplate() {
      return z.object({
          application: zodSchemaApplication().optional().nullable(),
          application_id: zodSchemaUUID().optional().nullable(),
          body_template: zodSchemaTemplate().optional().nullable(),
          body_template_id: zodSchemaUUID(),
          created: z.string().optional().nullable(),
          id: zodSchemaUUID().optional().nullable(),
          subject_template: zodSchemaTemplate().optional().nullable(),
          subject_template_id: zodSchemaUUID(),
          subscription_type: zodSchemaEmailSubscriptionType(),
          updated: z.string().optional().nullable()
      });
  }

  function zodSchemaApplication() {
      return z.object({
          bundle_id: zodSchemaUUID(),
          created: z.string().optional().nullable(),
          display_name: z.string(),
          id: zodSchemaUUID().optional().nullable(),
          name: z.string(),
          updated: z.string().optional().nullable()
      });
  }

  function zodSchemaApplication1() {
      return z.object({
          display_name: z.string(),
          id: zodSchemaUUID()
      });
  }

  function zodSchemaBasicAuthentication() {
      return z.object({
          password: z.string().optional().nullable(),
          username: z.string().optional().nullable()
      });
  }

  function zodSchemaBehaviorGroup() {
      return z.object({
          actions: z.array(zodSchemaBehaviorGroupAction()).optional().nullable(),
          bundle: zodSchemaBundle().optional().nullable(),
          bundle_id: zodSchemaUUID(),
          created: z.string().optional().nullable(),
          default_behavior: z.boolean().optional().nullable(),
          display_name: z.string(),
          id: zodSchemaUUID().optional().nullable(),
          updated: z.string().optional().nullable()
      });
  }

  function zodSchemaBehaviorGroupAction() {
      return z.object({
          created: z.string().optional().nullable(),
          endpoint: zodSchemaEndpoint().optional().nullable(),
          id: zodSchemaBehaviorGroupActionId().optional().nullable()
      });
  }

  function zodSchemaBehaviorGroupActionId() {
      return z.object({
          behaviorGroupId: zodSchemaUUID(),
          endpointId: zodSchemaUUID()
      });
  }

  function zodSchemaBundle() {
      return z.object({
          created: z.string().optional().nullable(),
          display_name: z.string(),
          id: zodSchemaUUID().optional().nullable(),
          name: z.string(),
          updated: z.string().optional().nullable()
      });
  }

  function zodSchemaCamelProperties() {
      return z.object({
          basic_authentication: zodSchemaBasicAuthentication()
          .optional()
          .nullable(),
          disable_ssl_verification: z.boolean(),
          extras: z.record(z.string()).optional().nullable(),
          secret_token: z.string().optional().nullable(),
          sub_type: z.string().optional().nullable(),
          url: z.string()
      });
  }

  function zodSchemaCurrentStatus() {
      return z.object({
          end_time: z.string().optional().nullable(),
          start_time: z.string().optional().nullable(),
          status: zodSchemaStatus()
      });
  }

  function zodSchemaEmailSubscriptionProperties() {
      return z.object({
          group_id: zodSchemaUUID().optional().nullable(),
          ignore_preferences: z.boolean(),
          only_admins: z.boolean()
      });
  }

  function zodSchemaEmailSubscriptionType() {
      return z.enum([ 'INSTANT', 'DAILY' ]);
  }

  function zodSchemaEndpoint() {
      return z.object({
          created: z.string().optional().nullable(),
          description: z.string(),
          enabled: z.boolean().optional().nullable(),
          id: zodSchemaUUID().optional().nullable(),
          name: z.string(),
          properties: z
          .union([
              zodSchemaWebhookProperties(),
              zodSchemaEmailSubscriptionProperties(),
              zodSchemaCamelProperties()
          ])
          .optional()
          .nullable(),
          sub_type: z.string().optional().nullable(),
          type: zodSchemaEndpointType(),
          updated: z.string().optional().nullable()
      });
  }

  function zodSchemaEndpointPage() {
      return z.object({
          data: z.array(zodSchemaEndpoint()),
          links: z.record(z.string()),
          meta: zodSchemaMeta()
      });
  }

  function zodSchemaEndpointProperties() {
      return z.unknown();
  }

  function zodSchemaEndpointType() {
      return z.enum([ 'webhook', 'email_subscription', 'default', 'camel' ]);
  }

  function zodSchemaEnvironment() {
      return z.enum([ 'PROD', 'STAGE', 'EPHEMERAL', 'LOCAL_SERVER' ]);
  }

  function zodSchemaEventLogEntry() {
      return z.object({
          actions: z.array(zodSchemaEventLogEntryAction()),
          application: z.string(),
          bundle: z.string(),
          created: z.string(),
          event_type: z.string(),
          id: zodSchemaUUID(),
          payload: z.string().optional().nullable()
      });
  }

  function zodSchemaEventLogEntryAction() {
      return z.object({
          details: z.record(z.unknown()).optional().nullable(),
          endpoint_id: zodSchemaUUID().optional().nullable(),
          endpoint_sub_type: z.string().optional().nullable(),
          endpoint_type: zodSchemaEndpointType(),
          id: zodSchemaUUID(),
          invocation_result: z.boolean()
      });
  }

  function zodSchemaEventType() {
      return z.object({
          application: zodSchemaApplication().optional().nullable(),
          application_id: zodSchemaUUID(),
          description: z.string().optional().nullable(),
          display_name: z.string(),
          id: zodSchemaUUID().optional().nullable(),
          name: z.string()
      });
  }

  function zodSchemaFacet() {
      return z.object({
          children: z
          .array(z.lazy(() => zodSchemaFacet()))
          .optional()
          .nullable(),
          displayName: z.string(),
          id: z.string(),
          name: z.string()
      });
  }

  function zodSchemaHttpType() {
      return z.enum([ 'GET', 'POST', 'PUT' ]);
  }

  function zodSchemaInstantEmailTemplate() {
      return z.object({
          body_template: zodSchemaTemplate().optional().nullable(),
          body_template_id: zodSchemaUUID(),
          created: z.string().optional().nullable(),
          event_type: zodSchemaEventType().optional().nullable(),
          event_type_id: zodSchemaUUID().optional().nullable(),
          id: zodSchemaUUID().optional().nullable(),
          subject_template: zodSchemaTemplate().optional().nullable(),
          subject_template_id: zodSchemaUUID(),
          updated: z.string().optional().nullable()
      });
  }

  function zodSchemaInternalApplicationUserPermission() {
      return z.object({
          application_display_name: z.string(),
          application_id: zodSchemaUUID(),
          role: z.string()
      });
  }

  function zodSchemaInternalRoleAccess() {
      return z.object({
          application_id: zodSchemaUUID(),
          id: zodSchemaUUID().optional().nullable(),
          role: z.string()
      });
  }

  function zodSchemaInternalUserPermissions() {
      return z.object({
          applications: z.array(zodSchemaApplication1()),
          is_admin: z.boolean(),
          roles: z.array(z.string())
      });
  }

  function zodSchemaMeta() {
      return z.object({
          count: z.number().int()
      });
  }

  function zodSchemaNotificationHistory() {
      return z.object({
          created: z.string().optional().nullable(),
          details: z.record(z.unknown()).optional().nullable(),
          endpointId: zodSchemaUUID().optional().nullable(),
          endpointSubType: z.string().optional().nullable(),
          endpointType: zodSchemaEndpointType().optional().nullable(),
          id: zodSchemaUUID().optional().nullable(),
          invocationResult: z.boolean(),
          invocationTime: z.number().int()
      });
  }

  function zodSchemaPageEventLogEntry() {
      return z.object({
          data: z.array(zodSchemaEventLogEntry()),
          links: z.record(z.string()),
          meta: zodSchemaMeta()
      });
  }

  function zodSchemaPageEventType() {
      return z.object({
          data: z.array(zodSchemaEventType()),
          links: z.record(z.string()),
          meta: zodSchemaMeta()
      });
  }

  function zodSchemaRenderEmailTemplateRequest() {
      return z.object({
          body_template: z.string(),
          payload: z.string(),
          subject_template: z.string()
      });
  }

  function zodSchemaRequestDefaultBehaviorGroupPropertyList() {
      return z.object({
          ignore_preferences: z.boolean(),
          only_admins: z.boolean()
      });
  }

  function zodSchemaRequestEmailSubscriptionProperties() {
      return z.object({
          group_id: zodSchemaUUID().optional().nullable(),
          only_admins: z.boolean()
      });
  }

  function zodSchemaServerInfo() {
      return z.object({
          environment: zodSchemaEnvironment().optional().nullable()
      });
  }

  function zodSchemaStatus() {
      return z.enum([ 'UP', 'MAINTENANCE' ]);
  }

  function zodSchemaTemplate() {
      return z.object({
          created: z.string().optional().nullable(),
          data: z.string(),
          description: z.string(),
          id: zodSchemaUUID().optional().nullable(),
          name: z.string(),
          updated: z.string().optional().nullable()
      });
  }

  function zodSchemaUUID() {
      return z.string();
  }

  function zodSchemaWebhookProperties() {
      return z.object({
          basic_authentication: zodSchemaBasicAuthentication()
          .optional()
          .nullable(),
          disable_ssl_verification: z.boolean(),
          method: zodSchemaHttpType(),
          secret_token: z.string().optional().nullable(),
          url: z.string()
      });
  }

  function zodSchema__Empty() {
      return z.string().max(0).optional();
  }
}

export namespace Operations {
  // POST /notifications/behaviorGroups
  // Create a behavior group.
  export namespace NotificationResourceCreateBehaviorGroup {
    export interface Params {
      body: Schemas.BehaviorGroup;
    }

    export type Payload =
      | ValidatedResponse<'BehaviorGroup', 200, Schemas.BehaviorGroup>
      | ValidatedResponse<'__Empty', 401, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 403, Schemas.__Empty>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/api/notifications/v1.0/notifications/behaviorGroups';
        const query = {} as Record<string, any>;
        return actionBuilder('POST', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [
                new ValidateRule(Schemas.BehaviorGroup, 'BehaviorGroup', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.__Empty, '__Empty', 403)
            ]
        })
        .build();
    };
  }
  // GET /notifications/behaviorGroups/affectedByRemovalOfEndpoint/{endpointId}
  // Retrieve the behavior groups affected by the removal of an endpoint.
  export namespace NotificationResourceGetBehaviorGroupsAffectedByRemovalOfEndpoint {
    const Response200 = z.array(Schemas.BehaviorGroup);
    type Response200 = z.infer<typeof Response200>;
    export interface Params {
      endpointId: Schemas.UUID;
    }

    export type Payload =
      | ValidatedResponse<'unknown', 200, Response200>
      | ValidatedResponse<'__Empty', 401, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 403, Schemas.__Empty>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path =
        '/api/notifications/v1.0/notifications/behaviorGroups/affectedByRemovalOfEndpoint/{endpointId}'.replace(
            '{endpointId}',
            params.endpointId.toString()
        );
        const query = {} as Record<string, any>;
        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Response200, 'unknown', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.__Empty, '__Empty', 403)
            ]
        })
        .build();
    };
  }
  // PUT /notifications/behaviorGroups/{behaviorGroupId}/actions
  // Update the list of actions of a behavior group.
  export namespace NotificationResourceUpdateBehaviorGroupActions {
    const Body = z.array(z.string());
    type Body = z.infer<typeof Body>;
    const Response200 = z.string();
    type Response200 = z.infer<typeof Response200>;
    export interface Params {
      behaviorGroupId: Schemas.UUID;
      body: Body;
    }

    export type Payload =
      | ValidatedResponse<'unknown', 200, Response200>
      | ValidatedResponse<'__Empty', 401, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 403, Schemas.__Empty>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path =
        '/api/notifications/v1.0/notifications/behaviorGroups/{behaviorGroupId}/actions'.replace(
            '{behaviorGroupId}',
            params.behaviorGroupId.toString()
        );
        const query = {} as Record<string, any>;
        return actionBuilder('PUT', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [
                new ValidateRule(Response200, 'unknown', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.__Empty, '__Empty', 403)
            ]
        })
        .build();
    };
  }
  // PUT /notifications/behaviorGroups/{id}
  // Update a behavior group.
  export namespace NotificationResourceUpdateBehaviorGroup {
    const Response200 = z.boolean();
    type Response200 = z.infer<typeof Response200>;
    export interface Params {
      id: Schemas.UUID;
      body: Schemas.BehaviorGroup;
    }

    export type Payload =
      | ValidatedResponse<'unknown', 200, Response200>
      | ValidatedResponse<'__Empty', 401, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 403, Schemas.__Empty>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path =
        '/api/notifications/v1.0/notifications/behaviorGroups/{id}'.replace(
            '{id}',
            params.id.toString()
        );
        const query = {} as Record<string, any>;
        return actionBuilder('PUT', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [
                new ValidateRule(Response200, 'unknown', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.__Empty, '__Empty', 403)
            ]
        })
        .build();
    };
  }
  // DELETE /notifications/behaviorGroups/{id}
  // Delete a behavior group.
  export namespace NotificationResourceDeleteBehaviorGroup {
    const Response200 = z.boolean();
    type Response200 = z.infer<typeof Response200>;
    export interface Params {
      id: Schemas.UUID;
    }

    export type Payload =
      | ValidatedResponse<'unknown', 200, Response200>
      | ValidatedResponse<'__Empty', 401, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 403, Schemas.__Empty>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path =
        '/api/notifications/v1.0/notifications/behaviorGroups/{id}'.replace(
            '{id}',
            params.id.toString()
        );
        const query = {} as Record<string, any>;
        return actionBuilder('DELETE', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Response200, 'unknown', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.__Empty, '__Empty', 403)
            ]
        })
        .build();
    };
  }
  // GET /notifications/bundles/{bundleId}/behaviorGroups
  // Retrieve the behavior groups of a bundle.
  export namespace NotificationResourceFindBehaviorGroupsByBundleId {
    const Response200 = z.array(Schemas.BehaviorGroup);
    type Response200 = z.infer<typeof Response200>;
    export interface Params {
      bundleId: Schemas.UUID;
    }

    export type Payload =
      | ValidatedResponse<'unknown', 200, Response200>
      | ValidatedResponse<'__Empty', 401, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 403, Schemas.__Empty>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path =
        '/api/notifications/v1.0/notifications/bundles/{bundleId}/behaviorGroups'.replace(
            '{bundleId}',
            params.bundleId.toString()
        );
        const query = {} as Record<string, any>;
        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Response200, 'unknown', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.__Empty, '__Empty', 403)
            ]
        })
        .build();
    };
  }
  // GET /notifications/eventTypes
  // Retrieve all event types. The returned list can be filtered by bundle or application.
  export namespace NotificationResourceGetEventTypes {
    const ApplicationIds = z.array(z.string());
    type ApplicationIds = z.infer<typeof ApplicationIds>;
    const Limit = z.number().int();
    type Limit = z.infer<typeof Limit>;
    const Offset = z.number().int();
    type Offset = z.infer<typeof Offset>;
    const PageNumber = z.number().int();
    type PageNumber = z.infer<typeof PageNumber>;
    const SortBy = z.string();
    type SortBy = z.infer<typeof SortBy>;
    export interface Params {
      applicationIds?: ApplicationIds;
      bundleId?: Schemas.UUID;
      limit?: Limit;
      offset?: Offset;
      pageNumber?: PageNumber;
      sortBy?: SortBy;
    }

    export type Payload =
      | ValidatedResponse<'PageEventType', 200, Schemas.PageEventType>
      | ValidatedResponse<'__Empty', 401, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 403, Schemas.__Empty>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/api/notifications/v1.0/notifications/eventTypes';
        const query = {} as Record<string, any>;
        if (params.applicationIds !== undefined) {
            query.applicationIds = params.applicationIds;
        }

        if (params.bundleId !== undefined) {
            query.bundleId = params.bundleId;
        }

        if (params.limit !== undefined) {
            query.limit = params.limit;
        }

        if (params.offset !== undefined) {
            query.offset = params.offset;
        }

        if (params.pageNumber !== undefined) {
            query.pageNumber = params.pageNumber;
        }

        if (params.sortBy !== undefined) {
            query.sort_by = params.sortBy;
        }

        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Schemas.PageEventType, 'PageEventType', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.__Empty, '__Empty', 403)
            ]
        })
        .build();
    };
  }
  // GET /notifications/eventTypes/affectedByRemovalOfBehaviorGroup/{behaviorGroupId}
  // Retrieve the event types affected by the removal of a behavior group.
  export namespace NotificationResourceGetEventTypesAffectedByRemovalOfBehaviorGroup {
    const Response200 = z.array(Schemas.EventType);
    type Response200 = z.infer<typeof Response200>;
    export interface Params {
      behaviorGroupId: Schemas.UUID;
    }

    export type Payload =
      | ValidatedResponse<'unknown', 200, Response200>
      | ValidatedResponse<'__Empty', 401, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 403, Schemas.__Empty>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path =
        '/api/notifications/v1.0/notifications/eventTypes/affectedByRemovalOfBehaviorGroup/{behaviorGroupId}'.replace(
            '{behaviorGroupId}',
            params.behaviorGroupId.toString()
        );
        const query = {} as Record<string, any>;
        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Response200, 'unknown', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.__Empty, '__Empty', 403)
            ]
        })
        .build();
    };
  }
  // GET /notifications/eventTypes/{eventTypeId}/behaviorGroups
  // Retrieve the behavior groups linked to an event type.
  export namespace NotificationResourceGetLinkedBehaviorGroups {
    const Limit = z.number().int();
    type Limit = z.infer<typeof Limit>;
    const Offset = z.number().int();
    type Offset = z.infer<typeof Offset>;
    const PageNumber = z.number().int();
    type PageNumber = z.infer<typeof PageNumber>;
    const SortBy = z.string();
    type SortBy = z.infer<typeof SortBy>;
    const Response200 = z.array(Schemas.BehaviorGroup);
    type Response200 = z.infer<typeof Response200>;
    export interface Params {
      eventTypeId: Schemas.UUID;
      limit?: Limit;
      offset?: Offset;
      pageNumber?: PageNumber;
      sortBy?: SortBy;
    }

    export type Payload =
      | ValidatedResponse<'unknown', 200, Response200>
      | ValidatedResponse<'__Empty', 401, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 403, Schemas.__Empty>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path =
        '/api/notifications/v1.0/notifications/eventTypes/{eventTypeId}/behaviorGroups'.replace(
            '{eventTypeId}',
            params.eventTypeId.toString()
        );
        const query = {} as Record<string, any>;
        if (params.limit !== undefined) {
            query.limit = params.limit;
        }

        if (params.offset !== undefined) {
            query.offset = params.offset;
        }

        if (params.pageNumber !== undefined) {
            query.pageNumber = params.pageNumber;
        }

        if (params.sortBy !== undefined) {
            query.sort_by = params.sortBy;
        }

        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Response200, 'unknown', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.__Empty, '__Empty', 403)
            ]
        })
        .build();
    };
  }
  // PUT /notifications/eventTypes/{eventTypeId}/behaviorGroups
  // Update the list of behavior groups of an event type.
  export namespace NotificationResourceUpdateEventTypeBehaviors {
    const Body = z.array(z.string());
    type Body = z.infer<typeof Body>;
    const Response200 = z.string();
    type Response200 = z.infer<typeof Response200>;
    export interface Params {
      eventTypeId: Schemas.UUID;
      body: Body;
    }

    export type Payload =
      | ValidatedResponse<'unknown', 200, Response200>
      | ValidatedResponse<'__Empty', 401, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 403, Schemas.__Empty>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path =
        '/api/notifications/v1.0/notifications/eventTypes/{eventTypeId}/behaviorGroups'.replace(
            '{eventTypeId}',
            params.eventTypeId.toString()
        );
        const query = {} as Record<string, any>;
        return actionBuilder('PUT', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [
                new ValidateRule(Response200, 'unknown', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.__Empty, '__Empty', 403)
            ]
        })
        .build();
    };
  }
  // GET /notifications/events
  // Retrieve the event log entries.
  export namespace EventResourceGetEvents {
    const AppIds = z.array(z.string());
    type AppIds = z.infer<typeof AppIds>;
    const BundleIds = z.array(z.string());
    type BundleIds = z.infer<typeof BundleIds>;
    const EndDate = z.string();
    type EndDate = z.infer<typeof EndDate>;
    const EndpointTypes = z.array(z.string());
    type EndpointTypes = z.infer<typeof EndpointTypes>;
    const EventTypeDisplayName = z.string();
    type EventTypeDisplayName = z.infer<typeof EventTypeDisplayName>;
    const IncludeActions = z.boolean();
    type IncludeActions = z.infer<typeof IncludeActions>;
    const IncludeDetails = z.boolean();
    type IncludeDetails = z.infer<typeof IncludeDetails>;
    const IncludePayload = z.boolean();
    type IncludePayload = z.infer<typeof IncludePayload>;
    const InvocationResults = z.array(z.boolean());
    type InvocationResults = z.infer<typeof InvocationResults>;
    const Limit = z.number().int();
    type Limit = z.infer<typeof Limit>;
    const Offset = z.number().int();
    type Offset = z.infer<typeof Offset>;
    const SortBy = z.string();
    type SortBy = z.infer<typeof SortBy>;
    const StartDate = z.string();
    type StartDate = z.infer<typeof StartDate>;
    export interface Params {
      appIds?: AppIds;
      bundleIds?: BundleIds;
      endDate?: EndDate;
      endpointTypes?: EndpointTypes;
      eventTypeDisplayName?: EventTypeDisplayName;
      includeActions?: IncludeActions;
      includeDetails?: IncludeDetails;
      includePayload?: IncludePayload;
      invocationResults?: InvocationResults;
      limit?: Limit;
      offset?: Offset;
      sortBy?: SortBy;
      startDate?: StartDate;
    }

    export type Payload =
      | ValidatedResponse<'PageEventLogEntry', 200, Schemas.PageEventLogEntry>
      | ValidatedResponse<'__Empty', 401, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 403, Schemas.__Empty>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/api/notifications/v1.0/notifications/events';
        const query = {} as Record<string, any>;
        if (params.appIds !== undefined) {
            query.appIds = params.appIds;
        }

        if (params.bundleIds !== undefined) {
            query.bundleIds = params.bundleIds;
        }

        if (params.endDate !== undefined) {
            query.endDate = params.endDate;
        }

        if (params.endpointTypes !== undefined) {
            query.endpointTypes = params.endpointTypes;
        }

        if (params.eventTypeDisplayName !== undefined) {
            query.eventTypeDisplayName = params.eventTypeDisplayName;
        }

        if (params.includeActions !== undefined) {
            query.includeActions = params.includeActions;
        }

        if (params.includeDetails !== undefined) {
            query.includeDetails = params.includeDetails;
        }

        if (params.includePayload !== undefined) {
            query.includePayload = params.includePayload;
        }

        if (params.invocationResults !== undefined) {
            query.invocationResults = params.invocationResults;
        }

        if (params.limit !== undefined) {
            query.limit = params.limit;
        }

        if (params.offset !== undefined) {
            query.offset = params.offset;
        }

        if (params.sortBy !== undefined) {
            query.sortBy = params.sortBy;
        }

        if (params.startDate !== undefined) {
            query.startDate = params.startDate;
        }

        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(
                    Schemas.PageEventLogEntry,
                    'PageEventLogEntry',
                    200
                ),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.__Empty, '__Empty', 403)
            ]
        })
        .build();
    };
  }
  // GET /notifications/facets/applications
  // Return a thin list of configured applications. This can be used to configure a filter in the UI
  export namespace NotificationResourceGetApplicationsFacets {
    const BundleName = z.string();
    type BundleName = z.infer<typeof BundleName>;
    const Response200 = z.array(Schemas.Facet);
    type Response200 = z.infer<typeof Response200>;
    export interface Params {
      bundleName?: BundleName;
    }

    export type Payload =
      | ValidatedResponse<'unknown', 200, Response200>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/api/notifications/v1.0/notifications/facets/applications';
        const query = {} as Record<string, any>;
        if (params.bundleName !== undefined) {
            query.bundleName = params.bundleName;
        }

        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [ new ValidateRule(Response200, 'unknown', 200) ]
        })
        .build();
    };
  }
  // GET /notifications/facets/bundles
  // Return a thin list of configured bundles. This can be used to configure a filter in the UI
  export namespace NotificationResourceGetBundleFacets {
    const IncludeApplications = z.boolean();
    type IncludeApplications = z.infer<typeof IncludeApplications>;
    const Response200 = z.array(Schemas.Facet);
    type Response200 = z.infer<typeof Response200>;
    export interface Params {
      includeApplications?: IncludeApplications;
    }

    export type Payload =
      | ValidatedResponse<'unknown', 200, Response200>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/api/notifications/v1.0/notifications/facets/bundles';
        const query = {} as Record<string, any>;
        if (params.includeApplications !== undefined) {
            query.includeApplications = params.includeApplications;
        }

        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [ new ValidateRule(Response200, 'unknown', 200) ]
        })
        .build();
    };
  }
  // DELETE /notifications/{id}
  export namespace NotificationResourceMarkRead {
    const Id = z.number().int();
    type Id = z.infer<typeof Id>;
    const Response204 = z.string();
    type Response204 = z.infer<typeof Response204>;
    export interface Params {
      id: Id;
    }

    export type Payload =
      | ValidatedResponse<'unknown', 204, Response204>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/api/notifications/v1.0/notifications/{id}'.replace(
            '{id}',
            params.id.toString()
        );
        const query = {} as Record<string, any>;
        return actionBuilder('DELETE', path)
        .queryParams(query)
        .config({
            rules: [ new ValidateRule(Response204, 'unknown', 204) ]
        })
        .build();
    };
  }
}
"
`;

exports[`src/cli/schema execute for ./tests/__fixtures__/notifications-openapi.json execute input file accepts path: compiled 1`] = `
"\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.Operations = exports.Schemas = void 0;
/* eslint-disable */
/**
 * Generated code, DO NOT modify directly.
 */
var z = require(\\"zod\\");
var openapi2typescript_1 = require(\\"openapi2typescript\\");
var react_fetching_library_1 = require(\\"openapi2typescript/react-fetching-library\\");
var Schemas;
(function (Schemas) {
    Schemas.AddAccessRequest = zodSchemaAddAccessRequest();
    Schemas.AddApplicationRequest = zodSchemaAddApplicationRequest();
    Schemas.AggregationEmailTemplate = zodSchemaAggregationEmailTemplate();
    Schemas.Application = zodSchemaApplication();
    Schemas.Application1 = zodSchemaApplication1();
    Schemas.BasicAuthentication = zodSchemaBasicAuthentication();
    Schemas.BehaviorGroup = zodSchemaBehaviorGroup();
    Schemas.BehaviorGroupAction = zodSchemaBehaviorGroupAction();
    Schemas.BehaviorGroupActionId = zodSchemaBehaviorGroupActionId();
    Schemas.Bundle = zodSchemaBundle();
    Schemas.CamelProperties = zodSchemaCamelProperties();
    Schemas.CurrentStatus = zodSchemaCurrentStatus();
    Schemas.EmailSubscriptionProperties = zodSchemaEmailSubscriptionProperties();
    Schemas.EmailSubscriptionType = zodSchemaEmailSubscriptionType();
    Schemas.Endpoint = zodSchemaEndpoint();
    Schemas.EndpointPage = zodSchemaEndpointPage();
    Schemas.EndpointProperties = zodSchemaEndpointProperties();
    Schemas.EndpointType = zodSchemaEndpointType();
    Schemas.Environment = zodSchemaEnvironment();
    Schemas.EventLogEntry = zodSchemaEventLogEntry();
    Schemas.EventLogEntryAction = zodSchemaEventLogEntryAction();
    Schemas.EventType = zodSchemaEventType();
    Schemas.Facet = zodSchemaFacet();
    Schemas.HttpType = zodSchemaHttpType();
    Schemas.InstantEmailTemplate = zodSchemaInstantEmailTemplate();
    Schemas.InternalApplicationUserPermission = zodSchemaInternalApplicationUserPermission();
    Schemas.InternalRoleAccess = zodSchemaInternalRoleAccess();
    Schemas.InternalUserPermissions = zodSchemaInternalUserPermissions();
    Schemas.Meta = zodSchemaMeta();
    Schemas.NotificationHistory = zodSchemaNotificationHistory();
    Schemas.PageEventLogEntry = zodSchemaPageEventLogEntry();
    Schemas.PageEventType = zodSchemaPageEventType();
    Schemas.RenderEmailTemplateRequest = zodSchemaRenderEmailTemplateRequest();
    Schemas.RequestDefaultBehaviorGroupPropertyList = zodSchemaRequestDefaultBehaviorGroupPropertyList();
    Schemas.RequestEmailSubscriptionProperties = zodSchemaRequestEmailSubscriptionProperties();
    Schemas.ServerInfo = zodSchemaServerInfo();
    Schemas.Status = zodSchemaStatus();
    Schemas.Template = zodSchemaTemplate();
    Schemas.UUID = zodSchemaUUID();
    Schemas.WebhookProperties = zodSchemaWebhookProperties();
    Schemas.__Empty = zodSchema__Empty();
    function zodSchemaAddAccessRequest() {
        return z.object({
            application_id: zodSchemaUUID().optional().nullable(),
            role: z.string().optional().nullable()
        });
    }
    function zodSchemaAddApplicationRequest() {
        return z.object({
            bundle_id: zodSchemaUUID(),
            display_name: z.string(),
            name: z.string(),
            owner_role: z.string().optional().nullable()
        });
    }
    function zodSchemaAggregationEmailTemplate() {
        return z.object({
            application: zodSchemaApplication().optional().nullable(),
            application_id: zodSchemaUUID().optional().nullable(),
            body_template: zodSchemaTemplate().optional().nullable(),
            body_template_id: zodSchemaUUID(),
            created: z.string().optional().nullable(),
            id: zodSchemaUUID().optional().nullable(),
            subject_template: zodSchemaTemplate().optional().nullable(),
            subject_template_id: zodSchemaUUID(),
            subscription_type: zodSchemaEmailSubscriptionType(),
            updated: z.string().optional().nullable()
        });
    }
    function zodSchemaApplication() {
        return z.object({
            bundle_id: zodSchemaUUID(),
            created: z.string().optional().nullable(),
            display_name: z.string(),
            id: zodSchemaUUID().optional().nullable(),
            name: z.string(),
            updated: z.string().optional().nullable()
        });
    }
    function zodSchemaApplication1() {
        return z.object({
            display_name: z.string(),
            id: zodSchemaUUID()
        });
    }
    function zodSchemaBasicAuthentication() {
        return z.object({
            password: z.string().optional().nullable(),
            username: z.string().optional().nullable()
        });
    }
    function zodSchemaBehaviorGroup() {
        return z.object({
            actions: z.array(zodSchemaBehaviorGroupAction()).optional().nullable(),
            bundle: zodSchemaBundle().optional().nullable(),
            bundle_id: zodSchemaUUID(),
            created: z.string().optional().nullable(),
            default_behavior: z.boolean().optional().nullable(),
            display_name: z.string(),
            id: zodSchemaUUID().optional().nullable(),
            updated: z.string().optional().nullable()
        });
    }
    function zodSchemaBehaviorGroupAction() {
        return z.object({
            created: z.string().optional().nullable(),
            endpoint: zodSchemaEndpoint().optional().nullable(),
            id: zodSchemaBehaviorGroupActionId().optional().nullable()
        });
    }
    function zodSchemaBehaviorGroupActionId() {
        return z.object({
            behaviorGroupId: zodSchemaUUID(),
            endpointId: zodSchemaUUID()
        });
    }
    function zodSchemaBundle() {
        return z.object({
            created: z.string().optional().nullable(),
            display_name: z.string(),
            id: zodSchemaUUID().optional().nullable(),
            name: z.string(),
            updated: z.string().optional().nullable()
        });
    }
    function zodSchemaCamelProperties() {
        return z.object({
            basic_authentication: zodSchemaBasicAuthentication()
                .optional()
                .nullable(),
            disable_ssl_verification: z.boolean(),
            extras: z.record(z.string()).optional().nullable(),
            secret_token: z.string().optional().nullable(),
            sub_type: z.string().optional().nullable(),
            url: z.string()
        });
    }
    function zodSchemaCurrentStatus() {
        return z.object({
            end_time: z.string().optional().nullable(),
            start_time: z.string().optional().nullable(),
            status: zodSchemaStatus()
        });
    }
    function zodSchemaEmailSubscriptionProperties() {
        return z.object({
            group_id: zodSchemaUUID().optional().nullable(),
            ignore_preferences: z.boolean(),
            only_admins: z.boolean()
        });
    }
    function zodSchemaEmailSubscriptionType() {
        return z.enum(['INSTANT', 'DAILY']);
    }
    function zodSchemaEndpoint() {
        return z.object({
            created: z.string().optional().nullable(),
            description: z.string(),
            enabled: z.boolean().optional().nullable(),
            id: zodSchemaUUID().optional().nullable(),
            name: z.string(),
            properties: z
                .union([
                zodSchemaWebhookProperties(),
                zodSchemaEmailSubscriptionProperties(),
                zodSchemaCamelProperties()
            ])
                .optional()
                .nullable(),
            sub_type: z.string().optional().nullable(),
            type: zodSchemaEndpointType(),
            updated: z.string().optional().nullable()
        });
    }
    function zodSchemaEndpointPage() {
        return z.object({
            data: z.array(zodSchemaEndpoint()),
            links: z.record(z.string()),
            meta: zodSchemaMeta()
        });
    }
    function zodSchemaEndpointProperties() {
        return z.unknown();
    }
    function zodSchemaEndpointType() {
        return z.enum(['webhook', 'email_subscription', 'default', 'camel']);
    }
    function zodSchemaEnvironment() {
        return z.enum(['PROD', 'STAGE', 'EPHEMERAL', 'LOCAL_SERVER']);
    }
    function zodSchemaEventLogEntry() {
        return z.object({
            actions: z.array(zodSchemaEventLogEntryAction()),
            application: z.string(),
            bundle: z.string(),
            created: z.string(),
            event_type: z.string(),
            id: zodSchemaUUID(),
            payload: z.string().optional().nullable()
        });
    }
    function zodSchemaEventLogEntryAction() {
        return z.object({
            details: z.record(z.unknown()).optional().nullable(),
            endpoint_id: zodSchemaUUID().optional().nullable(),
            endpoint_sub_type: z.string().optional().nullable(),
            endpoint_type: zodSchemaEndpointType(),
            id: zodSchemaUUID(),
            invocation_result: z.boolean()
        });
    }
    function zodSchemaEventType() {
        return z.object({
            application: zodSchemaApplication().optional().nullable(),
            application_id: zodSchemaUUID(),
            description: z.string().optional().nullable(),
            display_name: z.string(),
            id: zodSchemaUUID().optional().nullable(),
            name: z.string()
        });
    }
    function zodSchemaFacet() {
        return z.object({
            children: z
                .array(z.lazy(function () { return zodSchemaFacet(); }))
                .optional()
                .nullable(),
            displayName: z.string(),
            id: z.string(),
            name: z.string()
        });
    }
    function zodSchemaHttpType() {
        return z.enum(['GET', 'POST', 'PUT']);
    }
    function zodSchemaInstantEmailTemplate() {
        return z.object({
            body_template: zodSchemaTemplate().optional().nullable(),
            body_template_id: zodSchemaUUID(),
            created: z.string().optional().nullable(),
            event_type: zodSchemaEventType().optional().nullable(),
            event_type_id: zodSchemaUUID().optional().nullable(),
            id: zodSchemaUUID().optional().nullable(),
            subject_template: zodSchemaTemplate().optional().nullable(),
            subject_template_id: zodSchemaUUID(),
            updated: z.string().optional().nullable()
        });
    }
    function zodSchemaInternalApplicationUserPermission() {
        return z.object({
            application_display_name: z.string(),
            application_id: zodSchemaUUID(),
            role: z.string()
        });
    }
    function zodSchemaInternalRoleAccess() {
        return z.object({
            application_id: zodSchemaUUID(),
            id: zodSchemaUUID().optional().nullable(),
            role: z.string()
        });
    }
    function zodSchemaInternalUserPermissions() {
        return z.object({
            applications: z.array(zodSchemaApplication1()),
            is_admin: z.boolean(),
            roles: z.array(z.string())
        });
    }
    function zodSchemaMeta() {
        return z.object({
            count: z.number().int()
        });
    }
    function zodSchemaNotificationHistory() {
        return z.object({
            created: z.string().optional().nullable(),
            details: z.record(z.unknown()).optional().nullable(),
            endpointId: zodSchemaUUID().optional().nullable(),
            endpointSubType: z.string().optional().nullable(),
            endpointType: zodSchemaEndpointType().optional().nullable(),
            id: zodSchemaUUID().optional().nullable(),
            invocationResult: z.boolean(),
            invocationTime: z.number().int()
        });
    }
    function zodSchemaPageEventLogEntry() {
        return z.object({
            data: z.array(zodSchemaEventLogEntry()),
            links: z.record(z.string()),
            meta: zodSchemaMeta()
        });
    }
    function zodSchemaPageEventType() {
        return z.object({
            data: z.array(zodSchemaEventType()),
            links: z.record(z.string()),
            meta: zodSchemaMeta()
        });
    }
    function zodSchemaRenderEmailTemplateRequest() {
        return z.object({
            body_template: z.string(),
            payload: z.string(),
            subject_template: z.string()
        });
    }
    function zodSchemaRequestDefaultBehaviorGroupPropertyList() {
        return z.object({
            ignore_preferences: z.boolean(),
            only_admins: z.boolean()
        });
    }
    function zodSchemaRequestEmailSubscriptionProperties() {
        return z.object({
            group_id: zodSchemaUUID().optional().nullable(),
            only_admins: z.boolean()
        });
    }
    function zodSchemaServerInfo() {
        return z.object({
            environment: zodSchemaEnvironment().optional().nullable()
        });
    }
    function zodSchemaStatus() {
        return z.enum(['UP', 'MAINTENANCE']);
    }
    function zodSchemaTemplate() {
        return z.object({
            created: z.string().optional().nullable(),
            data: z.string(),
            description: z.string(),
            id: zodSchemaUUID().optional().nullable(),
            name: z.string(),
            updated: z.string().optional().nullable()
        });
    }
    function zodSchemaUUID() {
        return z.string();
    }
    function zodSchemaWebhookProperties() {
        return z.object({
            basic_authentication: zodSchemaBasicAuthentication()
                .optional()
                .nullable(),
            disable_ssl_verification: z.boolean(),
            method: zodSchemaHttpType(),
            secret_token: z.string().optional().nullable(),
            url: z.string()
        });
    }
    function zodSchema__Empty() {
        return z.string().max(0).optional();
    }
})(Schemas = exports.Schemas || (exports.Schemas = {}));
var Operations;
(function (Operations) {
    // POST /notifications/behaviorGroups
    // Create a behavior group.
    var NotificationResourceCreateBehaviorGroup;
    (function (NotificationResourceCreateBehaviorGroup) {
        /*
     Params
    body: Schemas.BehaviorGroup
    */
        NotificationResourceCreateBehaviorGroup.actionCreator = function (params) {
            var path = '/api/notifications/v1.0/notifications/behaviorGroups';
            var query = {};
            return (0, react_fetching_library_1.actionBuilder)('POST', path)
                .queryParams(query)
                .data(params.body)
                .config({
                rules: [
                    new openapi2typescript_1.ValidateRule(Schemas.BehaviorGroup, 'BehaviorGroup', 200),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 401),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 403)
                ]
            })
                .build();
        };
    })(NotificationResourceCreateBehaviorGroup = Operations.NotificationResourceCreateBehaviorGroup || (Operations.NotificationResourceCreateBehaviorGroup = {}));
    // GET /notifications/behaviorGroups/affectedByRemovalOfEndpoint/{endpointId}
    // Retrieve the behavior groups affected by the removal of an endpoint.
    var NotificationResourceGetBehaviorGroupsAffectedByRemovalOfEndpoint;
    (function (NotificationResourceGetBehaviorGroupsAffectedByRemovalOfEndpoint) {
        var Response200 = z.array(Schemas.BehaviorGroup);
        /*
     Params
    'endpointId':Schemas.UUID
    */
        NotificationResourceGetBehaviorGroupsAffectedByRemovalOfEndpoint.actionCreator = function (params) {
            var path = '/api/notifications/v1.0/notifications/behaviorGroups/affectedByRemovalOfEndpoint/{endpointId}'.replace('{endpointId}', params.endpointId.toString());
            var query = {};
            return (0, react_fetching_library_1.actionBuilder)('GET', path)
                .queryParams(query)
                .config({
                rules: [
                    new openapi2typescript_1.ValidateRule(Response200, 'unknown', 200),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 401),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 403)
                ]
            })
                .build();
        };
    })(NotificationResourceGetBehaviorGroupsAffectedByRemovalOfEndpoint = Operations.NotificationResourceGetBehaviorGroupsAffectedByRemovalOfEndpoint || (Operations.NotificationResourceGetBehaviorGroupsAffectedByRemovalOfEndpoint = {}));
    // PUT /notifications/behaviorGroups/{behaviorGroupId}/actions
    // Update the list of actions of a behavior group.
    var NotificationResourceUpdateBehaviorGroupActions;
    (function (NotificationResourceUpdateBehaviorGroupActions) {
        var Body = z.array(z.string());
        var Response200 = z.string();
        /*
     Params
    'behaviorGroupId':Schemas.UUID,
    body: Body
    */
        NotificationResourceUpdateBehaviorGroupActions.actionCreator = function (params) {
            var path = '/api/notifications/v1.0/notifications/behaviorGroups/{behaviorGroupId}/actions'.replace('{behaviorGroupId}', params.behaviorGroupId.toString());
            var query = {};
            return (0, react_fetching_library_1.actionBuilder)('PUT', path)
                .queryParams(query)
                .data(params.body)
                .config({
                rules: [
                    new openapi2typescript_1.ValidateRule(Response200, 'unknown', 200),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 401),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 403)
                ]
            })
                .build();
        };
    })(NotificationResourceUpdateBehaviorGroupActions = Operations.NotificationResourceUpdateBehaviorGroupActions || (Operations.NotificationResourceUpdateBehaviorGroupActions = {}));
    // PUT /notifications/behaviorGroups/{id}
    // Update a behavior group.
    var NotificationResourceUpdateBehaviorGroup;
    (function (NotificationResourceUpdateBehaviorGroup) {
        var Response200 = z.boolean();
        /*
     Params
    'id':Schemas.UUID,
    body: Schemas.BehaviorGroup
    */
        NotificationResourceUpdateBehaviorGroup.actionCreator = function (params) {
            var path = '/api/notifications/v1.0/notifications/behaviorGroups/{id}'.replace('{id}', params.id.toString());
            var query = {};
            return (0, react_fetching_library_1.actionBuilder)('PUT', path)
                .queryParams(query)
                .data(params.body)
                .config({
                rules: [
                    new openapi2typescript_1.ValidateRule(Response200, 'unknown', 200),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 401),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 403)
                ]
            })
                .build();
        };
    })(NotificationResourceUpdateBehaviorGroup = Operations.NotificationResourceUpdateBehaviorGroup || (Operations.NotificationResourceUpdateBehaviorGroup = {}));
    // DELETE /notifications/behaviorGroups/{id}
    // Delete a behavior group.
    var NotificationResourceDeleteBehaviorGroup;
    (function (NotificationResourceDeleteBehaviorGroup) {
        var Response200 = z.boolean();
        /*
     Params
    'id':Schemas.UUID
    */
        NotificationResourceDeleteBehaviorGroup.actionCreator = function (params) {
            var path = '/api/notifications/v1.0/notifications/behaviorGroups/{id}'.replace('{id}', params.id.toString());
            var query = {};
            return (0, react_fetching_library_1.actionBuilder)('DELETE', path)
                .queryParams(query)
                .config({
                rules: [
                    new openapi2typescript_1.ValidateRule(Response200, 'unknown', 200),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 401),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 403)
                ]
            })
                .build();
        };
    })(NotificationResourceDeleteBehaviorGroup = Operations.NotificationResourceDeleteBehaviorGroup || (Operations.NotificationResourceDeleteBehaviorGroup = {}));
    // GET /notifications/bundles/{bundleId}/behaviorGroups
    // Retrieve the behavior groups of a bundle.
    var NotificationResourceFindBehaviorGroupsByBundleId;
    (function (NotificationResourceFindBehaviorGroupsByBundleId) {
        var Response200 = z.array(Schemas.BehaviorGroup);
        /*
     Params
    'bundleId':Schemas.UUID
    */
        NotificationResourceFindBehaviorGroupsByBundleId.actionCreator = function (params) {
            var path = '/api/notifications/v1.0/notifications/bundles/{bundleId}/behaviorGroups'.replace('{bundleId}', params.bundleId.toString());
            var query = {};
            return (0, react_fetching_library_1.actionBuilder)('GET', path)
                .queryParams(query)
                .config({
                rules: [
                    new openapi2typescript_1.ValidateRule(Response200, 'unknown', 200),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 401),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 403)
                ]
            })
                .build();
        };
    })(NotificationResourceFindBehaviorGroupsByBundleId = Operations.NotificationResourceFindBehaviorGroupsByBundleId || (Operations.NotificationResourceFindBehaviorGroupsByBundleId = {}));
    // GET /notifications/eventTypes
    // Retrieve all event types. The returned list can be filtered by bundle or application.
    var NotificationResourceGetEventTypes;
    (function (NotificationResourceGetEventTypes) {
        var ApplicationIds = z.array(z.string());
        var Limit = z.number().int();
        var Offset = z.number().int();
        var PageNumber = z.number().int();
        var SortBy = z.string();
        /*
     Params
    'applicationIds'?:ApplicationIds,
    'bundleId'?:Schemas.UUID,
    'limit'?:Limit,
    'offset'?:Offset,
    'pageNumber'?:PageNumber,
    'sortBy'?:SortBy
    */
        NotificationResourceGetEventTypes.actionCreator = function (params) {
            var path = '/api/notifications/v1.0/notifications/eventTypes';
            var query = {};
            if (params.applicationIds !== undefined) {
                query.applicationIds = params.applicationIds;
            }
            if (params.bundleId !== undefined) {
                query.bundleId = params.bundleId;
            }
            if (params.limit !== undefined) {
                query.limit = params.limit;
            }
            if (params.offset !== undefined) {
                query.offset = params.offset;
            }
            if (params.pageNumber !== undefined) {
                query.pageNumber = params.pageNumber;
            }
            if (params.sortBy !== undefined) {
                query.sort_by = params.sortBy;
            }
            return (0, react_fetching_library_1.actionBuilder)('GET', path)
                .queryParams(query)
                .config({
                rules: [
                    new openapi2typescript_1.ValidateRule(Schemas.PageEventType, 'PageEventType', 200),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 401),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 403)
                ]
            })
                .build();
        };
    })(NotificationResourceGetEventTypes = Operations.NotificationResourceGetEventTypes || (Operations.NotificationResourceGetEventTypes = {}));
    // GET /notifications/eventTypes/affectedByRemovalOfBehaviorGroup/{behaviorGroupId}
    // Retrieve the event types affected by the removal of a behavior group.
    var NotificationResourceGetEventTypesAffectedByRemovalOfBehaviorGroup;
    (function (NotificationResourceGetEventTypesAffectedByRemovalOfBehaviorGroup) {
        var Response200 = z.array(Schemas.EventType);
        /*
     Params
    'behaviorGroupId':Schemas.UUID
    */
        NotificationResourceGetEventTypesAffectedByRemovalOfBehaviorGroup.actionCreator = function (params) {
            var path = '/api/notifications/v1.0/notifications/eventTypes/affectedByRemovalOfBehaviorGroup/{behaviorGroupId}'.replace('{behaviorGroupId}', params.behaviorGroupId.toString());
            var query = {};
            return (0, react_fetching_library_1.actionBuilder)('GET', path)
                .queryParams(query)
                .config({
                rules: [
                    new openapi2typescript_1.ValidateRule(Response200, 'unknown', 200),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 401),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 403)
                ]
            })
                .build();
        };
    })(NotificationResourceGetEventTypesAffectedByRemovalOfBehaviorGroup = Operations.NotificationResourceGetEventTypesAffectedByRemovalOfBehaviorGroup || (Operations.NotificationResourceGetEventTypesAffectedByRemovalOfBehaviorGroup = {}));
    // GET /notifications/eventTypes/{eventTypeId}/behaviorGroups
    // Retrieve the behavior groups linked to an event type.
    var NotificationResourceGetLinkedBehaviorGroups;
    (function (NotificationResourceGetLinkedBehaviorGroups) {
        var Limit = z.number().int();
        var Offset = z.number().int();
        var PageNumber = z.number().int();
        var SortBy = z.string();
        var Response200 = z.array(Schemas.BehaviorGroup);
        /*
     Params
    'eventTypeId':Schemas.UUID,
    'limit'?:Limit,
    'offset'?:Offset,
    'pageNumber'?:PageNumber,
    'sortBy'?:SortBy
    */
        NotificationResourceGetLinkedBehaviorGroups.actionCreator = function (params) {
            var path = '/api/notifications/v1.0/notifications/eventTypes/{eventTypeId}/behaviorGroups'.replace('{eventTypeId}', params.eventTypeId.toString());
            var query = {};
            if (params.limit !== undefined) {
                query.limit = params.limit;
            }
            if (params.offset !== undefined) {
                query.offset = params.offset;
            }
            if (params.pageNumber !== undefined) {
                query.pageNumber = params.pageNumber;
            }
            if (params.sortBy !== undefined) {
                query.sort_by = params.sortBy;
            }
            return (0, react_fetching_library_1.actionBuilder)('GET', path)
                .queryParams(query)
                .config({
                rules: [
                    new openapi2typescript_1.ValidateRule(Response200, 'unknown', 200),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 401),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 403)
                ]
            })
                .build();
        };
    })(NotificationResourceGetLinkedBehaviorGroups = Operations.NotificationResourceGetLinkedBehaviorGroups || (Operations.NotificationResourceGetLinkedBehaviorGroups = {}));
    // PUT /notifications/eventTypes/{eventTypeId}/behaviorGroups
    // Update the list of behavior groups of an event type.
    var NotificationResourceUpdateEventTypeBehaviors;
    (function (NotificationResourceUpdateEventTypeBehaviors) {
        var Body = z.array(z.string());
        var Response200 = z.string();
        /*
     Params
    'eventTypeId':Schemas.UUID,
    body: Body
    */
        NotificationResourceUpdateEventTypeBehaviors.actionCreator = function (params) {
            var path = '/api/notifications/v1.0/notifications/eventTypes/{eventTypeId}/behaviorGroups'.replace('{eventTypeId}', params.eventTypeId.toString());
            var query = {};
            return (0, react_fetching_library_1.actionBuilder)('PUT', path)
                .queryParams(query)
                .data(params.body)
                .config({
                rules: [
                    new openapi2typescript_1.ValidateRule(Response200, 'unknown', 200),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 401),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 403)
                ]
            })
                .build();
        };
    })(NotificationResourceUpdateEventTypeBehaviors = Operations.NotificationResourceUpdateEventTypeBehaviors || (Operations.NotificationResourceUpdateEventTypeBehaviors = {}));
    // GET /notifications/events
    // Retrieve the event log entries.
    var EventResourceGetEvents;
    (function (EventResourceGetEvents) {
        var AppIds = z.array(z.string());
        var BundleIds = z.array(z.string());
        var EndDate = z.string();
        var EndpointTypes = z.array(z.string());
        var EventTypeDisplayName = z.string();
        var IncludeActions = z.boolean();
        var IncludeDetails = z.boolean();
        var IncludePayload = z.boolean();
        var InvocationResults = z.array(z.boolean());
        var Limit = z.number().int();
        var Offset = z.number().int();
        var SortBy = z.string();
        var StartDate = z.string();
        /*
     Params
    'appIds'?:AppIds,
    'bundleIds'?:BundleIds,
    'endDate'?:EndDate,
    'endpointTypes'?:EndpointTypes,
    'eventTypeDisplayName'?:EventTypeDisplayName,
    'includeActions'?:IncludeActions,
    'includeDetails'?:IncludeDetails,
    'includePayload'?:IncludePayload,
    'invocationResults'?:InvocationResults,
    'limit'?:Limit,
    'offset'?:Offset,
    'sortBy'?:SortBy,
    'startDate'?:StartDate
    */
        EventResourceGetEvents.actionCreator = function (params) {
            var path = '/api/notifications/v1.0/notifications/events';
            var query = {};
            if (params.appIds !== undefined) {
                query.appIds = params.appIds;
            }
            if (params.bundleIds !== undefined) {
                query.bundleIds = params.bundleIds;
            }
            if (params.endDate !== undefined) {
                query.endDate = params.endDate;
            }
            if (params.endpointTypes !== undefined) {
                query.endpointTypes = params.endpointTypes;
            }
            if (params.eventTypeDisplayName !== undefined) {
                query.eventTypeDisplayName = params.eventTypeDisplayName;
            }
            if (params.includeActions !== undefined) {
                query.includeActions = params.includeActions;
            }
            if (params.includeDetails !== undefined) {
                query.includeDetails = params.includeDetails;
            }
            if (params.includePayload !== undefined) {
                query.includePayload = params.includePayload;
            }
            if (params.invocationResults !== undefined) {
                query.invocationResults = params.invocationResults;
            }
            if (params.limit !== undefined) {
                query.limit = params.limit;
            }
            if (params.offset !== undefined) {
                query.offset = params.offset;
            }
            if (params.sortBy !== undefined) {
                query.sortBy = params.sortBy;
            }
            if (params.startDate !== undefined) {
                query.startDate = params.startDate;
            }
            return (0, react_fetching_library_1.actionBuilder)('GET', path)
                .queryParams(query)
                .config({
                rules: [
                    new openapi2typescript_1.ValidateRule(Schemas.PageEventLogEntry, 'PageEventLogEntry', 200),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 401),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 403)
                ]
            })
                .build();
        };
    })(EventResourceGetEvents = Operations.EventResourceGetEvents || (Operations.EventResourceGetEvents = {}));
    // GET /notifications/facets/applications
    // Return a thin list of configured applications. This can be used to configure a filter in the UI
    var NotificationResourceGetApplicationsFacets;
    (function (NotificationResourceGetApplicationsFacets) {
        var BundleName = z.string();
        var Response200 = z.array(Schemas.Facet);
        /*
     Params
    'bundleName'?:BundleName
    */
        NotificationResourceGetApplicationsFacets.actionCreator = function (params) {
            var path = '/api/notifications/v1.0/notifications/facets/applications';
            var query = {};
            if (params.bundleName !== undefined) {
                query.bundleName = params.bundleName;
            }
            return (0, react_fetching_library_1.actionBuilder)('GET', path)
                .queryParams(query)
                .config({
                rules: [new openapi2typescript_1.ValidateRule(Response200, 'unknown', 200)]
            })
                .build();
        };
    })(NotificationResourceGetApplicationsFacets = Operations.NotificationResourceGetApplicationsFacets || (Operations.NotificationResourceGetApplicationsFacets = {}));
    // GET /notifications/facets/bundles
    // Return a thin list of configured bundles. This can be used to configure a filter in the UI
    var NotificationResourceGetBundleFacets;
    (function (NotificationResourceGetBundleFacets) {
        var IncludeApplications = z.boolean();
        var Response200 = z.array(Schemas.Facet);
        /*
     Params
    'includeApplications'?:IncludeApplications
    */
        NotificationResourceGetBundleFacets.actionCreator = function (params) {
            var path = '/api/notifications/v1.0/notifications/facets/bundles';
            var query = {};
            if (params.includeApplications !== undefined) {
                query.includeApplications = params.includeApplications;
            }
            return (0, react_fetching_library_1.actionBuilder)('GET', path)
                .queryParams(query)
                .config({
                rules: [new openapi2typescript_1.ValidateRule(Response200, 'unknown', 200)]
            })
                .build();
        };
    })(NotificationResourceGetBundleFacets = Operations.NotificationResourceGetBundleFacets || (Operations.NotificationResourceGetBundleFacets = {}));
    // DELETE /notifications/{id}
    var NotificationResourceMarkRead;
    (function (NotificationResourceMarkRead) {
        var Id = z.number().int();
        var Response204 = z.string();
        /*
     Params
    'id':Id
    */
        NotificationResourceMarkRead.actionCreator = function (params) {
            var path = '/api/notifications/v1.0/notifications/{id}'.replace('{id}', params.id.toString());
            var query = {};
            return (0, react_fetching_library_1.actionBuilder)('DELETE', path)
                .queryParams(query)
                .config({
                rules: [new openapi2typescript_1.ValidateRule(Response204, 'unknown', 204)]
            })
                .build();
        };
    })(NotificationResourceMarkRead = Operations.NotificationResourceMarkRead || (Operations.NotificationResourceMarkRead = {}));
})(Operations = exports.Operations || (exports.Operations = {}));
"
`;

exports[`src/cli/schema execute for ./tests/__fixtures__/notifications-openapi.json execute input file accepts path: generated 1`] = `
"/* eslint-disable */
/**
 * Generated code, DO NOT modify directly.
 */
import * as z from 'zod';
import { ValidateRule } from 'openapi2typescript';
import { actionBuilder } from 'openapi2typescript/react-fetching-library';

export namespace Schemas {
  export const AddAccessRequest = zodSchemaAddAccessRequest();

  export const AddApplicationRequest = zodSchemaAddApplicationRequest();

  export const AggregationEmailTemplate = zodSchemaAggregationEmailTemplate();

  export const Application = zodSchemaApplication();

  export const Application1 = zodSchemaApplication1();

  export const BasicAuthentication = zodSchemaBasicAuthentication();

  export const BehaviorGroup = zodSchemaBehaviorGroup();

  export const BehaviorGroupAction = zodSchemaBehaviorGroupAction();

  export const BehaviorGroupActionId = zodSchemaBehaviorGroupActionId();

  export const Bundle = zodSchemaBundle();

  export const CamelProperties = zodSchemaCamelProperties();

  export const CurrentStatus = zodSchemaCurrentStatus();

  export const EmailSubscriptionProperties =
    zodSchemaEmailSubscriptionProperties();

  export const EmailSubscriptionType = zodSchemaEmailSubscriptionType();

  export const Endpoint = zodSchemaEndpoint();

  export const EndpointPage = zodSchemaEndpointPage();

  export const EndpointProperties = zodSchemaEndpointProperties();

  export const EndpointType = zodSchemaEndpointType();

  export const Environment = zodSchemaEnvironment();

  export const EventLogEntry = zodSchemaEventLogEntry();

  export const EventLogEntryAction = zodSchemaEventLogEntryAction();

  export const EventType = zodSchemaEventType();

  export const Facet = zodSchemaFacet();

  export const HttpType = zodSchemaHttpType();

  export const InstantEmailTemplate = zodSchemaInstantEmailTemplate();

  export const InternalApplicationUserPermission =
    zodSchemaInternalApplicationUserPermission();

  export const InternalRoleAccess = zodSchemaInternalRoleAccess();

  export const InternalUserPermissions = zodSchemaInternalUserPermissions();

  export const Meta = zodSchemaMeta();

  export const NotificationHistory = zodSchemaNotificationHistory();

  export const PageEventLogEntry = zodSchemaPageEventLogEntry();

  export const PageEventType = zodSchemaPageEventType();

  export const RenderEmailTemplateRequest =
    zodSchemaRenderEmailTemplateRequest();

  export const RequestDefaultBehaviorGroupPropertyList =
    zodSchemaRequestDefaultBehaviorGroupPropertyList();

  export const RequestEmailSubscriptionProperties =
    zodSchemaRequestEmailSubscriptionProperties();

  export const ServerInfo = zodSchemaServerInfo();

  export const Status = zodSchemaStatus();

  export const Template = zodSchemaTemplate();

  export const UUID = zodSchemaUUID();

  export const WebhookProperties = zodSchemaWebhookProperties();

  export const __Empty = zodSchema__Empty();

  function zodSchemaAddAccessRequest() {
      return z.object({
          application_id: zodSchemaUUID().optional().nullable(),
          role: z.string().optional().nullable()
      });
  }

  function zodSchemaAddApplicationRequest() {
      return z.object({
          bundle_id: zodSchemaUUID(),
          display_name: z.string(),
          name: z.string(),
          owner_role: z.string().optional().nullable()
      });
  }

  function zodSchemaAggregationEmailTemplate() {
      return z.object({
          application: zodSchemaApplication().optional().nullable(),
          application_id: zodSchemaUUID().optional().nullable(),
          body_template: zodSchemaTemplate().optional().nullable(),
          body_template_id: zodSchemaUUID(),
          created: z.string().optional().nullable(),
          id: zodSchemaUUID().optional().nullable(),
          subject_template: zodSchemaTemplate().optional().nullable(),
          subject_template_id: zodSchemaUUID(),
          subscription_type: zodSchemaEmailSubscriptionType(),
          updated: z.string().optional().nullable()
      });
  }

  function zodSchemaApplication() {
      return z.object({
          bundle_id: zodSchemaUUID(),
          created: z.string().optional().nullable(),
          display_name: z.string(),
          id: zodSchemaUUID().optional().nullable(),
          name: z.string(),
          updated: z.string().optional().nullable()
      });
  }

  function zodSchemaApplication1() {
      return z.object({
          display_name: z.string(),
          id: zodSchemaUUID()
      });
  }

  function zodSchemaBasicAuthentication() {
      return z.object({
          password: z.string().optional().nullable(),
          username: z.string().optional().nullable()
      });
  }

  function zodSchemaBehaviorGroup() {
      return z.object({
          actions: z.array(zodSchemaBehaviorGroupAction()).optional().nullable(),
          bundle: zodSchemaBundle().optional().nullable(),
          bundle_id: zodSchemaUUID(),
          created: z.string().optional().nullable(),
          default_behavior: z.boolean().optional().nullable(),
          display_name: z.string(),
          id: zodSchemaUUID().optional().nullable(),
          updated: z.string().optional().nullable()
      });
  }

  function zodSchemaBehaviorGroupAction() {
      return z.object({
          created: z.string().optional().nullable(),
          endpoint: zodSchemaEndpoint().optional().nullable(),
          id: zodSchemaBehaviorGroupActionId().optional().nullable()
      });
  }

  function zodSchemaBehaviorGroupActionId() {
      return z.object({
          behaviorGroupId: zodSchemaUUID(),
          endpointId: zodSchemaUUID()
      });
  }

  function zodSchemaBundle() {
      return z.object({
          created: z.string().optional().nullable(),
          display_name: z.string(),
          id: zodSchemaUUID().optional().nullable(),
          name: z.string(),
          updated: z.string().optional().nullable()
      });
  }

  function zodSchemaCamelProperties() {
      return z.object({
          basic_authentication: zodSchemaBasicAuthentication()
          .optional()
          .nullable(),
          disable_ssl_verification: z.boolean(),
          extras: z.record(z.string()).optional().nullable(),
          secret_token: z.string().optional().nullable(),
          sub_type: z.string().optional().nullable(),
          url: z.string()
      });
  }

  function zodSchemaCurrentStatus() {
      return z.object({
          end_time: z.string().optional().nullable(),
          start_time: z.string().optional().nullable(),
          status: zodSchemaStatus()
      });
  }

  function zodSchemaEmailSubscriptionProperties() {
      return z.object({
          group_id: zodSchemaUUID().optional().nullable(),
          ignore_preferences: z.boolean(),
          only_admins: z.boolean()
      });
  }

  function zodSchemaEmailSubscriptionType() {
      return z.enum([ 'INSTANT', 'DAILY' ]);
  }

  function zodSchemaEndpoint() {
      return z.object({
          created: z.string().optional().nullable(),
          description: z.string(),
          enabled: z.boolean().optional().nullable(),
          id: zodSchemaUUID().optional().nullable(),
          name: z.string(),
          properties: z
          .union([
              zodSchemaWebhookProperties(),
              zodSchemaEmailSubscriptionProperties(),
              zodSchemaCamelProperties()
          ])
          .optional()
          .nullable(),
          sub_type: z.string().optional().nullable(),
          type: zodSchemaEndpointType(),
          updated: z.string().optional().nullable()
      });
  }

  function zodSchemaEndpointPage() {
      return z.object({
          data: z.array(zodSchemaEndpoint()),
          links: z.record(z.string()),
          meta: zodSchemaMeta()
      });
  }

  function zodSchemaEndpointProperties() {
      return z.unknown();
  }

  function zodSchemaEndpointType() {
      return z.enum([ 'webhook', 'email_subscription', 'default', 'camel' ]);
  }

  function zodSchemaEnvironment() {
      return z.enum([ 'PROD', 'STAGE', 'EPHEMERAL', 'LOCAL_SERVER' ]);
  }

  function zodSchemaEventLogEntry() {
      return z.object({
          actions: z.array(zodSchemaEventLogEntryAction()),
          application: z.string(),
          bundle: z.string(),
          created: z.string(),
          event_type: z.string(),
          id: zodSchemaUUID(),
          payload: z.string().optional().nullable()
      });
  }

  function zodSchemaEventLogEntryAction() {
      return z.object({
          details: z.record(z.unknown()).optional().nullable(),
          endpoint_id: zodSchemaUUID().optional().nullable(),
          endpoint_sub_type: z.string().optional().nullable(),
          endpoint_type: zodSchemaEndpointType(),
          id: zodSchemaUUID(),
          invocation_result: z.boolean()
      });
  }

  function zodSchemaEventType() {
      return z.object({
          application: zodSchemaApplication().optional().nullable(),
          application_id: zodSchemaUUID(),
          description: z.string().optional().nullable(),
          display_name: z.string(),
          id: zodSchemaUUID().optional().nullable(),
          name: z.string()
      });
  }

  function zodSchemaFacet() {
      return z.object({
          children: z
          .array(z.lazy(() => zodSchemaFacet()))
          .optional()
          .nullable(),
          displayName: z.string(),
          id: z.string(),
          name: z.string()
      });
  }

  function zodSchemaHttpType() {
      return z.enum([ 'GET', 'POST', 'PUT' ]);
  }

  function zodSchemaInstantEmailTemplate() {
      return z.object({
          body_template: zodSchemaTemplate().optional().nullable(),
          body_template_id: zodSchemaUUID(),
          created: z.string().optional().nullable(),
          event_type: zodSchemaEventType().optional().nullable(),
          event_type_id: zodSchemaUUID().optional().nullable(),
          id: zodSchemaUUID().optional().nullable(),
          subject_template: zodSchemaTemplate().optional().nullable(),
          subject_template_id: zodSchemaUUID(),
          updated: z.string().optional().nullable()
      });
  }

  function zodSchemaInternalApplicationUserPermission() {
      return z.object({
          application_display_name: z.string(),
          application_id: zodSchemaUUID(),
          role: z.string()
      });
  }

  function zodSchemaInternalRoleAccess() {
      return z.object({
          application_id: zodSchemaUUID(),
          id: zodSchemaUUID().optional().nullable(),
          role: z.string()
      });
  }

  function zodSchemaInternalUserPermissions() {
      return z.object({
          applications: z.array(zodSchemaApplication1()),
          is_admin: z.boolean(),
          roles: z.array(z.string())
      });
  }

  function zodSchemaMeta() {
      return z.object({
          count: z.number().int()
      });
  }

  function zodSchemaNotificationHistory() {
      return z.object({
          created: z.string().optional().nullable(),
          details: z.record(z.unknown()).optional().nullable(),
          endpointId: zodSchemaUUID().optional().nullable(),
          endpointSubType: z.string().optional().nullable(),
          endpointType: zodSchemaEndpointType().optional().nullable(),
          id: zodSchemaUUID().optional().nullable(),
          invocationResult: z.boolean(),
          invocationTime: z.number().int()
      });
  }

  function zodSchemaPageEventLogEntry() {
      return z.object({
          data: z.array(zodSchemaEventLogEntry()),
          links: z.record(z.string()),
          meta: zodSchemaMeta()
      });
  }

  function zodSchemaPageEventType() {
      return z.object({
          data: z.array(zodSchemaEventType()),
          links: z.record(z.string()),
          meta: zodSchemaMeta()
      });
  }

  function zodSchemaRenderEmailTemplateRequest() {
      return z.object({
          body_template: z.string(),
          payload: z.string(),
          subject_template: z.string()
      });
  }

  function zodSchemaRequestDefaultBehaviorGroupPropertyList() {
      return z.object({
          ignore_preferences: z.boolean(),
          only_admins: z.boolean()
      });
  }

  function zodSchemaRequestEmailSubscriptionProperties() {
      return z.object({
          group_id: zodSchemaUUID().optional().nullable(),
          only_admins: z.boolean()
      });
  }

  function zodSchemaServerInfo() {
      return z.object({
          environment: zodSchemaEnvironment().optional().nullable()
      });
  }

  function zodSchemaStatus() {
      return z.enum([ 'UP', 'MAINTENANCE' ]);
  }

  function zodSchemaTemplate() {
      return z.object({
          created: z.string().optional().nullable(),
          data: z.string(),
          description: z.string(),
          id: zodSchemaUUID().optional().nullable(),
          name: z.string(),
          updated: z.string().optional().nullable()
      });
  }

  function zodSchemaUUID() {
      return z.string();
  }

  function zodSchemaWebhookProperties() {
      return z.object({
          basic_authentication: zodSchemaBasicAuthentication()
          .optional()
          .nullable(),
          disable_ssl_verification: z.boolean(),
          method: zodSchemaHttpType(),
          secret_token: z.string().optional().nullable(),
          url: z.string()
      });
  }

  function zodSchema__Empty() {
      return z.string().max(0).optional();
  }
}

export namespace Operations {
  // POST /notifications/behaviorGroups
  // Create a behavior group.
  export namespace NotificationResourceCreateBehaviorGroup {
    /*
 Params
body: Schemas.BehaviorGroup
*/
    export const actionCreator = (params) => {
        const path = '/api/notifications/v1.0/notifications/behaviorGroups';
        const query = {};
        return actionBuilder('POST', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [
                new ValidateRule(Schemas.BehaviorGroup, 'BehaviorGroup', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.__Empty, '__Empty', 403)
            ]
        })
        .build();
    };
  }
  // GET /notifications/behaviorGroups/affectedByRemovalOfEndpoint/{endpointId}
  // Retrieve the behavior groups affected by the removal of an endpoint.
  export namespace NotificationResourceGetBehaviorGroupsAffectedByRemovalOfEndpoint {
    const Response200 = z.array(Schemas.BehaviorGroup);
    /*
 Params
'endpointId':Schemas.UUID
*/
    export const actionCreator = (params) => {
        const path =
        '/api/notifications/v1.0/notifications/behaviorGroups/affectedByRemovalOfEndpoint/{endpointId}'.replace(
            '{endpointId}',
            params.endpointId.toString()
        );
        const query = {};
        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Response200, 'unknown', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.__Empty, '__Empty', 403)
            ]
        })
        .build();
    };
  }
  // PUT /notifications/behaviorGroups/{behaviorGroupId}/actions
  // Update the list of actions of a behavior group.
  export namespace NotificationResourceUpdateBehaviorGroupActions {
    const Body = z.array(z.string());
    const Response200 = z.string();
    /*
 Params
'behaviorGroupId':Schemas.UUID,
body: Body
*/
    export const actionCreator = (params) => {
        const path =
        '/api/notifications/v1.0/notifications/behaviorGroups/{behaviorGroupId}/actions'.replace(
            '{behaviorGroupId}',
            params.behaviorGroupId.toString()
        );
        const query = {};
        return actionBuilder('PUT', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [
                new ValidateRule(Response200, 'unknown', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.__Empty, '__Empty', 403)
            ]
        })
        .build();
    };
  }
  // PUT /notifications/behaviorGroups/{id}
  // Update a behavior group.
  export namespace NotificationResourceUpdateBehaviorGroup {
    const Response200 = z.boolean();
    /*
 Params
'id':Schemas.UUID,
body: Schemas.BehaviorGroup
*/
    export const actionCreator = (params) => {
        const path =
        '/api/notifications/v1.0/notifications/behaviorGroups/{id}'.replace(
            '{id}',
            params.id.toString()
        );
        const query = {};
        return actionBuilder('PUT', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [
                new ValidateRule(Response200, 'unknown', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.__Empty, '__Empty', 403)
            ]
        })
        .build();
    };
  }
  // DELETE /notifications/behaviorGroups/{id}
  // Delete a behavior group.
  export namespace NotificationResourceDeleteBehaviorGroup {
    const Response200 = z.boolean();
    /*
 Params
'id':Schemas.UUID
*/
    export const actionCreator = (params) => {
        const path =
        '/api/notifications/v1.0/notifications/behaviorGroups/{id}'.replace(
            '{id}',
            params.id.toString()
        );
        const query = {};
        return actionBuilder('DELETE', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Response200, 'unknown', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.__Empty, '__Empty', 403)
            ]
        })
        .build();
    };
  }
  // GET /notifications/bundles/{bundleId}/behaviorGroups
  // Retrieve the behavior groups of a bundle.
  export namespace NotificationResourceFindBehaviorGroupsByBundleId {
    const Response200 = z.array(Schemas.BehaviorGroup);
    /*
 Params
'bundleId':Schemas.UUID
*/
    export const actionCreator = (params) => {
        const path =
        '/api/notifications/v1.0/notifications/bundles/{bundleId}/behaviorGroups'.replace(
            '{bundleId}',
            params.bundleId.toString()
        );
        const query = {};
        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Response200, 'unknown', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.__Empty, '__Empty', 403)
            ]
        })
        .build();
    };
  }
  // GET /notifications/eventTypes
  // Retrieve all event types. The returned list can be filtered by bundle or application.
  export namespace NotificationResourceGetEventTypes {
    const ApplicationIds = z.array(z.string());
    const Limit = z.number().int();
    const Offset = z.number().int();
    const PageNumber = z.number().int();
    const SortBy = z.string();
    /*
 Params
'applicationIds'?:ApplicationIds,
'bundleId'?:Schemas.UUID,
'limit'?:Limit,
'offset'?:Offset,
'pageNumber'?:PageNumber,
'sortBy'?:SortBy
*/
    export const actionCreator = (params) => {
        const path = '/api/notifications/v1.0/notifications/eventTypes';
        const query = {};
        if (params.applicationIds !== undefined) {
            query.applicationIds = params.applicationIds;
        }

        if (params.bundleId !== undefined) {
            query.bundleId = params.bundleId;
        }

        if (params.limit !== undefined) {
            query.limit = params.limit;
        }

        if (params.offset !== undefined) {
            query.offset = params.offset;
        }

        if (params.pageNumber !== undefined) {
            query.pageNumber = params.pageNumber;
        }

        if (params.sortBy !== undefined) {
            query.sort_by = params.sortBy;
        }

        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Schemas.PageEventType, 'PageEventType', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.__Empty, '__Empty', 403)
            ]
        })
        .build();
    };
  }
  // GET /notifications/eventTypes/affectedByRemovalOfBehaviorGroup/{behaviorGroupId}
  // Retrieve the event types affected by the removal of a behavior group.
  export namespace NotificationResourceGetEventTypesAffectedByRemovalOfBehaviorGroup {
    const Response200 = z.array(Schemas.EventType);
    /*
 Params
'behaviorGroupId':Schemas.UUID
*/
    export const actionCreator = (params) => {
        const path =
        '/api/notifications/v1.0/notifications/eventTypes/affectedByRemovalOfBehaviorGroup/{behaviorGroupId}'.replace(
            '{behaviorGroupId}',
            params.behaviorGroupId.toString()
        );
        const query = {};
        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Response200, 'unknown', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.__Empty, '__Empty', 403)
            ]
        })
        .build();
    };
  }
  // GET /notifications/eventTypes/{eventTypeId}/behaviorGroups
  // Retrieve the behavior groups linked to an event type.
  export namespace NotificationResourceGetLinkedBehaviorGroups {
    const Limit = z.number().int();
    const Offset = z.number().int();
    const PageNumber = z.number().int();
    const SortBy = z.string();
    const Response200 = z.array(Schemas.BehaviorGroup);
    /*
 Params
'eventTypeId':Schemas.UUID,
'limit'?:Limit,
'offset'?:Offset,
'pageNumber'?:PageNumber,
'sortBy'?:SortBy
*/
    export const actionCreator = (params) => {
        const path =
        '/api/notifications/v1.0/notifications/eventTypes/{eventTypeId}/behaviorGroups'.replace(
            '{eventTypeId}',
            params.eventTypeId.toString()
        );
        const query = {};
        if (params.limit !== undefined) {
            query.limit = params.limit;
        }

        if (params.offset !== undefined) {
            query.offset = params.offset;
        }

        if (params.pageNumber !== undefined) {
            query.pageNumber = params.pageNumber;
        }

        if (params.sortBy !== undefined) {
            query.sort_by = params.sortBy;
        }

        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Response200, 'unknown', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.__Empty, '__Empty', 403)
            ]
        })
        .build();
    };
  }
  // PUT /notifications/eventTypes/{eventTypeId}/behaviorGroups
  // Update the list of behavior groups of an event type.
  export namespace NotificationResourceUpdateEventTypeBehaviors {
    const Body = z.array(z.string());
    const Response200 = z.string();
    /*
 Params
'eventTypeId':Schemas.UUID,
body: Body
*/
    export const actionCreator = (params) => {
        const path =
        '/api/notifications/v1.0/notifications/eventTypes/{eventTypeId}/behaviorGroups'.replace(
            '{eventTypeId}',
            params.eventTypeId.toString()
        );
        const query = {};
        return actionBuilder('PUT', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [
                new ValidateRule(Response200, 'unknown', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.__Empty, '__Empty', 403)
            ]
        })
        .build();
    };
  }
  // GET /notifications/events
  // Retrieve the event log entries.
  export namespace EventResourceGetEvents {
    const AppIds = z.array(z.string());
    const BundleIds = z.array(z.string());
    const EndDate = z.string();
    const EndpointTypes = z.array(z.string());
    const EventTypeDisplayName = z.string();
    const IncludeActions = z.boolean();
    const IncludeDetails = z.boolean();
    const IncludePayload = z.boolean();
    const InvocationResults = z.array(z.boolean());
    const Limit = z.number().int();
    const Offset = z.number().int();
    const SortBy = z.string();
    const StartDate = z.string();
    /*
 Params
'appIds'?:AppIds,
'bundleIds'?:BundleIds,
'endDate'?:EndDate,
'endpointTypes'?:EndpointTypes,
'eventTypeDisplayName'?:EventTypeDisplayName,
'includeActions'?:IncludeActions,
'includeDetails'?:IncludeDetails,
'includePayload'?:IncludePayload,
'invocationResults'?:InvocationResults,
'limit'?:Limit,
'offset'?:Offset,
'sortBy'?:SortBy,
'startDate'?:StartDate
*/
    export const actionCreator = (params) => {
        const path = '/api/notifications/v1.0/notifications/events';
        const query = {};
        if (params.appIds !== undefined) {
            query.appIds = params.appIds;
        }

        if (params.bundleIds !== undefined) {
            query.bundleIds = params.bundleIds;
        }

        if (params.endDate !== undefined) {
            query.endDate = params.endDate;
        }

        if (params.endpointTypes !== undefined) {
            query.endpointTypes = params.endpointTypes;
        }

        if (params.eventTypeDisplayName !== undefined) {
            query.eventTypeDisplayName = params.eventTypeDisplayName;
        }

        if (params.includeActions !== undefined) {
            query.includeActions = params.includeActions;
        }

        if (params.includeDetails !== undefined) {
            query.includeDetails = params.includeDetails;
        }

        if (params.includePayload !== undefined) {
            query.includePayload = params.includePayload;
        }

        if (params.invocationResults !== undefined) {
            query.invocationResults = params.invocationResults;
        }

        if (params.limit !== undefined) {
            query.limit = params.limit;
        }

        if (params.offset !== undefined) {
            query.offset = params.offset;
        }

        if (params.sortBy !== undefined) {
            query.sortBy = params.sortBy;
        }

        if (params.startDate !== undefined) {
            query.startDate = params.startDate;
        }

        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(
                    Schemas.PageEventLogEntry,
                    'PageEventLogEntry',
                    200
                ),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.__Empty, '__Empty', 403)
            ]
        })
        .build();
    };
  }
  // GET /notifications/facets/applications
  // Return a thin list of configured applications. This can be used to configure a filter in the UI
  export namespace NotificationResourceGetApplicationsFacets {
    const BundleName = z.string();
    const Response200 = z.array(Schemas.Facet);
    /*
 Params
'bundleName'?:BundleName
*/
    export const actionCreator = (params) => {
        const path = '/api/notifications/v1.0/notifications/facets/applications';
        const query = {};
        if (params.bundleName !== undefined) {
            query.bundleName = params.bundleName;
        }

        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [ new ValidateRule(Response200, 'unknown', 200) ]
        })
        .build();
    };
  }
  // GET /notifications/facets/bundles
  // Return a thin list of configured bundles. This can be used to configure a filter in the UI
  export namespace NotificationResourceGetBundleFacets {
    const IncludeApplications = z.boolean();
    const Response200 = z.array(Schemas.Facet);
    /*
 Params
'includeApplications'?:IncludeApplications
*/
    export const actionCreator = (params) => {
        const path = '/api/notifications/v1.0/notifications/facets/bundles';
        const query = {};
        if (params.includeApplications !== undefined) {
            query.includeApplications = params.includeApplications;
        }

        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [ new ValidateRule(Response200, 'unknown', 200) ]
        })
        .build();
    };
  }
  // DELETE /notifications/{id}
  export namespace NotificationResourceMarkRead {
    const Id = z.number().int();
    const Response204 = z.string();
    /*
 Params
'id':Id
*/
    export const actionCreator = (params) => {
        const path = '/api/notifications/v1.0/notifications/{id}'.replace(
            '{id}',
            params.id.toString()
        );
        const query = {};
        return actionBuilder('DELETE', path)
        .queryParams(query)
        .config({
            rules: [ new ValidateRule(Response204, 'unknown', 204) ]
        })
        .build();
    };
  }
}
"
`;

exports[`src/cli/schema execute for ./tests/__fixtures__/policies-openapi.json execute accepts urls 1`] = `
"/* eslint-disable */
/**
 * Generated code, DO NOT modify directly.
 */
import * as z from 'zod';
import { ValidatedResponse } from 'openapi2typescript';
import { Action } from 'react-fetching-library';
import { ValidateRule } from 'openapi2typescript';
import {
    actionBuilder,
    ActionValidatableConfig
} from 'openapi2typescript/react-fetching-library';

export namespace Schemas {
  export const Fact = zodSchemaFact();
  export type Fact = z.infer<typeof Fact>;

  export const FactType = zodSchemaFactType();
  export type FactType = z.infer<typeof FactType>;

  export const HistoryItem = zodSchemaHistoryItem();
  export type HistoryItem = z.infer<typeof HistoryItem>;

  export const List = zodSchemaList();
  export type List = z.infer<typeof List>;

  export const ListHistoryItem = zodSchemaListHistoryItem();
  export type ListHistoryItem = z.infer<typeof ListHistoryItem>;

  export const ListPolicy = zodSchemaListPolicy();
  export type ListPolicy = z.infer<typeof ListPolicy>;

  export const ListUUID = zodSchemaListUUID();
  export type ListUUID = z.infer<typeof ListUUID>;

  export const MapStringString = zodSchemaMapStringString();
  export type MapStringString = z.infer<typeof MapStringString>;

  export const Meta = zodSchemaMeta();
  export type Meta = z.infer<typeof Meta>;

  export const PagedResponseOfHistoryItem =
    zodSchemaPagedResponseOfHistoryItem();
  export type PagedResponseOfHistoryItem = z.infer<
    typeof PagedResponseOfHistoryItem
  >;

  export const PagedResponseOfPolicy = zodSchemaPagedResponseOfPolicy();
  export type PagedResponseOfPolicy = z.infer<typeof PagedResponseOfPolicy>;

  export const Policy = zodSchemaPolicy();
  export type Policy = z.infer<typeof Policy>;

  export const UUID = zodSchemaUUID();
  export type UUID = z.infer<typeof UUID>;

  export const __Empty = zodSchema__Empty();
  export type __Empty = z.infer<typeof __Empty>;

  function zodSchemaFact() {
      return z.object({
          id: z.number().int().optional().nullable(),
          name: z.string().optional().nullable(),
          type: zodSchemaFactType().optional().nullable()
      });
  }

  function zodSchemaFactType() {
      return z.enum([ 'BOOLEAN', 'INT', 'LIST', 'STRING' ]);
  }

  function zodSchemaHistoryItem() {
      return z.object({
          ctime: z.number().int().optional().nullable(),
          hostName: z.string().optional().nullable(),
          id: z.string().optional().nullable()
      });
  }

  function zodSchemaList() {
      return z.array(z.unknown());
  }

  function zodSchemaListHistoryItem() {
      return z.array(zodSchemaHistoryItem());
  }

  function zodSchemaListPolicy() {
      return z.array(zodSchemaPolicy());
  }

  function zodSchemaListUUID() {
      return z.array(z.string());
  }

  function zodSchemaMapStringString() {
      return z.record(z.string());
  }

  function zodSchemaMeta() {
      return z.object({
          count: z.number().int().optional().nullable()
      });
  }

  function zodSchemaPagedResponseOfHistoryItem() {
      return z.object({
          data: zodSchemaListHistoryItem().optional().nullable(),
          links: zodSchemaMapStringString().optional().nullable(),
          meta: zodSchemaMeta().optional().nullable()
      });
  }

  function zodSchemaPagedResponseOfPolicy() {
      return z.object({
          data: zodSchemaListPolicy().optional().nullable(),
          links: zodSchemaMapStringString().optional().nullable(),
          meta: zodSchemaMeta().optional().nullable()
      });
  }

  function zodSchemaPolicy() {
      return z.object({
          actions: z.string().optional().nullable(),
          conditions: z.string(),
          ctime: z.string().optional().nullable(),
          description: z.string().optional().nullable(),
          id: zodSchemaUUID().optional().nullable(),
          isEnabled: z.boolean().optional().nullable(),
          lastTriggered: z.number().int().optional().nullable(),
          mtime: z.string().optional().nullable(),
          name: z.string()
      });
  }

  function zodSchemaUUID() {
      return z.string();
  }

  function zodSchema__Empty() {
      return z.string().max(0).optional();
  }
}

export namespace Operations {
  // GET /
  // Just a filler to have a defined return code for the base path
  export namespace Get {
    export type Payload =
      | ValidatedResponse<'__Empty', 404, Schemas.__Empty>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (): ActionCreator => {
        const path = '/api/policies/v1.0/';
        const query = {} as Record<string, any>;
        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [ new ValidateRule(Schemas.__Empty, '__Empty', 404) ]
        })
        .build();
    };
  }
  // GET /facts
  // Retrieve a list of fact (keys) along with their data types
  export namespace GetFacts {
    const Response200 = z.array(Schemas.Fact);
    type Response200 = z.infer<typeof Response200>;
    export type Payload =
      | ValidatedResponse<'unknown', 200, Response200>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (): ActionCreator => {
        const path = '/api/policies/v1.0/facts';
        const query = {} as Record<string, any>;
        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [ new ValidateRule(Response200, 'unknown', 200) ]
        })
        .build();
    };
  }
  // GET /policies
  // Return all policies for a given account
  export namespace GetPolicies {
    const FilterOpDescription = z.enum([ 'equal', 'like', 'ilike', 'not_equal' ]);
    type FilterOpDescription = z.infer<typeof FilterOpDescription>;
    const FilterOpName = z.enum([ 'equal', 'like', 'ilike', 'not_equal' ]);
    type FilterOpName = z.infer<typeof FilterOpName>;
    const FilterDescription = z.string();
    type FilterDescription = z.infer<typeof FilterDescription>;
    const FilterIsEnabled = z.enum([ 'true', 'false' ]);
    type FilterIsEnabled = z.infer<typeof FilterIsEnabled>;
    const FilterName = z.string();
    type FilterName = z.infer<typeof FilterName>;
    const Limit = z.number().int();
    type Limit = z.infer<typeof Limit>;
    const Offset = z.number().int();
    type Offset = z.infer<typeof Offset>;
    const SortColumn = z.enum([ 'name', 'description', 'is_enabled', 'mtime' ]);
    type SortColumn = z.infer<typeof SortColumn>;
    const SortDirection = z.enum([ 'asc', 'desc' ]);
    type SortDirection = z.infer<typeof SortDirection>;
    export interface Params {
      filterOpDescription?: FilterOpDescription;
      filterOpName?: FilterOpName;
      filterDescription?: FilterDescription;
      filterIsEnabled?: FilterIsEnabled;
      filterName?: FilterName;
      limit?: Limit;
      offset?: Offset;
      sortColumn?: SortColumn;
      sortDirection?: SortDirection;
    }

    export type Payload =
      | ValidatedResponse<
          'PagedResponseOfPolicy',
          200,
          Schemas.PagedResponseOfPolicy
        >
      | ValidatedResponse<'__Empty', 400, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 403, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 404, Schemas.__Empty>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/api/policies/v1.0/policies';
        const query = {} as Record<string, any>;
        if (params.filterOpDescription !== undefined) {
            query['filter:op[description]'] = params.filterOpDescription;
        }

        if (params.filterOpName !== undefined) {
            query['filter:op[name]'] = params.filterOpName;
        }

        if (params.filterDescription !== undefined) {
            query['filter[description]'] = params.filterDescription;
        }

        if (params.filterIsEnabled !== undefined) {
            query['filter[is_enabled]'] = params.filterIsEnabled;
        }

        if (params.filterName !== undefined) {
            query['filter[name]'] = params.filterName;
        }

        if (params.limit !== undefined) {
            query.limit = params.limit;
        }

        if (params.offset !== undefined) {
            query.offset = params.offset;
        }

        if (params.sortColumn !== undefined) {
            query.sortColumn = params.sortColumn;
        }

        if (params.sortDirection !== undefined) {
            query.sortDirection = params.sortDirection;
        }

        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(
                    Schemas.PagedResponseOfPolicy,
                    'PagedResponseOfPolicy',
                    200
                ),
                new ValidateRule(Schemas.__Empty, '__Empty', 400),
                new ValidateRule(Schemas.__Empty, '__Empty', 403),
                new ValidateRule(Schemas.__Empty, '__Empty', 404)
            ]
        })
        .build();
    };
  }
  // POST /policies
  // Validate (and possibly persist) a passed policy for the given account
  export namespace PostPolicies {
    const AlsoStore = z.boolean();
    type AlsoStore = z.infer<typeof AlsoStore>;
    const Response400 = z.object({
        msg: z.string().optional().nullable()
    });
    type Response400 = z.infer<typeof Response400>;
    const Response409 = z.object({
        msg: z.string().optional().nullable()
    });
    type Response409 = z.infer<typeof Response409>;
    export interface Params {
      alsoStore?: AlsoStore;
      body: Schemas.Policy;
    }

    export type Payload =
      | ValidatedResponse<'__Empty', 200, Schemas.__Empty>
      | ValidatedResponse<'Policy', 201, Schemas.Policy>
      | ValidatedResponse<'unknown', 400, Response400>
      | ValidatedResponse<'__Empty', 403, Schemas.__Empty>
      | ValidatedResponse<'unknown', 409, Response409>
      | ValidatedResponse<'__Empty', 500, Schemas.__Empty>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/api/policies/v1.0/policies';
        const query = {} as Record<string, any>;
        if (params.alsoStore !== undefined) {
            query.alsoStore = params.alsoStore;
        }

        return actionBuilder('POST', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [
                new ValidateRule(Schemas.__Empty, '__Empty', 200),
                new ValidateRule(Schemas.Policy, 'Policy', 201),
                new ValidateRule(Response400, 'unknown', 400),
                new ValidateRule(Schemas.__Empty, '__Empty', 403),
                new ValidateRule(Response409, 'unknown', 409),
                new ValidateRule(Schemas.__Empty, '__Empty', 500)
            ]
        })
        .build();
    };
  }
  // GET /policies/ids
  // Return all policy ids for a given account after applying the filters
  export namespace GetPoliciesIds {
    const FilterOpDescription = z.enum([ 'equal', 'like', 'ilike', 'not_equal' ]);
    type FilterOpDescription = z.infer<typeof FilterOpDescription>;
    const FilterOpName = z.enum([ 'equal', 'like', 'ilike', 'not_equal' ]);
    type FilterOpName = z.infer<typeof FilterOpName>;
    const FilterDescription = z.string();
    type FilterDescription = z.infer<typeof FilterDescription>;
    const FilterIsEnabled = z.enum([ 'true', 'false' ]);
    type FilterIsEnabled = z.infer<typeof FilterIsEnabled>;
    const FilterName = z.string();
    type FilterName = z.infer<typeof FilterName>;
    export interface Params {
      filterOpDescription?: FilterOpDescription;
      filterOpName?: FilterOpName;
      filterDescription?: FilterDescription;
      filterIsEnabled?: FilterIsEnabled;
      filterName?: FilterName;
    }

    export type Payload =
      | ValidatedResponse<'List', 200, Schemas.List>
      | ValidatedResponse<'__Empty', 400, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 403, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 404, Schemas.__Empty>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/api/policies/v1.0/policies/ids';
        const query = {} as Record<string, any>;
        if (params.filterOpDescription !== undefined) {
            query['filter:op[description]'] = params.filterOpDescription;
        }

        if (params.filterOpName !== undefined) {
            query['filter:op[name]'] = params.filterOpName;
        }

        if (params.filterDescription !== undefined) {
            query['filter[description]'] = params.filterDescription;
        }

        if (params.filterIsEnabled !== undefined) {
            query['filter[is_enabled]'] = params.filterIsEnabled;
        }

        if (params.filterName !== undefined) {
            query['filter[name]'] = params.filterName;
        }

        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Schemas.List, 'List', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 400),
                new ValidateRule(Schemas.__Empty, '__Empty', 403),
                new ValidateRule(Schemas.__Empty, '__Empty', 404)
            ]
        })
        .build();
    };
  }
  // DELETE /policies/ids
  // Delete policies for a customer by the ids passed in the body. Result will be a list of deleted UUIDs
  export namespace DeletePoliciesIds {
    const Response200 = z.array(Schemas.UUID);
    type Response200 = z.infer<typeof Response200>;
    export interface Params {
      body: Schemas.ListUUID;
    }

    export type Payload =
      | ValidatedResponse<'unknown', 200, Response200>
      | ValidatedResponse<'__Empty', 403, Schemas.__Empty>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/api/policies/v1.0/policies/ids';
        const query = {} as Record<string, any>;
        return actionBuilder('DELETE', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [
                new ValidateRule(Response200, 'unknown', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 403)
            ]
        })
        .build();
    };
  }
  // POST /policies/ids/enabled
  // Enable/disable policies identified by list of uuid in body
  export namespace PostPoliciesIdsEnabled {
    const Enabled = z.boolean();
    type Enabled = z.infer<typeof Enabled>;
    export interface Params {
      enabled?: Enabled;
      body: Schemas.ListUUID;
    }

    export type Payload =
      | ValidatedResponse<'__Empty', 200, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 403, Schemas.__Empty>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/api/policies/v1.0/policies/ids/enabled';
        const query = {} as Record<string, any>;
        if (params.enabled !== undefined) {
            query.enabled = params.enabled;
        }

        return actionBuilder('POST', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [
                new ValidateRule(Schemas.__Empty, '__Empty', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 403)
            ]
        })
        .build();
    };
  }
  // POST /policies/validate
  // Validates a Policy condition
  export namespace PostPoliciesValidate {
    export interface Params {
      body: Schemas.Policy;
    }

    export type Payload =
      | ValidatedResponse<'__Empty', 200, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 400, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 500, Schemas.__Empty>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/api/policies/v1.0/policies/validate';
        const query = {} as Record<string, any>;
        return actionBuilder('POST', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [
                new ValidateRule(Schemas.__Empty, '__Empty', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 400),
                new ValidateRule(Schemas.__Empty, '__Empty', 500)
            ]
        })
        .build();
    };
  }
  // POST /policies/validate-name
  // Validates the Policy.name and verifies if it is unique.
  export namespace PostPoliciesValidateName {
    const Body = z.string();
    type Body = z.infer<typeof Body>;
    export interface Params {
      id?: Schemas.UUID;
      body: Body;
    }

    export type Payload =
      | ValidatedResponse<'__Empty', 200, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 400, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 403, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 409, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 500, Schemas.__Empty>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/api/policies/v1.0/policies/validate-name';
        const query = {} as Record<string, any>;
        if (params.id !== undefined) {
            query.id = params.id;
        }

        return actionBuilder('POST', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [
                new ValidateRule(Schemas.__Empty, '__Empty', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 400),
                new ValidateRule(Schemas.__Empty, '__Empty', 403),
                new ValidateRule(Schemas.__Empty, '__Empty', 409),
                new ValidateRule(Schemas.__Empty, '__Empty', 500)
            ]
        })
        .build();
    };
  }
  // GET /policies/{id}
  // Retrieve a single policy for a customer by its id
  export namespace GetPoliciesById {
    export interface Params {
      id: Schemas.UUID;
    }

    export type Payload =
      | ValidatedResponse<'Policy', 200, Schemas.Policy>
      | ValidatedResponse<'__Empty', 403, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 404, Schemas.__Empty>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/api/policies/v1.0/policies/{id}'.replace(
            '{id}',
            params.id.toString()
        );
        const query = {} as Record<string, any>;
        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Schemas.Policy, 'Policy', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 403),
                new ValidateRule(Schemas.__Empty, '__Empty', 404)
            ]
        })
        .build();
    };
  }
  // DELETE /policies/{id}
  // Delete a single policy for a customer by its id
  export namespace DeletePoliciesById {
    export interface Params {
      id: Schemas.UUID;
    }

    export type Payload =
      | ValidatedResponse<'__Empty', 200, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 403, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 404, Schemas.__Empty>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/api/policies/v1.0/policies/{id}'.replace(
            '{id}',
            params.id.toString()
        );
        const query = {} as Record<string, any>;
        return actionBuilder('DELETE', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Schemas.__Empty, '__Empty', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 403),
                new ValidateRule(Schemas.__Empty, '__Empty', 404)
            ]
        })
        .build();
    };
  }
  // POST /policies/{id}/enabled
  // Enable/disable a policy
  export namespace PostPoliciesByIdEnabled {
    const Enabled = z.boolean();
    type Enabled = z.infer<typeof Enabled>;
    export interface Params {
      id: Schemas.UUID;
      enabled?: Enabled;
    }

    export type Payload =
      | ValidatedResponse<'__Empty', 200, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 403, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 404, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 500, Schemas.__Empty>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/api/policies/v1.0/policies/{id}/enabled'.replace(
            '{id}',
            params.id.toString()
        );
        const query = {} as Record<string, any>;
        if (params.enabled !== undefined) {
            query.enabled = params.enabled;
        }

        return actionBuilder('POST', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Schemas.__Empty, '__Empty', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 403),
                new ValidateRule(Schemas.__Empty, '__Empty', 404),
                new ValidateRule(Schemas.__Empty, '__Empty', 500)
            ]
        })
        .build();
    };
  }
  // GET /policies/{id}/history/trigger
  // Retrieve the trigger history of a single policy
  export namespace GetPoliciesByIdHistoryTrigger {
    const FilterOpId = z.enum([ 'equal', 'not_equal', 'like' ]);
    type FilterOpId = z.infer<typeof FilterOpId>;
    const FilterOpName = z.enum([ 'equal', 'like', 'not_equal' ]);
    type FilterOpName = z.infer<typeof FilterOpName>;
    const FilterId = z.string();
    type FilterId = z.infer<typeof FilterId>;
    const FilterName = z.string();
    type FilterName = z.infer<typeof FilterName>;
    const Limit = z.number().int();
    type Limit = z.infer<typeof Limit>;
    const Offset = z.number().int();
    type Offset = z.infer<typeof Offset>;
    const SortColumn = z.enum([ 'hostName', 'id', 'ctime' ]);
    type SortColumn = z.infer<typeof SortColumn>;
    const SortDirection = z.enum([ 'asc', 'desc' ]);
    type SortDirection = z.infer<typeof SortDirection>;
    export interface Params {
      id: Schemas.UUID;
      filterOpId?: FilterOpId;
      filterOpName?: FilterOpName;
      filterId?: FilterId;
      filterName?: FilterName;
      limit?: Limit;
      offset?: Offset;
      sortColumn?: SortColumn;
      sortDirection?: SortDirection;
    }

    export type Payload =
      | ValidatedResponse<
          'PagedResponseOfHistoryItem',
          200,
          Schemas.PagedResponseOfHistoryItem
        >
      | ValidatedResponse<'__Empty', 400, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 403, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 404, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 500, Schemas.__Empty>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/api/policies/v1.0/policies/{id}/history/trigger'.replace(
            '{id}',
            params.id.toString()
        );
        const query = {} as Record<string, any>;
        if (params.filterOpId !== undefined) {
            query['filter:op[id]'] = params.filterOpId;
        }

        if (params.filterOpName !== undefined) {
            query['filter:op[name]'] = params.filterOpName;
        }

        if (params.filterId !== undefined) {
            query['filter[id]'] = params.filterId;
        }

        if (params.filterName !== undefined) {
            query['filter[name]'] = params.filterName;
        }

        if (params.limit !== undefined) {
            query.limit = params.limit;
        }

        if (params.offset !== undefined) {
            query.offset = params.offset;
        }

        if (params.sortColumn !== undefined) {
            query.sortColumn = params.sortColumn;
        }

        if (params.sortDirection !== undefined) {
            query.sortDirection = params.sortDirection;
        }

        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(
                    Schemas.PagedResponseOfHistoryItem,
                    'PagedResponseOfHistoryItem',
                    200
                ),
                new ValidateRule(Schemas.__Empty, '__Empty', 400),
                new ValidateRule(Schemas.__Empty, '__Empty', 403),
                new ValidateRule(Schemas.__Empty, '__Empty', 404),
                new ValidateRule(Schemas.__Empty, '__Empty', 500)
            ]
        })
        .build();
    };
  }
  // PUT /policies/{policyId}
  // Update a single policy for a customer by its id
  export namespace PutPoliciesByPolicyId {
    const Dry = z.boolean();
    type Dry = z.infer<typeof Dry>;
    const Response409 = z.object({
        msg: z.string().optional().nullable()
    });
    type Response409 = z.infer<typeof Response409>;
    export interface Params {
      policyId: Schemas.UUID;
      dry?: Dry;
      body: Schemas.Policy;
    }

    export type Payload =
      | ValidatedResponse<'__Empty', 200, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 400, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 403, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 404, Schemas.__Empty>
      | ValidatedResponse<'unknown', 409, Response409>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/api/policies/v1.0/policies/{policyId}'.replace(
            '{policyId}',
            params.policyId.toString()
        );
        const query = {} as Record<string, any>;
        if (params.dry !== undefined) {
            query.dry = params.dry;
        }

        return actionBuilder('PUT', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [
                new ValidateRule(Schemas.__Empty, '__Empty', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 400),
                new ValidateRule(Schemas.__Empty, '__Empty', 403),
                new ValidateRule(Schemas.__Empty, '__Empty', 404),
                new ValidateRule(Response409, 'unknown', 409)
            ]
        })
        .build();
    };
  }
  // GET /status
  export namespace GetStatus {
    export type Payload =
      | ValidatedResponse<'__Empty', 200, Schemas.__Empty>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (): ActionCreator => {
        const path = '/api/policies/v1.0/status';
        const query = {} as Record<string, any>;
        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [ new ValidateRule(Schemas.__Empty, '__Empty', 200) ]
        })
        .build();
    };
  }
}
"
`;

exports[`src/cli/schema execute for ./tests/__fixtures__/policies-openapi.json execute input file accepts path: compiled 1`] = `
"\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.Operations = exports.Schemas = void 0;
/* eslint-disable */
/**
 * Generated code, DO NOT modify directly.
 */
var z = require(\\"zod\\");
var openapi2typescript_1 = require(\\"openapi2typescript\\");
var react_fetching_library_1 = require(\\"openapi2typescript/react-fetching-library\\");
var Schemas;
(function (Schemas) {
    Schemas.Fact = zodSchemaFact();
    Schemas.FactType = zodSchemaFactType();
    Schemas.HistoryItem = zodSchemaHistoryItem();
    Schemas.List = zodSchemaList();
    Schemas.ListHistoryItem = zodSchemaListHistoryItem();
    Schemas.ListPolicy = zodSchemaListPolicy();
    Schemas.ListUUID = zodSchemaListUUID();
    Schemas.MapStringString = zodSchemaMapStringString();
    Schemas.Meta = zodSchemaMeta();
    Schemas.PagedResponseOfHistoryItem = zodSchemaPagedResponseOfHistoryItem();
    Schemas.PagedResponseOfPolicy = zodSchemaPagedResponseOfPolicy();
    Schemas.Policy = zodSchemaPolicy();
    Schemas.UUID = zodSchemaUUID();
    Schemas.__Empty = zodSchema__Empty();
    function zodSchemaFact() {
        return z.object({
            id: z.number().int().optional().nullable(),
            name: z.string().optional().nullable(),
            type: zodSchemaFactType().optional().nullable()
        });
    }
    function zodSchemaFactType() {
        return z.enum(['BOOLEAN', 'INT', 'LIST', 'STRING']);
    }
    function zodSchemaHistoryItem() {
        return z.object({
            ctime: z.number().int().optional().nullable(),
            hostName: z.string().optional().nullable(),
            id: z.string().optional().nullable()
        });
    }
    function zodSchemaList() {
        return z.array(z.unknown());
    }
    function zodSchemaListHistoryItem() {
        return z.array(zodSchemaHistoryItem());
    }
    function zodSchemaListPolicy() {
        return z.array(zodSchemaPolicy());
    }
    function zodSchemaListUUID() {
        return z.array(z.string());
    }
    function zodSchemaMapStringString() {
        return z.record(z.string());
    }
    function zodSchemaMeta() {
        return z.object({
            count: z.number().int().optional().nullable()
        });
    }
    function zodSchemaPagedResponseOfHistoryItem() {
        return z.object({
            data: zodSchemaListHistoryItem().optional().nullable(),
            links: zodSchemaMapStringString().optional().nullable(),
            meta: zodSchemaMeta().optional().nullable()
        });
    }
    function zodSchemaPagedResponseOfPolicy() {
        return z.object({
            data: zodSchemaListPolicy().optional().nullable(),
            links: zodSchemaMapStringString().optional().nullable(),
            meta: zodSchemaMeta().optional().nullable()
        });
    }
    function zodSchemaPolicy() {
        return z.object({
            actions: z.string().optional().nullable(),
            conditions: z.string(),
            ctime: z.string().optional().nullable(),
            description: z.string().optional().nullable(),
            id: zodSchemaUUID().optional().nullable(),
            isEnabled: z.boolean().optional().nullable(),
            lastTriggered: z.number().int().optional().nullable(),
            mtime: z.string().optional().nullable(),
            name: z.string()
        });
    }
    function zodSchemaUUID() {
        return z.string();
    }
    function zodSchema__Empty() {
        return z.string().max(0).optional();
    }
})(Schemas = exports.Schemas || (exports.Schemas = {}));
var Operations;
(function (Operations) {
    // GET /
    // Just a filler to have a defined return code for the base path
    var Get;
    (function (Get) {
        Get.actionCreator = function () {
            var path = '/api/policies/v1.0/';
            var query = {};
            return (0, react_fetching_library_1.actionBuilder)('GET', path)
                .queryParams(query)
                .config({
                rules: [new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 404)]
            })
                .build();
        };
    })(Get = Operations.Get || (Operations.Get = {}));
    // GET /facts
    // Retrieve a list of fact (keys) along with their data types
    var GetFacts;
    (function (GetFacts) {
        var Response200 = z.array(Schemas.Fact);
        GetFacts.actionCreator = function () {
            var path = '/api/policies/v1.0/facts';
            var query = {};
            return (0, react_fetching_library_1.actionBuilder)('GET', path)
                .queryParams(query)
                .config({
                rules: [new openapi2typescript_1.ValidateRule(Response200, 'unknown', 200)]
            })
                .build();
        };
    })(GetFacts = Operations.GetFacts || (Operations.GetFacts = {}));
    // GET /policies
    // Return all policies for a given account
    var GetPolicies;
    (function (GetPolicies) {
        var FilterOpDescription = z.enum(['equal', 'like', 'ilike', 'not_equal']);
        var FilterOpName = z.enum(['equal', 'like', 'ilike', 'not_equal']);
        var FilterDescription = z.string();
        var FilterIsEnabled = z.enum(['true', 'false']);
        var FilterName = z.string();
        var Limit = z.number().int();
        var Offset = z.number().int();
        var SortColumn = z.enum(['name', 'description', 'is_enabled', 'mtime']);
        var SortDirection = z.enum(['asc', 'desc']);
        /*
     Params
    'filterOpDescription'?:FilterOpDescription,
    'filterOpName'?:FilterOpName,
    'filterDescription'?:FilterDescription,
    'filterIsEnabled'?:FilterIsEnabled,
    'filterName'?:FilterName,
    'limit'?:Limit,
    'offset'?:Offset,
    'sortColumn'?:SortColumn,
    'sortDirection'?:SortDirection
    */
        GetPolicies.actionCreator = function (params) {
            var path = '/api/policies/v1.0/policies';
            var query = {};
            if (params.filterOpDescription !== undefined) {
                query['filter:op[description]'] = params.filterOpDescription;
            }
            if (params.filterOpName !== undefined) {
                query['filter:op[name]'] = params.filterOpName;
            }
            if (params.filterDescription !== undefined) {
                query['filter[description]'] = params.filterDescription;
            }
            if (params.filterIsEnabled !== undefined) {
                query['filter[is_enabled]'] = params.filterIsEnabled;
            }
            if (params.filterName !== undefined) {
                query['filter[name]'] = params.filterName;
            }
            if (params.limit !== undefined) {
                query.limit = params.limit;
            }
            if (params.offset !== undefined) {
                query.offset = params.offset;
            }
            if (params.sortColumn !== undefined) {
                query.sortColumn = params.sortColumn;
            }
            if (params.sortDirection !== undefined) {
                query.sortDirection = params.sortDirection;
            }
            return (0, react_fetching_library_1.actionBuilder)('GET', path)
                .queryParams(query)
                .config({
                rules: [
                    new openapi2typescript_1.ValidateRule(Schemas.PagedResponseOfPolicy, 'PagedResponseOfPolicy', 200),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 400),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 403),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 404)
                ]
            })
                .build();
        };
    })(GetPolicies = Operations.GetPolicies || (Operations.GetPolicies = {}));
    // POST /policies
    // Validate (and possibly persist) a passed policy for the given account
    var PostPolicies;
    (function (PostPolicies) {
        var AlsoStore = z.boolean();
        var Response400 = z.object({
            msg: z.string().optional().nullable()
        });
        var Response409 = z.object({
            msg: z.string().optional().nullable()
        });
        /*
     Params
    'alsoStore'?:AlsoStore,
    body: Schemas.Policy
    */
        PostPolicies.actionCreator = function (params) {
            var path = '/api/policies/v1.0/policies';
            var query = {};
            if (params.alsoStore !== undefined) {
                query.alsoStore = params.alsoStore;
            }
            return (0, react_fetching_library_1.actionBuilder)('POST', path)
                .queryParams(query)
                .data(params.body)
                .config({
                rules: [
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 200),
                    new openapi2typescript_1.ValidateRule(Schemas.Policy, 'Policy', 201),
                    new openapi2typescript_1.ValidateRule(Response400, 'unknown', 400),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 403),
                    new openapi2typescript_1.ValidateRule(Response409, 'unknown', 409),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 500)
                ]
            })
                .build();
        };
    })(PostPolicies = Operations.PostPolicies || (Operations.PostPolicies = {}));
    // GET /policies/ids
    // Return all policy ids for a given account after applying the filters
    var GetPoliciesIds;
    (function (GetPoliciesIds) {
        var FilterOpDescription = z.enum(['equal', 'like', 'ilike', 'not_equal']);
        var FilterOpName = z.enum(['equal', 'like', 'ilike', 'not_equal']);
        var FilterDescription = z.string();
        var FilterIsEnabled = z.enum(['true', 'false']);
        var FilterName = z.string();
        /*
     Params
    'filterOpDescription'?:FilterOpDescription,
    'filterOpName'?:FilterOpName,
    'filterDescription'?:FilterDescription,
    'filterIsEnabled'?:FilterIsEnabled,
    'filterName'?:FilterName
    */
        GetPoliciesIds.actionCreator = function (params) {
            var path = '/api/policies/v1.0/policies/ids';
            var query = {};
            if (params.filterOpDescription !== undefined) {
                query['filter:op[description]'] = params.filterOpDescription;
            }
            if (params.filterOpName !== undefined) {
                query['filter:op[name]'] = params.filterOpName;
            }
            if (params.filterDescription !== undefined) {
                query['filter[description]'] = params.filterDescription;
            }
            if (params.filterIsEnabled !== undefined) {
                query['filter[is_enabled]'] = params.filterIsEnabled;
            }
            if (params.filterName !== undefined) {
                query['filter[name]'] = params.filterName;
            }
            return (0, react_fetching_library_1.actionBuilder)('GET', path)
                .queryParams(query)
                .config({
                rules: [
                    new openapi2typescript_1.ValidateRule(Schemas.List, 'List', 200),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 400),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 403),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 404)
                ]
            })
                .build();
        };
    })(GetPoliciesIds = Operations.GetPoliciesIds || (Operations.GetPoliciesIds = {}));
    // DELETE /policies/ids
    // Delete policies for a customer by the ids passed in the body. Result will be a list of deleted UUIDs
    var DeletePoliciesIds;
    (function (DeletePoliciesIds) {
        var Response200 = z.array(Schemas.UUID);
        /*
     Params
    body: Schemas.ListUUID
    */
        DeletePoliciesIds.actionCreator = function (params) {
            var path = '/api/policies/v1.0/policies/ids';
            var query = {};
            return (0, react_fetching_library_1.actionBuilder)('DELETE', path)
                .queryParams(query)
                .data(params.body)
                .config({
                rules: [
                    new openapi2typescript_1.ValidateRule(Response200, 'unknown', 200),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 403)
                ]
            })
                .build();
        };
    })(DeletePoliciesIds = Operations.DeletePoliciesIds || (Operations.DeletePoliciesIds = {}));
    // POST /policies/ids/enabled
    // Enable/disable policies identified by list of uuid in body
    var PostPoliciesIdsEnabled;
    (function (PostPoliciesIdsEnabled) {
        var Enabled = z.boolean();
        /*
     Params
    'enabled'?:Enabled,
    body: Schemas.ListUUID
    */
        PostPoliciesIdsEnabled.actionCreator = function (params) {
            var path = '/api/policies/v1.0/policies/ids/enabled';
            var query = {};
            if (params.enabled !== undefined) {
                query.enabled = params.enabled;
            }
            return (0, react_fetching_library_1.actionBuilder)('POST', path)
                .queryParams(query)
                .data(params.body)
                .config({
                rules: [
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 200),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 403)
                ]
            })
                .build();
        };
    })(PostPoliciesIdsEnabled = Operations.PostPoliciesIdsEnabled || (Operations.PostPoliciesIdsEnabled = {}));
    // POST /policies/validate
    // Validates a Policy condition
    var PostPoliciesValidate;
    (function (PostPoliciesValidate) {
        /*
     Params
    body: Schemas.Policy
    */
        PostPoliciesValidate.actionCreator = function (params) {
            var path = '/api/policies/v1.0/policies/validate';
            var query = {};
            return (0, react_fetching_library_1.actionBuilder)('POST', path)
                .queryParams(query)
                .data(params.body)
                .config({
                rules: [
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 200),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 400),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 500)
                ]
            })
                .build();
        };
    })(PostPoliciesValidate = Operations.PostPoliciesValidate || (Operations.PostPoliciesValidate = {}));
    // POST /policies/validate-name
    // Validates the Policy.name and verifies if it is unique.
    var PostPoliciesValidateName;
    (function (PostPoliciesValidateName) {
        var Body = z.string();
        /*
     Params
    'id'?:Schemas.UUID,
    body: Body
    */
        PostPoliciesValidateName.actionCreator = function (params) {
            var path = '/api/policies/v1.0/policies/validate-name';
            var query = {};
            if (params.id !== undefined) {
                query.id = params.id;
            }
            return (0, react_fetching_library_1.actionBuilder)('POST', path)
                .queryParams(query)
                .data(params.body)
                .config({
                rules: [
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 200),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 400),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 403),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 409),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 500)
                ]
            })
                .build();
        };
    })(PostPoliciesValidateName = Operations.PostPoliciesValidateName || (Operations.PostPoliciesValidateName = {}));
    // GET /policies/{id}
    // Retrieve a single policy for a customer by its id
    var GetPoliciesById;
    (function (GetPoliciesById) {
        /*
     Params
    'id':Schemas.UUID
    */
        GetPoliciesById.actionCreator = function (params) {
            var path = '/api/policies/v1.0/policies/{id}'.replace('{id}', params.id.toString());
            var query = {};
            return (0, react_fetching_library_1.actionBuilder)('GET', path)
                .queryParams(query)
                .config({
                rules: [
                    new openapi2typescript_1.ValidateRule(Schemas.Policy, 'Policy', 200),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 403),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 404)
                ]
            })
                .build();
        };
    })(GetPoliciesById = Operations.GetPoliciesById || (Operations.GetPoliciesById = {}));
    // DELETE /policies/{id}
    // Delete a single policy for a customer by its id
    var DeletePoliciesById;
    (function (DeletePoliciesById) {
        /*
     Params
    'id':Schemas.UUID
    */
        DeletePoliciesById.actionCreator = function (params) {
            var path = '/api/policies/v1.0/policies/{id}'.replace('{id}', params.id.toString());
            var query = {};
            return (0, react_fetching_library_1.actionBuilder)('DELETE', path)
                .queryParams(query)
                .config({
                rules: [
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 200),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 403),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 404)
                ]
            })
                .build();
        };
    })(DeletePoliciesById = Operations.DeletePoliciesById || (Operations.DeletePoliciesById = {}));
    // POST /policies/{id}/enabled
    // Enable/disable a policy
    var PostPoliciesByIdEnabled;
    (function (PostPoliciesByIdEnabled) {
        var Enabled = z.boolean();
        /*
     Params
    'id':Schemas.UUID,
    'enabled'?:Enabled
    */
        PostPoliciesByIdEnabled.actionCreator = function (params) {
            var path = '/api/policies/v1.0/policies/{id}/enabled'.replace('{id}', params.id.toString());
            var query = {};
            if (params.enabled !== undefined) {
                query.enabled = params.enabled;
            }
            return (0, react_fetching_library_1.actionBuilder)('POST', path)
                .queryParams(query)
                .config({
                rules: [
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 200),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 403),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 404),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 500)
                ]
            })
                .build();
        };
    })(PostPoliciesByIdEnabled = Operations.PostPoliciesByIdEnabled || (Operations.PostPoliciesByIdEnabled = {}));
    // GET /policies/{id}/history/trigger
    // Retrieve the trigger history of a single policy
    var GetPoliciesByIdHistoryTrigger;
    (function (GetPoliciesByIdHistoryTrigger) {
        var FilterOpId = z.enum(['equal', 'not_equal', 'like']);
        var FilterOpName = z.enum(['equal', 'like', 'not_equal']);
        var FilterId = z.string();
        var FilterName = z.string();
        var Limit = z.number().int();
        var Offset = z.number().int();
        var SortColumn = z.enum(['hostName', 'id', 'ctime']);
        var SortDirection = z.enum(['asc', 'desc']);
        /*
     Params
    'id':Schemas.UUID,
    'filterOpId'?:FilterOpId,
    'filterOpName'?:FilterOpName,
    'filterId'?:FilterId,
    'filterName'?:FilterName,
    'limit'?:Limit,
    'offset'?:Offset,
    'sortColumn'?:SortColumn,
    'sortDirection'?:SortDirection
    */
        GetPoliciesByIdHistoryTrigger.actionCreator = function (params) {
            var path = '/api/policies/v1.0/policies/{id}/history/trigger'.replace('{id}', params.id.toString());
            var query = {};
            if (params.filterOpId !== undefined) {
                query['filter:op[id]'] = params.filterOpId;
            }
            if (params.filterOpName !== undefined) {
                query['filter:op[name]'] = params.filterOpName;
            }
            if (params.filterId !== undefined) {
                query['filter[id]'] = params.filterId;
            }
            if (params.filterName !== undefined) {
                query['filter[name]'] = params.filterName;
            }
            if (params.limit !== undefined) {
                query.limit = params.limit;
            }
            if (params.offset !== undefined) {
                query.offset = params.offset;
            }
            if (params.sortColumn !== undefined) {
                query.sortColumn = params.sortColumn;
            }
            if (params.sortDirection !== undefined) {
                query.sortDirection = params.sortDirection;
            }
            return (0, react_fetching_library_1.actionBuilder)('GET', path)
                .queryParams(query)
                .config({
                rules: [
                    new openapi2typescript_1.ValidateRule(Schemas.PagedResponseOfHistoryItem, 'PagedResponseOfHistoryItem', 200),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 400),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 403),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 404),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 500)
                ]
            })
                .build();
        };
    })(GetPoliciesByIdHistoryTrigger = Operations.GetPoliciesByIdHistoryTrigger || (Operations.GetPoliciesByIdHistoryTrigger = {}));
    // PUT /policies/{policyId}
    // Update a single policy for a customer by its id
    var PutPoliciesByPolicyId;
    (function (PutPoliciesByPolicyId) {
        var Dry = z.boolean();
        var Response409 = z.object({
            msg: z.string().optional().nullable()
        });
        /*
     Params
    'policyId':Schemas.UUID,
    'dry'?:Dry,
    body: Schemas.Policy
    */
        PutPoliciesByPolicyId.actionCreator = function (params) {
            var path = '/api/policies/v1.0/policies/{policyId}'.replace('{policyId}', params.policyId.toString());
            var query = {};
            if (params.dry !== undefined) {
                query.dry = params.dry;
            }
            return (0, react_fetching_library_1.actionBuilder)('PUT', path)
                .queryParams(query)
                .data(params.body)
                .config({
                rules: [
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 200),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 400),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 403),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 404),
                    new openapi2typescript_1.ValidateRule(Response409, 'unknown', 409)
                ]
            })
                .build();
        };
    })(PutPoliciesByPolicyId = Operations.PutPoliciesByPolicyId || (Operations.PutPoliciesByPolicyId = {}));
    // GET /status
    var GetStatus;
    (function (GetStatus) {
        GetStatus.actionCreator = function () {
            var path = '/api/policies/v1.0/status';
            var query = {};
            return (0, react_fetching_library_1.actionBuilder)('GET', path)
                .queryParams(query)
                .config({
                rules: [new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 200)]
            })
                .build();
        };
    })(GetStatus = Operations.GetStatus || (Operations.GetStatus = {}));
})(Operations = exports.Operations || (exports.Operations = {}));
"
`;

exports[`src/cli/schema execute for ./tests/__fixtures__/policies-openapi.json execute input file accepts path: generated 1`] = `
"/* eslint-disable */
/**
 * Generated code, DO NOT modify directly.
 */
import * as z from 'zod';
import { ValidateRule } from 'openapi2typescript';
import { actionBuilder } from 'openapi2typescript/react-fetching-library';

export namespace Schemas {
  export const Fact = zodSchemaFact();

  export const FactType = zodSchemaFactType();

  export const HistoryItem = zodSchemaHistoryItem();

  export const List = zodSchemaList();

  export const ListHistoryItem = zodSchemaListHistoryItem();

  export const ListPolicy = zodSchemaListPolicy();

  export const ListUUID = zodSchemaListUUID();

  export const MapStringString = zodSchemaMapStringString();

  export const Meta = zodSchemaMeta();

  export const PagedResponseOfHistoryItem =
    zodSchemaPagedResponseOfHistoryItem();

  export const PagedResponseOfPolicy = zodSchemaPagedResponseOfPolicy();

  export const Policy = zodSchemaPolicy();

  export const UUID = zodSchemaUUID();

  export const __Empty = zodSchema__Empty();

  function zodSchemaFact() {
      return z.object({
          id: z.number().int().optional().nullable(),
          name: z.string().optional().nullable(),
          type: zodSchemaFactType().optional().nullable()
      });
  }

  function zodSchemaFactType() {
      return z.enum([ 'BOOLEAN', 'INT', 'LIST', 'STRING' ]);
  }

  function zodSchemaHistoryItem() {
      return z.object({
          ctime: z.number().int().optional().nullable(),
          hostName: z.string().optional().nullable(),
          id: z.string().optional().nullable()
      });
  }

  function zodSchemaList() {
      return z.array(z.unknown());
  }

  function zodSchemaListHistoryItem() {
      return z.array(zodSchemaHistoryItem());
  }

  function zodSchemaListPolicy() {
      return z.array(zodSchemaPolicy());
  }

  function zodSchemaListUUID() {
      return z.array(z.string());
  }

  function zodSchemaMapStringString() {
      return z.record(z.string());
  }

  function zodSchemaMeta() {
      return z.object({
          count: z.number().int().optional().nullable()
      });
  }

  function zodSchemaPagedResponseOfHistoryItem() {
      return z.object({
          data: zodSchemaListHistoryItem().optional().nullable(),
          links: zodSchemaMapStringString().optional().nullable(),
          meta: zodSchemaMeta().optional().nullable()
      });
  }

  function zodSchemaPagedResponseOfPolicy() {
      return z.object({
          data: zodSchemaListPolicy().optional().nullable(),
          links: zodSchemaMapStringString().optional().nullable(),
          meta: zodSchemaMeta().optional().nullable()
      });
  }

  function zodSchemaPolicy() {
      return z.object({
          actions: z.string().optional().nullable(),
          conditions: z.string(),
          ctime: z.string().optional().nullable(),
          description: z.string().optional().nullable(),
          id: zodSchemaUUID().optional().nullable(),
          isEnabled: z.boolean().optional().nullable(),
          lastTriggered: z.number().int().optional().nullable(),
          mtime: z.string().optional().nullable(),
          name: z.string()
      });
  }

  function zodSchemaUUID() {
      return z.string();
  }

  function zodSchema__Empty() {
      return z.string().max(0).optional();
  }
}

export namespace Operations {
  // GET /
  // Just a filler to have a defined return code for the base path
  export namespace Get {
    export const actionCreator = () => {
        const path = '/api/policies/v1.0/';
        const query = {};
        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [ new ValidateRule(Schemas.__Empty, '__Empty', 404) ]
        })
        .build();
    };
  }
  // GET /facts
  // Retrieve a list of fact (keys) along with their data types
  export namespace GetFacts {
    const Response200 = z.array(Schemas.Fact);
    export const actionCreator = () => {
        const path = '/api/policies/v1.0/facts';
        const query = {};
        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [ new ValidateRule(Response200, 'unknown', 200) ]
        })
        .build();
    };
  }
  // GET /policies
  // Return all policies for a given account
  export namespace GetPolicies {
    const FilterOpDescription = z.enum([ 'equal', 'like', 'ilike', 'not_equal' ]);
    const FilterOpName = z.enum([ 'equal', 'like', 'ilike', 'not_equal' ]);
    const FilterDescription = z.string();
    const FilterIsEnabled = z.enum([ 'true', 'false' ]);
    const FilterName = z.string();
    const Limit = z.number().int();
    const Offset = z.number().int();
    const SortColumn = z.enum([ 'name', 'description', 'is_enabled', 'mtime' ]);
    const SortDirection = z.enum([ 'asc', 'desc' ]);
    /*
 Params
'filterOpDescription'?:FilterOpDescription,
'filterOpName'?:FilterOpName,
'filterDescription'?:FilterDescription,
'filterIsEnabled'?:FilterIsEnabled,
'filterName'?:FilterName,
'limit'?:Limit,
'offset'?:Offset,
'sortColumn'?:SortColumn,
'sortDirection'?:SortDirection
*/
    export const actionCreator = (params) => {
        const path = '/api/policies/v1.0/policies';
        const query = {};
        if (params.filterOpDescription !== undefined) {
            query['filter:op[description]'] = params.filterOpDescription;
        }

        if (params.filterOpName !== undefined) {
            query['filter:op[name]'] = params.filterOpName;
        }

        if (params.filterDescription !== undefined) {
            query['filter[description]'] = params.filterDescription;
        }

        if (params.filterIsEnabled !== undefined) {
            query['filter[is_enabled]'] = params.filterIsEnabled;
        }

        if (params.filterName !== undefined) {
            query['filter[name]'] = params.filterName;
        }

        if (params.limit !== undefined) {
            query.limit = params.limit;
        }

        if (params.offset !== undefined) {
            query.offset = params.offset;
        }

        if (params.sortColumn !== undefined) {
            query.sortColumn = params.sortColumn;
        }

        if (params.sortDirection !== undefined) {
            query.sortDirection = params.sortDirection;
        }

        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(
                    Schemas.PagedResponseOfPolicy,
                    'PagedResponseOfPolicy',
                    200
                ),
                new ValidateRule(Schemas.__Empty, '__Empty', 400),
                new ValidateRule(Schemas.__Empty, '__Empty', 403),
                new ValidateRule(Schemas.__Empty, '__Empty', 404)
            ]
        })
        .build();
    };
  }
  // POST /policies
  // Validate (and possibly persist) a passed policy for the given account
  export namespace PostPolicies {
    const AlsoStore = z.boolean();
    const Response400 = z.object({
        msg: z.string().optional().nullable()
    });
    const Response409 = z.object({
        msg: z.string().optional().nullable()
    });
    /*
 Params
'alsoStore'?:AlsoStore,
body: Schemas.Policy
*/
    export const actionCreator = (params) => {
        const path = '/api/policies/v1.0/policies';
        const query = {};
        if (params.alsoStore !== undefined) {
            query.alsoStore = params.alsoStore;
        }

        return actionBuilder('POST', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [
                new ValidateRule(Schemas.__Empty, '__Empty', 200),
                new ValidateRule(Schemas.Policy, 'Policy', 201),
                new ValidateRule(Response400, 'unknown', 400),
                new ValidateRule(Schemas.__Empty, '__Empty', 403),
                new ValidateRule(Response409, 'unknown', 409),
                new ValidateRule(Schemas.__Empty, '__Empty', 500)
            ]
        })
        .build();
    };
  }
  // GET /policies/ids
  // Return all policy ids for a given account after applying the filters
  export namespace GetPoliciesIds {
    const FilterOpDescription = z.enum([ 'equal', 'like', 'ilike', 'not_equal' ]);
    const FilterOpName = z.enum([ 'equal', 'like', 'ilike', 'not_equal' ]);
    const FilterDescription = z.string();
    const FilterIsEnabled = z.enum([ 'true', 'false' ]);
    const FilterName = z.string();
    /*
 Params
'filterOpDescription'?:FilterOpDescription,
'filterOpName'?:FilterOpName,
'filterDescription'?:FilterDescription,
'filterIsEnabled'?:FilterIsEnabled,
'filterName'?:FilterName
*/
    export const actionCreator = (params) => {
        const path = '/api/policies/v1.0/policies/ids';
        const query = {};
        if (params.filterOpDescription !== undefined) {
            query['filter:op[description]'] = params.filterOpDescription;
        }

        if (params.filterOpName !== undefined) {
            query['filter:op[name]'] = params.filterOpName;
        }

        if (params.filterDescription !== undefined) {
            query['filter[description]'] = params.filterDescription;
        }

        if (params.filterIsEnabled !== undefined) {
            query['filter[is_enabled]'] = params.filterIsEnabled;
        }

        if (params.filterName !== undefined) {
            query['filter[name]'] = params.filterName;
        }

        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Schemas.List, 'List', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 400),
                new ValidateRule(Schemas.__Empty, '__Empty', 403),
                new ValidateRule(Schemas.__Empty, '__Empty', 404)
            ]
        })
        .build();
    };
  }
  // DELETE /policies/ids
  // Delete policies for a customer by the ids passed in the body. Result will be a list of deleted UUIDs
  export namespace DeletePoliciesIds {
    const Response200 = z.array(Schemas.UUID);
    /*
 Params
body: Schemas.ListUUID
*/
    export const actionCreator = (params) => {
        const path = '/api/policies/v1.0/policies/ids';
        const query = {};
        return actionBuilder('DELETE', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [
                new ValidateRule(Response200, 'unknown', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 403)
            ]
        })
        .build();
    };
  }
  // POST /policies/ids/enabled
  // Enable/disable policies identified by list of uuid in body
  export namespace PostPoliciesIdsEnabled {
    const Enabled = z.boolean();
    /*
 Params
'enabled'?:Enabled,
body: Schemas.ListUUID
*/
    export const actionCreator = (params) => {
        const path = '/api/policies/v1.0/policies/ids/enabled';
        const query = {};
        if (params.enabled !== undefined) {
            query.enabled = params.enabled;
        }

        return actionBuilder('POST', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [
                new ValidateRule(Schemas.__Empty, '__Empty', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 403)
            ]
        })
        .build();
    };
  }
  // POST /policies/validate
  // Validates a Policy condition
  export namespace PostPoliciesValidate {
    /*
 Params
body: Schemas.Policy
*/
    export const actionCreator = (params) => {
        const path = '/api/policies/v1.0/policies/validate';
        const query = {};
        return actionBuilder('POST', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [
                new ValidateRule(Schemas.__Empty, '__Empty', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 400),
                new ValidateRule(Schemas.__Empty, '__Empty', 500)
            ]
        })
        .build();
    };
  }
  // POST /policies/validate-name
  // Validates the Policy.name and verifies if it is unique.
  export namespace PostPoliciesValidateName {
    const Body = z.string();
    /*
 Params
'id'?:Schemas.UUID,
body: Body
*/
    export const actionCreator = (params) => {
        const path = '/api/policies/v1.0/policies/validate-name';
        const query = {};
        if (params.id !== undefined) {
            query.id = params.id;
        }

        return actionBuilder('POST', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [
                new ValidateRule(Schemas.__Empty, '__Empty', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 400),
                new ValidateRule(Schemas.__Empty, '__Empty', 403),
                new ValidateRule(Schemas.__Empty, '__Empty', 409),
                new ValidateRule(Schemas.__Empty, '__Empty', 500)
            ]
        })
        .build();
    };
  }
  // GET /policies/{id}
  // Retrieve a single policy for a customer by its id
  export namespace GetPoliciesById {
    /*
 Params
'id':Schemas.UUID
*/
    export const actionCreator = (params) => {
        const path = '/api/policies/v1.0/policies/{id}'.replace(
            '{id}',
            params.id.toString()
        );
        const query = {};
        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Schemas.Policy, 'Policy', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 403),
                new ValidateRule(Schemas.__Empty, '__Empty', 404)
            ]
        })
        .build();
    };
  }
  // DELETE /policies/{id}
  // Delete a single policy for a customer by its id
  export namespace DeletePoliciesById {
    /*
 Params
'id':Schemas.UUID
*/
    export const actionCreator = (params) => {
        const path = '/api/policies/v1.0/policies/{id}'.replace(
            '{id}',
            params.id.toString()
        );
        const query = {};
        return actionBuilder('DELETE', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Schemas.__Empty, '__Empty', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 403),
                new ValidateRule(Schemas.__Empty, '__Empty', 404)
            ]
        })
        .build();
    };
  }
  // POST /policies/{id}/enabled
  // Enable/disable a policy
  export namespace PostPoliciesByIdEnabled {
    const Enabled = z.boolean();
    /*
 Params
'id':Schemas.UUID,
'enabled'?:Enabled
*/
    export const actionCreator = (params) => {
        const path = '/api/policies/v1.0/policies/{id}/enabled'.replace(
            '{id}',
            params.id.toString()
        );
        const query = {};
        if (params.enabled !== undefined) {
            query.enabled = params.enabled;
        }

        return actionBuilder('POST', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Schemas.__Empty, '__Empty', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 403),
                new ValidateRule(Schemas.__Empty, '__Empty', 404),
                new ValidateRule(Schemas.__Empty, '__Empty', 500)
            ]
        })
        .build();
    };
  }
  // GET /policies/{id}/history/trigger
  // Retrieve the trigger history of a single policy
  export namespace GetPoliciesByIdHistoryTrigger {
    const FilterOpId = z.enum([ 'equal', 'not_equal', 'like' ]);
    const FilterOpName = z.enum([ 'equal', 'like', 'not_equal' ]);
    const FilterId = z.string();
    const FilterName = z.string();
    const Limit = z.number().int();
    const Offset = z.number().int();
    const SortColumn = z.enum([ 'hostName', 'id', 'ctime' ]);
    const SortDirection = z.enum([ 'asc', 'desc' ]);
    /*
 Params
'id':Schemas.UUID,
'filterOpId'?:FilterOpId,
'filterOpName'?:FilterOpName,
'filterId'?:FilterId,
'filterName'?:FilterName,
'limit'?:Limit,
'offset'?:Offset,
'sortColumn'?:SortColumn,
'sortDirection'?:SortDirection
*/
    export const actionCreator = (params) => {
        const path = '/api/policies/v1.0/policies/{id}/history/trigger'.replace(
            '{id}',
            params.id.toString()
        );
        const query = {};
        if (params.filterOpId !== undefined) {
            query['filter:op[id]'] = params.filterOpId;
        }

        if (params.filterOpName !== undefined) {
            query['filter:op[name]'] = params.filterOpName;
        }

        if (params.filterId !== undefined) {
            query['filter[id]'] = params.filterId;
        }

        if (params.filterName !== undefined) {
            query['filter[name]'] = params.filterName;
        }

        if (params.limit !== undefined) {
            query.limit = params.limit;
        }

        if (params.offset !== undefined) {
            query.offset = params.offset;
        }

        if (params.sortColumn !== undefined) {
            query.sortColumn = params.sortColumn;
        }

        if (params.sortDirection !== undefined) {
            query.sortDirection = params.sortDirection;
        }

        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(
                    Schemas.PagedResponseOfHistoryItem,
                    'PagedResponseOfHistoryItem',
                    200
                ),
                new ValidateRule(Schemas.__Empty, '__Empty', 400),
                new ValidateRule(Schemas.__Empty, '__Empty', 403),
                new ValidateRule(Schemas.__Empty, '__Empty', 404),
                new ValidateRule(Schemas.__Empty, '__Empty', 500)
            ]
        })
        .build();
    };
  }
  // PUT /policies/{policyId}
  // Update a single policy for a customer by its id
  export namespace PutPoliciesByPolicyId {
    const Dry = z.boolean();
    const Response409 = z.object({
        msg: z.string().optional().nullable()
    });
    /*
 Params
'policyId':Schemas.UUID,
'dry'?:Dry,
body: Schemas.Policy
*/
    export const actionCreator = (params) => {
        const path = '/api/policies/v1.0/policies/{policyId}'.replace(
            '{policyId}',
            params.policyId.toString()
        );
        const query = {};
        if (params.dry !== undefined) {
            query.dry = params.dry;
        }

        return actionBuilder('PUT', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [
                new ValidateRule(Schemas.__Empty, '__Empty', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 400),
                new ValidateRule(Schemas.__Empty, '__Empty', 403),
                new ValidateRule(Schemas.__Empty, '__Empty', 404),
                new ValidateRule(Response409, 'unknown', 409)
            ]
        })
        .build();
    };
  }
  // GET /status
  export namespace GetStatus {
    export const actionCreator = () => {
        const path = '/api/policies/v1.0/status';
        const query = {};
        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [ new ValidateRule(Schemas.__Empty, '__Empty', 200) ]
        })
        .build();
    };
  }
}
"
`;

exports[`src/cli/schema execute for ./tests/__fixtures__/rbac-openapi.json execute accepts urls 1`] = `
"/* eslint-disable */
/**
 * Generated code, DO NOT modify directly.
 */
import * as z from 'zod';
import { ValidatedResponse } from 'openapi2typescript';
import { Action } from 'react-fetching-library';
import { ValidateRule } from 'openapi2typescript';
import {
    actionBuilder,
    ActionValidatableConfig
} from 'openapi2typescript/react-fetching-library';

export namespace Schemas {
  export const Access = zodSchemaAccess();
  export type Access = z.infer<typeof Access>;

  export const AccessPagination = zodSchemaAccessPagination();
  export type AccessPagination = z.infer<typeof AccessPagination>;

  export const AdditionalGroup = zodSchemaAdditionalGroup();
  export type AdditionalGroup = z.infer<typeof AdditionalGroup>;

  export const CrossAccountRequest = zodSchemaCrossAccountRequest();
  export type CrossAccountRequest = z.infer<typeof CrossAccountRequest>;

  export const CrossAccountRequestByAccount =
    zodSchemaCrossAccountRequestByAccount();
  export type CrossAccountRequestByAccount = z.infer<
    typeof CrossAccountRequestByAccount
  >;

  export const CrossAccountRequestByUserId =
    zodSchemaCrossAccountRequestByUserId();
  export type CrossAccountRequestByUserId = z.infer<
    typeof CrossAccountRequestByUserId
  >;

  export const CrossAccountRequestDetail = zodSchemaCrossAccountRequestDetail();
  export type CrossAccountRequestDetail = z.infer<
    typeof CrossAccountRequestDetail
  >;

  export const CrossAccountRequestDetailByAccount =
    zodSchemaCrossAccountRequestDetailByAccount();
  export type CrossAccountRequestDetailByAccount = z.infer<
    typeof CrossAccountRequestDetailByAccount
  >;

  export const CrossAccountRequestDetailByUseId =
    zodSchemaCrossAccountRequestDetailByUseId();
  export type CrossAccountRequestDetailByUseId = z.infer<
    typeof CrossAccountRequestDetailByUseId
  >;

  export const CrossAccountRequestIn = zodSchemaCrossAccountRequestIn();
  export type CrossAccountRequestIn = z.infer<typeof CrossAccountRequestIn>;

  export const CrossAccountRequestOut = zodSchemaCrossAccountRequestOut();
  export type CrossAccountRequestOut = z.infer<typeof CrossAccountRequestOut>;

  export const CrossAccountRequestPagination =
    zodSchemaCrossAccountRequestPagination();
  export type CrossAccountRequestPagination = z.infer<
    typeof CrossAccountRequestPagination
  >;

  export const CrossAccountRequestPatch = zodSchemaCrossAccountRequestPatch();
  export type CrossAccountRequestPatch = z.infer<
    typeof CrossAccountRequestPatch
  >;

  export const CrossAccountRequestUpdateIn =
    zodSchemaCrossAccountRequestUpdateIn();
  export type CrossAccountRequestUpdateIn = z.infer<
    typeof CrossAccountRequestUpdateIn
  >;

  export const CrossAccountRequestWithRoles =
    zodSchemaCrossAccountRequestWithRoles();
  export type CrossAccountRequestWithRoles = z.infer<
    typeof CrossAccountRequestWithRoles
  >;

  export const Error = zodSchemaError();
  export type Error = z.infer<typeof Error>;

  export const Error403 = zodSchemaError403();
  export type Error403 = z.infer<typeof Error403>;

  export const Group = zodSchemaGroup();
  export type Group = z.infer<typeof Group>;

  export const GroupOut = zodSchemaGroupOut();
  export type GroupOut = z.infer<typeof GroupOut>;

  export const GroupPagination = zodSchemaGroupPagination();
  export type GroupPagination = z.infer<typeof GroupPagination>;

  export const GroupPrincipalIn = zodSchemaGroupPrincipalIn();
  export type GroupPrincipalIn = z.infer<typeof GroupPrincipalIn>;

  export const GroupRoleIn = zodSchemaGroupRoleIn();
  export type GroupRoleIn = z.infer<typeof GroupRoleIn>;

  export const GroupRolesPagination = zodSchemaGroupRolesPagination();
  export type GroupRolesPagination = z.infer<typeof GroupRolesPagination>;

  export const GroupWithPrincipals = zodSchemaGroupWithPrincipals();
  export type GroupWithPrincipals = z.infer<typeof GroupWithPrincipals>;

  export const GroupWithPrincipalsAndRoles =
    zodSchemaGroupWithPrincipalsAndRoles();
  export type GroupWithPrincipalsAndRoles = z.infer<
    typeof GroupWithPrincipalsAndRoles
  >;

  export const ListPagination = zodSchemaListPagination();
  export type ListPagination = z.infer<typeof ListPagination>;

  export const PaginationLinks = zodSchemaPaginationLinks();
  export type PaginationLinks = z.infer<typeof PaginationLinks>;

  export const PaginationMeta = zodSchemaPaginationMeta();
  export type PaginationMeta = z.infer<typeof PaginationMeta>;

  export const Permission = zodSchemaPermission();
  export type Permission = z.infer<typeof Permission>;

  export const PermissionOptionsPagination =
    zodSchemaPermissionOptionsPagination();
  export type PermissionOptionsPagination = z.infer<
    typeof PermissionOptionsPagination
  >;

  export const PermissionPagination = zodSchemaPermissionPagination();
  export type PermissionPagination = z.infer<typeof PermissionPagination>;

  export const Policy = zodSchemaPolicy();
  export type Policy = z.infer<typeof Policy>;

  export const PolicyExtended = zodSchemaPolicyExtended();
  export type PolicyExtended = z.infer<typeof PolicyExtended>;

  export const PolicyIn = zodSchemaPolicyIn();
  export type PolicyIn = z.infer<typeof PolicyIn>;

  export const PolicyPagination = zodSchemaPolicyPagination();
  export type PolicyPagination = z.infer<typeof PolicyPagination>;

  export const Principal = zodSchemaPrincipal();
  export type Principal = z.infer<typeof Principal>;

  export const PrincipalIn = zodSchemaPrincipalIn();
  export type PrincipalIn = z.infer<typeof PrincipalIn>;

  export const PrincipalOut = zodSchemaPrincipalOut();
  export type PrincipalOut = z.infer<typeof PrincipalOut>;

  export const PrincipalPagination = zodSchemaPrincipalPagination();
  export type PrincipalPagination = z.infer<typeof PrincipalPagination>;

  export const ResourceDefinition = zodSchemaResourceDefinition();
  export type ResourceDefinition = z.infer<typeof ResourceDefinition>;

  export const ResourceDefinitionFilter = zodSchemaResourceDefinitionFilter();
  export type ResourceDefinitionFilter = z.infer<
    typeof ResourceDefinitionFilter
  >;

  export const Role = zodSchemaRole();
  export type Role = z.infer<typeof Role>;

  export const RoleIn = zodSchemaRoleIn();
  export type RoleIn = z.infer<typeof RoleIn>;

  export const RoleOut = zodSchemaRoleOut();
  export type RoleOut = z.infer<typeof RoleOut>;

  export const RoleOutDynamic = zodSchemaRoleOutDynamic();
  export type RoleOutDynamic = z.infer<typeof RoleOutDynamic>;

  export const RolePagination = zodSchemaRolePagination();
  export type RolePagination = z.infer<typeof RolePagination>;

  export const RolePaginationDynamic = zodSchemaRolePaginationDynamic();
  export type RolePaginationDynamic = z.infer<typeof RolePaginationDynamic>;

  export const RolePatch = zodSchemaRolePatch();
  export type RolePatch = z.infer<typeof RolePatch>;

  export const RoleWithAccess = zodSchemaRoleWithAccess();
  export type RoleWithAccess = z.infer<typeof RoleWithAccess>;

  export const Status = zodSchemaStatus();
  export type Status = z.infer<typeof Status>;

  export const Timestamped = zodSchemaTimestamped();
  export type Timestamped = z.infer<typeof Timestamped>;

  export const UUID = zodSchemaUUID();
  export type UUID = z.infer<typeof UUID>;

  export const __Empty = zodSchema__Empty();
  export type __Empty = z.infer<typeof __Empty>;

  function zodSchemaAccess() {
      return z.object({
          permission: z.string(),
          resourceDefinitions: z.array(zodSchemaResourceDefinition())
      });
  }

  function zodSchemaAccessPagination() {
      return z.intersection(
          zodSchemaListPagination(),
          z.object({
              data: z.array(zodSchemaAccess())
          })
      );
  }

  function zodSchemaAdditionalGroup() {
      return z.object({
          description: z.string().optional().nullable(),
          name: z.string().optional().nullable(),
          uuid: z.string().optional().nullable()
      });
  }

  function zodSchemaCrossAccountRequest() {
      return z.object({
          created: z.string().optional().nullable(),
          end_date: z.unknown().optional().nullable(),
          request_id: z.string().optional().nullable(),
          start_date: z.unknown().optional().nullable(),
          status: z.string().optional().nullable(),
          target_account: z.string().optional().nullable()
      });
  }

  function zodSchemaCrossAccountRequestByAccount() {
      return z.intersection(
          zodSchemaCrossAccountRequest(),
          z.object({
              email: z.string().optional().nullable(),
              first_name: z.string().optional().nullable(),
              last_name: z.string().optional().nullable()
          })
      );
  }

  function zodSchemaCrossAccountRequestByUserId() {
      return z.intersection(
          zodSchemaCrossAccountRequest(),
          z.object({
              user_id: z.string().optional().nullable()
          })
      );
  }

  function zodSchemaCrossAccountRequestDetail() {
      return z.union([
          zodSchemaCrossAccountRequestDetailByAccount(),
          zodSchemaCrossAccountRequestDetailByUseId()
      ]);
  }

  function zodSchemaCrossAccountRequestDetailByAccount() {
      return z.intersection(
          zodSchemaCrossAccountRequestWithRoles(),
          z.object({
              email: z.unknown().optional().nullable(),
              first_name: z.unknown().optional().nullable(),
              last_name: z.unknown().optional().nullable()
          })
      );
  }

  function zodSchemaCrossAccountRequestDetailByUseId() {
      return z.intersection(
          zodSchemaCrossAccountRequestWithRoles(),
          z.object({
              user_id: z.unknown().optional().nullable()
          })
      );
  }

  function zodSchemaCrossAccountRequestIn() {
      return z.object({
          end_date: z.string(),
          roles: z.array(z.string()),
          start_date: z.string(),
          target_account: z.string()
      });
  }

  function zodSchemaCrossAccountRequestOut() {
      return z.intersection(
          zodSchemaCrossAccountRequestWithRoles(),
          z.object({
              user_id: z.string().optional().nullable()
          })
      );
  }

  function zodSchemaCrossAccountRequestPagination() {
      return z.intersection(
          zodSchemaListPagination(),
          z.object({
              data: z.array(
                  z.union([
                      zodSchemaCrossAccountRequestByAccount(),
                      zodSchemaCrossAccountRequestByUserId()
                  ])
              )
          })
      );
  }

  function zodSchemaCrossAccountRequestPatch() {
      return z.object({
          end_date: z.string().optional().nullable(),
          roles: z.array(z.string()).optional().nullable(),
          start_date: z.string().optional().nullable(),
          status: z
          .enum([ 'pending', 'approved', 'expired', 'cancelled', 'denied' ])
          .optional()
          .nullable()
      });
  }

  function zodSchemaCrossAccountRequestUpdateIn() {
      return z.object({
          end_date: z.string(),
          roles: z.array(z.string()),
          start_date: z.string(),
          status: z
          .enum([ 'pending', 'approved', 'expired', 'cancelled', 'denied' ])
          .optional()
          .nullable()
      });
  }

  function zodSchemaCrossAccountRequestWithRoles() {
      return z.object({
          created: z.string().optional().nullable(),
          end_date: z.string().optional().nullable(),
          request_id: z.string().optional().nullable(),
          roles: z
          .array(
              z.object({
                  description: z.string().optional().nullable(),
                  display_name: z.string().optional().nullable(),
                  permissions: z.array(zodSchemaPermission()).optional().nullable()
              })
          )
          .optional()
          .nullable(),
          start_date: z.string().optional().nullable(),
          status: z.string().optional().nullable(),
          target_account: z.string().optional().nullable()
      });
  }

  function zodSchemaError() {
      return z.object({
          errors: z.array(
              z.object({
                  detail: z.string().optional().nullable(),
                  status: z.string().optional().nullable()
              })
          )
      });
  }

  function zodSchemaError403() {
      return z.object({
          errors: z.array(
              z.object({
                  detail: z.string().optional().nullable(),
                  source: z.string().optional().nullable(),
                  status: z.string().optional().nullable()
              })
          )
      });
  }

  function zodSchemaGroup() {
      return z.object({
          description: z.string().optional().nullable(),
          name: z.string()
      });
  }

  function zodSchemaGroupOut() {
      return z.intersection(
          zodSchemaGroup(),
          z.intersection(
              zodSchemaUUID(),
              z.intersection(
                  zodSchemaTimestamped(),
                  z.object({
                      platform_default: z.boolean().optional().nullable(),
                      principalCount: z.number().int().optional().nullable(),
                      roleCount: z.number().int().optional().nullable(),
                      system: z.boolean().optional().nullable()
                  })
              )
          )
      );
  }

  function zodSchemaGroupPagination() {
      return z.intersection(
          zodSchemaListPagination(),
          z.object({
              data: z.array(zodSchemaGroupOut())
          })
      );
  }

  function zodSchemaGroupPrincipalIn() {
      return z.object({
          principals: z.array(zodSchemaPrincipalIn())
      });
  }

  function zodSchemaGroupRoleIn() {
      return z.object({
          roles: z.array(z.string())
      });
  }

  function zodSchemaGroupRolesPagination() {
      return z.intersection(
          zodSchemaListPagination(),
          z.object({
              data: z.array(zodSchemaRoleOut())
          })
      );
  }

  function zodSchemaGroupWithPrincipals() {
      return z.intersection(
          zodSchemaGroup(),
          z.intersection(
              zodSchemaUUID(),
              z.intersection(
                  zodSchemaTimestamped(),
                  z.object({
                      principals: z.array(zodSchemaPrincipal())
                  })
              )
          )
      );
  }

  function zodSchemaGroupWithPrincipalsAndRoles() {
      return z.intersection(
          zodSchemaGroup(),
          z.intersection(
              zodSchemaUUID(),
              z.intersection(
                  zodSchemaTimestamped(),
                  z.object({
                      principals: z.array(zodSchemaPrincipal()),
                      roles: z.array(zodSchemaRoleOut())
                  })
              )
          )
      );
  }

  function zodSchemaListPagination() {
      return z.object({
          links: zodSchemaPaginationLinks().optional().nullable(),
          meta: zodSchemaPaginationMeta().optional().nullable()
      });
  }

  function zodSchemaPaginationLinks() {
      return z.object({
          first: z.string().optional().nullable(),
          last: z.string().optional().nullable(),
          next: z.string().optional().nullable(),
          previous: z.string().optional().nullable()
      });
  }

  function zodSchemaPaginationMeta() {
      return z.object({
          count: z.number().int().optional().nullable()
      });
  }

  function zodSchemaPermission() {
      return z.object({
          application: z.string().optional().nullable(),
          description: z.string().optional().nullable(),
          permission: z.string().optional().nullable(),
          resource_type: z.string().optional().nullable(),
          verb: z.string().optional().nullable()
      });
  }

  function zodSchemaPermissionOptionsPagination() {
      return z.intersection(
          zodSchemaListPagination(),
          z.object({
              data: z.array(z.string())
          })
      );
  }

  function zodSchemaPermissionPagination() {
      return z.intersection(
          zodSchemaListPagination(),
          z.object({
              data: z.array(zodSchemaPermission())
          })
      );
  }

  function zodSchemaPolicy() {
      return z.object({
          description: z.string().optional().nullable(),
          name: z.string()
      });
  }

  function zodSchemaPolicyExtended() {
      return z.intersection(
          zodSchemaPolicy(),
          z.intersection(
              zodSchemaUUID(),
              z.intersection(
                  zodSchemaTimestamped(),
                  z.object({
                      group: zodSchemaGroupOut(),
                      roles: z.array(zodSchemaRoleOut())
                  })
              )
          )
      );
  }

  function zodSchemaPolicyIn() {
      return z.intersection(
          zodSchemaPolicy(),
          z.object({
              group: z.string(),
              roles: z.array(z.string())
          })
      );
  }

  function zodSchemaPolicyPagination() {
      return z.intersection(
          zodSchemaListPagination(),
          z.object({
              data: z.array(zodSchemaPolicyExtended())
          })
      );
  }

  function zodSchemaPrincipal() {
      return z.object({
          email: z.string(),
          first_name: z.string().optional().nullable(),
          is_active: z.boolean().optional().nullable(),
          is_org_admin: z.boolean().optional().nullable(),
          last_name: z.string().optional().nullable(),
          username: z.string()
      });
  }

  function zodSchemaPrincipalIn() {
      return z.object({
          username: z.string()
      });
  }

  function zodSchemaPrincipalOut() {
      return z.intersection(zodSchemaPrincipal(), zodSchemaUUID());
  }

  function zodSchemaPrincipalPagination() {
      return z.intersection(
          zodSchemaListPagination(),
          z.object({
              data: z.array(zodSchemaPrincipal())
          })
      );
  }

  function zodSchemaResourceDefinition() {
      return z.object({
          attributeFilter: zodSchemaResourceDefinitionFilter()
      });
  }

  function zodSchemaResourceDefinitionFilter() {
      return z.object({
          key: z.string(),
          operation: z.enum([ 'equal', 'in' ]),
          value: z.string()
      });
  }

  function zodSchemaRole() {
      return z.object({
          description: z.string().optional().nullable(),
          display_name: z.string().optional().nullable(),
          name: z.string()
      });
  }

  function zodSchemaRoleIn() {
      return z.intersection(
          zodSchemaRole(),
          z.object({
              access: z.array(zodSchemaAccess())
          })
      );
  }

  function zodSchemaRoleOut() {
      return z.intersection(
          zodSchemaRole(),
          z.intersection(
              zodSchemaUUID(),
              z.intersection(
                  zodSchemaTimestamped(),
                  z.object({
                      accessCount: z.number().int().optional().nullable(),
                      applications: z.array(z.string()).optional().nullable(),
                      platform_default: z.boolean().optional().nullable(),
                      policyCount: z.number().int().optional().nullable(),
                      system: z.boolean().optional().nullable()
                  })
              )
          )
      );
  }

  function zodSchemaRoleOutDynamic() {
      return z.intersection(
          zodSchemaRole(),
          z.intersection(
              zodSchemaUUID(),
              z.intersection(
                  zodSchemaTimestamped(),
                  z.object({
                      accessCount: z.number().int(),
                      applications: z.array(z.string()),
                      groups_in: z
                      .array(zodSchemaAdditionalGroup())
                      .optional()
                      .nullable(),
                      groups_in_count: z.number().int().optional().nullable(),
                      platform_default: z.boolean(),
                      policyCount: z.number().int(),
                      system: z.boolean()
                  })
              )
          )
      );
  }

  function zodSchemaRolePagination() {
      return z.intersection(
          zodSchemaListPagination(),
          z.object({
              data: z.array(zodSchemaRoleOut())
          })
      );
  }

  function zodSchemaRolePaginationDynamic() {
      return z.intersection(
          zodSchemaListPagination(),
          z.object({
              data: z.array(zodSchemaRoleOutDynamic())
          })
      );
  }

  function zodSchemaRolePatch() {
      return z.object({
          description: z.string().optional().nullable(),
          display_name: z.string().optional().nullable(),
          name: z.string().optional().nullable()
      });
  }

  function zodSchemaRoleWithAccess() {
      return z.intersection(
          zodSchemaRoleOut(),
          z.object({
              access: z.array(zodSchemaAccess())
          })
      );
  }

  function zodSchemaStatus() {
      return z.object({
          api_version: z.number().int(),
          commit: z.string().optional().nullable()
      });
  }

  function zodSchemaTimestamped() {
      return z.object({
          created: z.string(),
          modified: z.string()
      });
  }

  function zodSchemaUUID() {
      return z.object({
          uuid: z.string()
      });
  }

  function zodSchema__Empty() {
      return z.string().max(0).optional();
  }
}

export namespace Operations {
  // GET /access/
  // Get the permitted access for a principal in the tenant (defaults to principal from the identity header)
  export namespace GetPrincipalAccess {
    const Application = z.string();
    type Application = z.infer<typeof Application>;
    const Username = z.string();
    type Username = z.infer<typeof Username>;
    const OrderBy = z.enum([ 'application', 'resource_type', 'verb' ]);
    type OrderBy = z.infer<typeof OrderBy>;
    const Limit = z.number().int();
    type Limit = z.infer<typeof Limit>;
    const Offset = z.number().int();
    type Offset = z.infer<typeof Offset>;
    export interface Params {
      application: Application;
      username?: Username;
      orderBy?: OrderBy;
      limit?: Limit;
      offset?: Offset;
    }

    export type Payload =
      | ValidatedResponse<'AccessPagination', 200, Schemas.AccessPagination>
      | ValidatedResponse<'__Empty', 401, Schemas.__Empty>
      | ValidatedResponse<'Error', 404, Schemas.Error>
      | ValidatedResponse<'Error', 500, Schemas.Error>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/access/';
        const query = {} as Record<string, any>;
        if (params.application !== undefined) {
            query.application = params.application;
        }

        if (params.username !== undefined) {
            query.username = params.username;
        }

        if (params.orderBy !== undefined) {
            query.order_by = params.orderBy;
        }

        if (params.limit !== undefined) {
            query.limit = params.limit;
        }

        if (params.offset !== undefined) {
            query.offset = params.offset;
        }

        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Schemas.AccessPagination, 'AccessPagination', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.Error, 'Error', 404),
                new ValidateRule(Schemas.Error, 'Error', 500)
            ]
        })
        .build();
    };
  }
  // GET /cross-account-requests/
  // List the cross account requests for a user or account
  export namespace ListCrossAccountRequests {
    const Limit = z.number().int();
    type Limit = z.infer<typeof Limit>;
    const Offset = z.number().int();
    type Offset = z.infer<typeof Offset>;
    const QueryBy = z.enum([ 'user_id', 'target_account' ]);
    type QueryBy = z.infer<typeof QueryBy>;
    const Account = z.string();
    type Account = z.infer<typeof Account>;
    const ApprovedOnly = z.enum([ 'true' ]);
    type ApprovedOnly = z.infer<typeof ApprovedOnly>;
    const Status = z.enum([
        'pending',
        'approved',
        'denied',
        'cancelled',
        'expired'
    ]);
    type Status = z.infer<typeof Status>;
    const OrderBy = z.enum([
        'request_id',
        'start_date',
        'end_date',
        'created',
        'modified',
        'status'
    ]);
    type OrderBy = z.infer<typeof OrderBy>;
    export interface Params {
      limit?: Limit;
      offset?: Offset;
      queryBy?: QueryBy;
      account?: Account;
      approvedOnly?: ApprovedOnly;
      status?: Status;
      orderBy?: OrderBy;
    }

    export type Payload =
      | ValidatedResponse<
          'CrossAccountRequestPagination',
          200,
          Schemas.CrossAccountRequestPagination
        >
      | ValidatedResponse<'__Empty', 401, Schemas.__Empty>
      | ValidatedResponse<'Error403', 403, Schemas.Error403>
      | ValidatedResponse<'Error', 500, Schemas.Error>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/cross-account-requests/';
        const query = {} as Record<string, any>;
        if (params.limit !== undefined) {
            query.limit = params.limit;
        }

        if (params.offset !== undefined) {
            query.offset = params.offset;
        }

        if (params.queryBy !== undefined) {
            query.query_by = params.queryBy;
        }

        if (params.account !== undefined) {
            query.account = params.account;
        }

        if (params.approvedOnly !== undefined) {
            query.approved_only = params.approvedOnly;
        }

        if (params.status !== undefined) {
            query.status = params.status;
        }

        if (params.orderBy !== undefined) {
            query.order_by = params.orderBy;
        }

        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(
                    Schemas.CrossAccountRequestPagination,
                    'CrossAccountRequestPagination',
                    200
                ),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.Error403, 'Error403', 403),
                new ValidateRule(Schemas.Error, 'Error', 500)
            ]
        })
        .build();
    };
  }
  // POST /cross-account-requests/
  // Create a cross account request
  export namespace CreateCrossAccountRequests {
    export interface Params {
      body: Schemas.CrossAccountRequestIn;
    }

    export type Payload =
      | ValidatedResponse<
          'CrossAccountRequestOut',
          201,
          Schemas.CrossAccountRequestOut
        >
      | ValidatedResponse<'__Empty', 401, Schemas.__Empty>
      | ValidatedResponse<'Error403', 403, Schemas.Error403>
      | ValidatedResponse<'Error', 500, Schemas.Error>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/cross-account-requests/';
        const query = {} as Record<string, any>;
        return actionBuilder('POST', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [
                new ValidateRule(
                    Schemas.CrossAccountRequestOut,
                    'CrossAccountRequestOut',
                    201
                ),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.Error403, 'Error403', 403),
                new ValidateRule(Schemas.Error, 'Error', 500)
            ]
        })
        .build();
    };
  }
  // GET /cross-account-requests/{uuid}/
  // Get a cross account request
  export namespace GetCrossAccountRequest {
    const Uuid = z.string();
    type Uuid = z.infer<typeof Uuid>;
    const QueryBy = z.enum([ 'user_id', 'target_account' ]);
    type QueryBy = z.infer<typeof QueryBy>;
    const Account = z.string();
    type Account = z.infer<typeof Account>;
    const ApprovedOnly = z.enum([ 'true' ]);
    type ApprovedOnly = z.infer<typeof ApprovedOnly>;
    export interface Params {
      uuid: Uuid;
      queryBy?: QueryBy;
      account?: Account;
      approvedOnly?: ApprovedOnly;
    }

    export type Payload =
      | ValidatedResponse<
          'CrossAccountRequestDetail',
          200,
          Schemas.CrossAccountRequestDetail
        >
      | ValidatedResponse<'__Empty', 401, Schemas.__Empty>
      | ValidatedResponse<'Error403', 403, Schemas.Error403>
      | ValidatedResponse<'Error', 404, Schemas.Error>
      | ValidatedResponse<'Error', 500, Schemas.Error>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/cross-account-requests/{uuid}/'.replace(
            '{uuid}',
            params.uuid.toString()
        );
        const query = {} as Record<string, any>;
        if (params.queryBy !== undefined) {
            query.query_by = params.queryBy;
        }

        if (params.account !== undefined) {
            query.account = params.account;
        }

        if (params.approvedOnly !== undefined) {
            query.approved_only = params.approvedOnly;
        }

        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(
                    Schemas.CrossAccountRequestDetail,
                    'CrossAccountRequestDetail',
                    200
                ),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.Error403, 'Error403', 403),
                new ValidateRule(Schemas.Error, 'Error', 404),
                new ValidateRule(Schemas.Error, 'Error', 500)
            ]
        })
        .build();
    };
  }
  // PUT /cross-account-requests/{uuid}/
  // Update a cross account request
  export namespace PutCrossAccountRequest {
    const Uuid = z.string();
    type Uuid = z.infer<typeof Uuid>;
    export interface Params {
      uuid: Uuid;
      body: Schemas.CrossAccountRequestUpdateIn;
    }

    export type Payload =
      | ValidatedResponse<
          'CrossAccountRequestDetail',
          200,
          Schemas.CrossAccountRequestDetail
        >
      | ValidatedResponse<
          'CrossAccountRequestOut',
          201,
          Schemas.CrossAccountRequestOut
        >
      | ValidatedResponse<'__Empty', 401, Schemas.__Empty>
      | ValidatedResponse<'Error403', 403, Schemas.Error403>
      | ValidatedResponse<'Error', 404, Schemas.Error>
      | ValidatedResponse<'Error', 500, Schemas.Error>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/cross-account-requests/{uuid}/'.replace(
            '{uuid}',
            params.uuid.toString()
        );
        const query = {} as Record<string, any>;
        return actionBuilder('PUT', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [
                new ValidateRule(
                    Schemas.CrossAccountRequestDetail,
                    'CrossAccountRequestDetail',
                    200
                ),
                new ValidateRule(
                    Schemas.CrossAccountRequestOut,
                    'CrossAccountRequestOut',
                    201
                ),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.Error403, 'Error403', 403),
                new ValidateRule(Schemas.Error, 'Error', 404),
                new ValidateRule(Schemas.Error, 'Error', 500)
            ]
        })
        .build();
    };
  }
  // GET /groups/
  // List the groups for a tenant
  export namespace ListGroups {
    const Limit = z.number().int();
    type Limit = z.infer<typeof Limit>;
    const Offset = z.number().int();
    type Offset = z.infer<typeof Offset>;
    const Name = z.string();
    type Name = z.infer<typeof Name>;
    const NameMatch = z.enum([ 'partial', 'exact' ]);
    type NameMatch = z.infer<typeof NameMatch>;
    const Scope = z.enum([ 'account', 'principal' ]);
    type Scope = z.infer<typeof Scope>;
    const Username = z.string();
    type Username = z.infer<typeof Username>;
    const Uuid = z.array(z.string());
    type Uuid = z.infer<typeof Uuid>;
    const RoleNames = z.array(z.string());
    type RoleNames = z.infer<typeof RoleNames>;
    const RoleDiscriminator = z.enum([ 'all', 'any' ]);
    type RoleDiscriminator = z.infer<typeof RoleDiscriminator>;
    const OrderBy = z.enum([
        'name',
        'modified',
        'principalCount',
        'policyCount'
    ]);
    type OrderBy = z.infer<typeof OrderBy>;
    const PlatformDefault = z.boolean();
    type PlatformDefault = z.infer<typeof PlatformDefault>;
    const System = z.boolean();
    type System = z.infer<typeof System>;
    export interface Params {
      limit?: Limit;
      offset?: Offset;
      name?: Name;
      nameMatch?: NameMatch;
      scope?: Scope;
      username?: Username;
      uuid?: Uuid;
      roleNames?: RoleNames;
      roleDiscriminator?: RoleDiscriminator;
      orderBy?: OrderBy;
      platformDefault?: PlatformDefault;
      system?: System;
    }

    export type Payload =
      | ValidatedResponse<'GroupPagination', 200, Schemas.GroupPagination>
      | ValidatedResponse<'__Empty', 401, Schemas.__Empty>
      | ValidatedResponse<'Error403', 403, Schemas.Error403>
      | ValidatedResponse<'Error', 500, Schemas.Error>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/groups/';
        const query = {} as Record<string, any>;
        if (params.limit !== undefined) {
            query.limit = params.limit;
        }

        if (params.offset !== undefined) {
            query.offset = params.offset;
        }

        if (params.name !== undefined) {
            query.name = params.name;
        }

        if (params.nameMatch !== undefined) {
            query.name_match = params.nameMatch;
        }

        if (params.scope !== undefined) {
            query.scope = params.scope;
        }

        if (params.username !== undefined) {
            query.username = params.username;
        }

        if (params.uuid !== undefined) {
            query.uuid = params.uuid;
        }

        if (params.roleNames !== undefined) {
            query.role_names = params.roleNames;
        }

        if (params.roleDiscriminator !== undefined) {
            query.role_discriminator = params.roleDiscriminator;
        }

        if (params.orderBy !== undefined) {
            query.order_by = params.orderBy;
        }

        if (params.platformDefault !== undefined) {
            query.platform_default = params.platformDefault;
        }

        if (params.system !== undefined) {
            query.system = params.system;
        }

        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Schemas.GroupPagination, 'GroupPagination', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.Error403, 'Error403', 403),
                new ValidateRule(Schemas.Error, 'Error', 500)
            ]
        })
        .build();
    };
  }
  // POST /groups/
  // Create a group in a tenant
  export namespace CreateGroup {
    export interface Params {
      body: Schemas.Group;
    }

    export type Payload =
      | ValidatedResponse<'GroupOut', 201, Schemas.GroupOut>
      | ValidatedResponse<'__Empty', 401, Schemas.__Empty>
      | ValidatedResponse<'Error403', 403, Schemas.Error403>
      | ValidatedResponse<'Error', 500, Schemas.Error>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/groups/';
        const query = {} as Record<string, any>;
        return actionBuilder('POST', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [
                new ValidateRule(Schemas.GroupOut, 'GroupOut', 201),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.Error403, 'Error403', 403),
                new ValidateRule(Schemas.Error, 'Error', 500)
            ]
        })
        .build();
    };
  }
  // GET /groups/{uuid}/
  // Get a group in the tenant
  export namespace GetGroup {
    const Uuid = z.string();
    type Uuid = z.infer<typeof Uuid>;
    export interface Params {
      uuid: Uuid;
    }

    export type Payload =
      | ValidatedResponse<
          'GroupWithPrincipalsAndRoles',
          200,
          Schemas.GroupWithPrincipalsAndRoles
        >
      | ValidatedResponse<'__Empty', 401, Schemas.__Empty>
      | ValidatedResponse<'Error403', 403, Schemas.Error403>
      | ValidatedResponse<'Error', 404, Schemas.Error>
      | ValidatedResponse<'Error', 500, Schemas.Error>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/groups/{uuid}/'.replace(
            '{uuid}',
            params.uuid.toString()
        );
        const query = {} as Record<string, any>;
        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(
                    Schemas.GroupWithPrincipalsAndRoles,
                    'GroupWithPrincipalsAndRoles',
                    200
                ),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.Error403, 'Error403', 403),
                new ValidateRule(Schemas.Error, 'Error', 404),
                new ValidateRule(Schemas.Error, 'Error', 500)
            ]
        })
        .build();
    };
  }
  // PUT /groups/{uuid}/
  // Update a group in the tenant
  export namespace UpdateGroup {
    const Uuid = z.string();
    type Uuid = z.infer<typeof Uuid>;
    export interface Params {
      uuid: Uuid;
      body: Schemas.Group;
    }

    export type Payload =
      | ValidatedResponse<'GroupOut', 200, Schemas.GroupOut>
      | ValidatedResponse<'__Empty', 401, Schemas.__Empty>
      | ValidatedResponse<'Error403', 403, Schemas.Error403>
      | ValidatedResponse<'Error', 404, Schemas.Error>
      | ValidatedResponse<'Error', 500, Schemas.Error>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/groups/{uuid}/'.replace(
            '{uuid}',
            params.uuid.toString()
        );
        const query = {} as Record<string, any>;
        return actionBuilder('PUT', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [
                new ValidateRule(Schemas.GroupOut, 'GroupOut', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.Error403, 'Error403', 403),
                new ValidateRule(Schemas.Error, 'Error', 404),
                new ValidateRule(Schemas.Error, 'Error', 500)
            ]
        })
        .build();
    };
  }
  // DELETE /groups/{uuid}/
  // Delete a group in the tenant
  export namespace DeleteGroup {
    const Uuid = z.string();
    type Uuid = z.infer<typeof Uuid>;
    export interface Params {
      uuid: Uuid;
    }

    export type Payload =
      | ValidatedResponse<'__Empty', 204, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 401, Schemas.__Empty>
      | ValidatedResponse<'Error403', 403, Schemas.Error403>
      | ValidatedResponse<'Error', 404, Schemas.Error>
      | ValidatedResponse<'Error', 500, Schemas.Error>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/groups/{uuid}/'.replace(
            '{uuid}',
            params.uuid.toString()
        );
        const query = {} as Record<string, any>;
        return actionBuilder('DELETE', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Schemas.__Empty, '__Empty', 204),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.Error403, 'Error403', 403),
                new ValidateRule(Schemas.Error, 'Error', 404),
                new ValidateRule(Schemas.Error, 'Error', 500)
            ]
        })
        .build();
    };
  }
  // GET /groups/{uuid}/principals/
  // Get a list of principals from a group in the tenant
  export namespace GetPrincipalsFromGroup {
    const Uuid = z.string();
    type Uuid = z.infer<typeof Uuid>;
    const PrincipalUsername = z.string();
    type PrincipalUsername = z.infer<typeof PrincipalUsername>;
    const Limit = z.number().int();
    type Limit = z.infer<typeof Limit>;
    const Offset = z.number().int();
    type Offset = z.infer<typeof Offset>;
    const OrderBy = z.enum([ 'username' ]);
    type OrderBy = z.infer<typeof OrderBy>;
    export interface Params {
      uuid: Uuid;
      principalUsername?: PrincipalUsername;
      limit?: Limit;
      offset?: Offset;
      orderBy?: OrderBy;
    }

    export type Payload =
      | ValidatedResponse<
          'PrincipalPagination',
          200,
          Schemas.PrincipalPagination
        >
      | ValidatedResponse<'__Empty', 400, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 401, Schemas.__Empty>
      | ValidatedResponse<'Error', 404, Schemas.Error>
      | ValidatedResponse<'Error', 500, Schemas.Error>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/groups/{uuid}/principals/'.replace(
            '{uuid}',
            params.uuid.toString()
        );
        const query = {} as Record<string, any>;
        if (params.principalUsername !== undefined) {
            query.principal_username = params.principalUsername;
        }

        if (params.limit !== undefined) {
            query.limit = params.limit;
        }

        if (params.offset !== undefined) {
            query.offset = params.offset;
        }

        if (params.orderBy !== undefined) {
            query.order_by = params.orderBy;
        }

        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(
                    Schemas.PrincipalPagination,
                    'PrincipalPagination',
                    200
                ),
                new ValidateRule(Schemas.__Empty, '__Empty', 400),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.Error, 'Error', 404),
                new ValidateRule(Schemas.Error, 'Error', 500)
            ]
        })
        .build();
    };
  }
  // POST /groups/{uuid}/principals/
  // Add a principal to a group in the tenant
  export namespace AddPrincipalToGroup {
    const Uuid = z.string();
    type Uuid = z.infer<typeof Uuid>;
    export interface Params {
      uuid: Uuid;
      body: Schemas.GroupPrincipalIn;
    }

    export type Payload =
      | ValidatedResponse<
          'GroupWithPrincipalsAndRoles',
          200,
          Schemas.GroupWithPrincipalsAndRoles
        >
      | ValidatedResponse<'__Empty', 400, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 401, Schemas.__Empty>
      | ValidatedResponse<'Error403', 403, Schemas.Error403>
      | ValidatedResponse<'Error', 404, Schemas.Error>
      | ValidatedResponse<'Error', 500, Schemas.Error>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/groups/{uuid}/principals/'.replace(
            '{uuid}',
            params.uuid.toString()
        );
        const query = {} as Record<string, any>;
        return actionBuilder('POST', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [
                new ValidateRule(
                    Schemas.GroupWithPrincipalsAndRoles,
                    'GroupWithPrincipalsAndRoles',
                    200
                ),
                new ValidateRule(Schemas.__Empty, '__Empty', 400),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.Error403, 'Error403', 403),
                new ValidateRule(Schemas.Error, 'Error', 404),
                new ValidateRule(Schemas.Error, 'Error', 500)
            ]
        })
        .build();
    };
  }
  // DELETE /groups/{uuid}/principals/
  // Remove a principal from a group in the tenant
  export namespace DeletePrincipalFromGroup {
    const Uuid = z.string();
    type Uuid = z.infer<typeof Uuid>;
    const Usernames = z.string();
    type Usernames = z.infer<typeof Usernames>;
    export interface Params {
      uuid: Uuid;
      usernames: Usernames;
    }

    export type Payload =
      | ValidatedResponse<'__Empty', 204, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 400, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 401, Schemas.__Empty>
      | ValidatedResponse<'Error403', 403, Schemas.Error403>
      | ValidatedResponse<'Error', 404, Schemas.Error>
      | ValidatedResponse<'Error', 500, Schemas.Error>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/groups/{uuid}/principals/'.replace(
            '{uuid}',
            params.uuid.toString()
        );
        const query = {} as Record<string, any>;
        if (params.usernames !== undefined) {
            query.usernames = params.usernames;
        }

        return actionBuilder('DELETE', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Schemas.__Empty, '__Empty', 204),
                new ValidateRule(Schemas.__Empty, '__Empty', 400),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.Error403, 'Error403', 403),
                new ValidateRule(Schemas.Error, 'Error', 404),
                new ValidateRule(Schemas.Error, 'Error', 500)
            ]
        })
        .build();
    };
  }
  // GET /groups/{uuid}/roles/
  // List the roles for a group in the tenant
  export namespace ListRolesForGroup {
    const Uuid = z.string();
    type Uuid = z.infer<typeof Uuid>;
    const Exclude = z.boolean();
    type Exclude = z.infer<typeof Exclude>;
    const RoleName = z.string();
    type RoleName = z.infer<typeof RoleName>;
    const RoleDisplayName = z.string();
    type RoleDisplayName = z.infer<typeof RoleDisplayName>;
    const RoleDescription = z.string();
    type RoleDescription = z.infer<typeof RoleDescription>;
    const RoleSystem = z.boolean();
    type RoleSystem = z.infer<typeof RoleSystem>;
    const Limit = z.number().int();
    type Limit = z.infer<typeof Limit>;
    const Offset = z.number().int();
    type Offset = z.infer<typeof Offset>;
    const OrderBy = z.enum([ 'name', 'display_name', 'modified', 'policyCount' ]);
    type OrderBy = z.infer<typeof OrderBy>;
    export interface Params {
      uuid: Uuid;
      exclude?: Exclude;
      roleName?: RoleName;
      roleDisplayName?: RoleDisplayName;
      roleDescription?: RoleDescription;
      roleSystem?: RoleSystem;
      limit?: Limit;
      offset?: Offset;
      orderBy?: OrderBy;
    }

    export type Payload =
      | ValidatedResponse<
          'GroupRolesPagination',
          200,
          Schemas.GroupRolesPagination
        >
      | ValidatedResponse<'__Empty', 401, Schemas.__Empty>
      | ValidatedResponse<'Error403', 403, Schemas.Error403>
      | ValidatedResponse<'Error', 500, Schemas.Error>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/groups/{uuid}/roles/'.replace(
            '{uuid}',
            params.uuid.toString()
        );
        const query = {} as Record<string, any>;
        if (params.exclude !== undefined) {
            query.exclude = params.exclude;
        }

        if (params.roleName !== undefined) {
            query.role_name = params.roleName;
        }

        if (params.roleDisplayName !== undefined) {
            query.role_display_name = params.roleDisplayName;
        }

        if (params.roleDescription !== undefined) {
            query.role_description = params.roleDescription;
        }

        if (params.roleSystem !== undefined) {
            query.role_system = params.roleSystem;
        }

        if (params.limit !== undefined) {
            query.limit = params.limit;
        }

        if (params.offset !== undefined) {
            query.offset = params.offset;
        }

        if (params.orderBy !== undefined) {
            query.order_by = params.orderBy;
        }

        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(
                    Schemas.GroupRolesPagination,
                    'GroupRolesPagination',
                    200
                ),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.Error403, 'Error403', 403),
                new ValidateRule(Schemas.Error, 'Error', 500)
            ]
        })
        .build();
    };
  }
  // POST /groups/{uuid}/roles/
  // Add a role to a group in the tenant
  export namespace AddRoleToGroup {
    const Uuid = z.string();
    type Uuid = z.infer<typeof Uuid>;
    const Response200 = z.object({
        data: z.array(Schemas.RoleOut)
    });
    type Response200 = z.infer<typeof Response200>;
    export interface Params {
      uuid: Uuid;
      body: Schemas.GroupRoleIn;
    }

    export type Payload =
      | ValidatedResponse<'unknown', 200, Response200>
      | ValidatedResponse<'__Empty', 400, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 401, Schemas.__Empty>
      | ValidatedResponse<'Error403', 403, Schemas.Error403>
      | ValidatedResponse<'Error', 404, Schemas.Error>
      | ValidatedResponse<'Error', 500, Schemas.Error>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/groups/{uuid}/roles/'.replace(
            '{uuid}',
            params.uuid.toString()
        );
        const query = {} as Record<string, any>;
        return actionBuilder('POST', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [
                new ValidateRule(Response200, 'unknown', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 400),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.Error403, 'Error403', 403),
                new ValidateRule(Schemas.Error, 'Error', 404),
                new ValidateRule(Schemas.Error, 'Error', 500)
            ]
        })
        .build();
    };
  }
  // DELETE /groups/{uuid}/roles/
  // Remove a role from a group in the tenant
  export namespace DeleteRoleFromGroup {
    const Uuid = z.string();
    type Uuid = z.infer<typeof Uuid>;
    const Roles = z.string();
    type Roles = z.infer<typeof Roles>;
    export interface Params {
      uuid: Uuid;
      roles: Roles;
    }

    export type Payload =
      | ValidatedResponse<'__Empty', 204, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 400, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 401, Schemas.__Empty>
      | ValidatedResponse<'Error403', 403, Schemas.Error403>
      | ValidatedResponse<'Error', 404, Schemas.Error>
      | ValidatedResponse<'Error', 500, Schemas.Error>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/groups/{uuid}/roles/'.replace(
            '{uuid}',
            params.uuid.toString()
        );
        const query = {} as Record<string, any>;
        if (params.roles !== undefined) {
            query.roles = params.roles;
        }

        return actionBuilder('DELETE', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Schemas.__Empty, '__Empty', 204),
                new ValidateRule(Schemas.__Empty, '__Empty', 400),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.Error403, 'Error403', 403),
                new ValidateRule(Schemas.Error, 'Error', 404),
                new ValidateRule(Schemas.Error, 'Error', 500)
            ]
        })
        .build();
    };
  }
  // GET /permissions/
  // List the permissions for a tenant
  export namespace ListPermissions {
    const Limit = z.number().int();
    type Limit = z.infer<typeof Limit>;
    const Offset = z.number().int();
    type Offset = z.infer<typeof Offset>;
    const OrderBy = z.enum([
        'application',
        'resource_type',
        'verb',
        'permission'
    ]);
    type OrderBy = z.infer<typeof OrderBy>;
    const Application = z.string();
    type Application = z.infer<typeof Application>;
    const ResourceType = z.string();
    type ResourceType = z.infer<typeof ResourceType>;
    const Verb = z.string();
    type Verb = z.infer<typeof Verb>;
    const Permission = z.string();
    type Permission = z.infer<typeof Permission>;
    const ExcludeGlobals = z.enum([ 'true', 'false' ]);
    type ExcludeGlobals = z.infer<typeof ExcludeGlobals>;
    const ExcludeRoles = z.string();
    type ExcludeRoles = z.infer<typeof ExcludeRoles>;
    const AllowedOnly = z.enum([ 'true', 'false' ]);
    type AllowedOnly = z.infer<typeof AllowedOnly>;
    export interface Params {
      limit?: Limit;
      offset?: Offset;
      orderBy?: OrderBy;
      application?: Application;
      resourceType?: ResourceType;
      verb?: Verb;
      permission?: Permission;
      excludeGlobals?: ExcludeGlobals;
      excludeRoles?: ExcludeRoles;
      allowedOnly?: AllowedOnly;
    }

    export type Payload =
      | ValidatedResponse<
          'PermissionPagination',
          200,
          Schemas.PermissionPagination
        >
      | ValidatedResponse<'__Empty', 401, Schemas.__Empty>
      | ValidatedResponse<'Error403', 403, Schemas.Error403>
      | ValidatedResponse<'Error', 500, Schemas.Error>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/permissions/';
        const query = {} as Record<string, any>;
        if (params.limit !== undefined) {
            query.limit = params.limit;
        }

        if (params.offset !== undefined) {
            query.offset = params.offset;
        }

        if (params.orderBy !== undefined) {
            query.order_by = params.orderBy;
        }

        if (params.application !== undefined) {
            query.application = params.application;
        }

        if (params.resourceType !== undefined) {
            query.resource_type = params.resourceType;
        }

        if (params.verb !== undefined) {
            query.verb = params.verb;
        }

        if (params.permission !== undefined) {
            query.permission = params.permission;
        }

        if (params.excludeGlobals !== undefined) {
            query.exclude_globals = params.excludeGlobals;
        }

        if (params.excludeRoles !== undefined) {
            query.exclude_roles = params.excludeRoles;
        }

        if (params.allowedOnly !== undefined) {
            query.allowed_only = params.allowedOnly;
        }

        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(
                    Schemas.PermissionPagination,
                    'PermissionPagination',
                    200
                ),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.Error403, 'Error403', 403),
                new ValidateRule(Schemas.Error, 'Error', 500)
            ]
        })
        .build();
    };
  }
  // GET /permissions/options/
  // List the available options for fields of permissions for a tenant
  export namespace ListPermissionOptions {
    const Limit = z.number().int();
    type Limit = z.infer<typeof Limit>;
    const Offset = z.number().int();
    type Offset = z.infer<typeof Offset>;
    const Field = z.enum([ 'application', 'resource_type', 'verb' ]);
    type Field = z.infer<typeof Field>;
    const Application = z.string();
    type Application = z.infer<typeof Application>;
    const ResourceType = z.string();
    type ResourceType = z.infer<typeof ResourceType>;
    const Verb = z.string();
    type Verb = z.infer<typeof Verb>;
    const ExcludeGlobals = z.enum([ 'true', 'false' ]);
    type ExcludeGlobals = z.infer<typeof ExcludeGlobals>;
    const AllowedOnly = z.enum([ 'true', 'false' ]);
    type AllowedOnly = z.infer<typeof AllowedOnly>;
    export interface Params {
      limit?: Limit;
      offset?: Offset;
      field: Field;
      application?: Application;
      resourceType?: ResourceType;
      verb?: Verb;
      excludeGlobals?: ExcludeGlobals;
      allowedOnly?: AllowedOnly;
    }

    export type Payload =
      | ValidatedResponse<
          'PermissionOptionsPagination',
          200,
          Schemas.PermissionOptionsPagination
        >
      | ValidatedResponse<'__Empty', 401, Schemas.__Empty>
      | ValidatedResponse<'Error403', 403, Schemas.Error403>
      | ValidatedResponse<'Error', 500, Schemas.Error>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/permissions/options/';
        const query = {} as Record<string, any>;
        if (params.limit !== undefined) {
            query.limit = params.limit;
        }

        if (params.offset !== undefined) {
            query.offset = params.offset;
        }

        if (params.field !== undefined) {
            query.field = params.field;
        }

        if (params.application !== undefined) {
            query.application = params.application;
        }

        if (params.resourceType !== undefined) {
            query.resource_type = params.resourceType;
        }

        if (params.verb !== undefined) {
            query.verb = params.verb;
        }

        if (params.excludeGlobals !== undefined) {
            query.exclude_globals = params.excludeGlobals;
        }

        if (params.allowedOnly !== undefined) {
            query.allowed_only = params.allowedOnly;
        }

        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(
                    Schemas.PermissionOptionsPagination,
                    'PermissionOptionsPagination',
                    200
                ),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.Error403, 'Error403', 403),
                new ValidateRule(Schemas.Error, 'Error', 500)
            ]
        })
        .build();
    };
  }
  // GET /policies/
  // List the policies in the tenant
  export namespace ListPolicies {
    const Limit = z.number().int();
    type Limit = z.infer<typeof Limit>;
    const Offset = z.number().int();
    type Offset = z.infer<typeof Offset>;
    const Name = z.string();
    type Name = z.infer<typeof Name>;
    const Scope = z.enum([ 'account', 'principal' ]);
    type Scope = z.infer<typeof Scope>;
    const GroupName = z.string();
    type GroupName = z.infer<typeof GroupName>;
    const GroupUuid = z.string();
    type GroupUuid = z.infer<typeof GroupUuid>;
    const OrderBy = z.enum([ 'name', 'modified' ]);
    type OrderBy = z.infer<typeof OrderBy>;
    export interface Params {
      limit?: Limit;
      offset?: Offset;
      name?: Name;
      scope?: Scope;
      groupName?: GroupName;
      groupUuid?: GroupUuid;
      orderBy?: OrderBy;
    }

    export type Payload =
      | ValidatedResponse<'PolicyPagination', 200, Schemas.PolicyPagination>
      | ValidatedResponse<'__Empty', 401, Schemas.__Empty>
      | ValidatedResponse<'Error', 500, Schemas.Error>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/policies/';
        const query = {} as Record<string, any>;
        if (params.limit !== undefined) {
            query.limit = params.limit;
        }

        if (params.offset !== undefined) {
            query.offset = params.offset;
        }

        if (params.name !== undefined) {
            query.name = params.name;
        }

        if (params.scope !== undefined) {
            query.scope = params.scope;
        }

        if (params.groupName !== undefined) {
            query.group_name = params.groupName;
        }

        if (params.groupUuid !== undefined) {
            query.group_uuid = params.groupUuid;
        }

        if (params.orderBy !== undefined) {
            query.order_by = params.orderBy;
        }

        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Schemas.PolicyPagination, 'PolicyPagination', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.Error, 'Error', 500)
            ]
        })
        .build();
    };
  }
  // POST /policies/
  // Create a policy in a tenant
  export namespace CreatePolicies {
    export interface Params {
      body: Schemas.PolicyIn;
    }

    export type Payload =
      | ValidatedResponse<'PolicyExtended', 201, Schemas.PolicyExtended>
      | ValidatedResponse<'__Empty', 401, Schemas.__Empty>
      | ValidatedResponse<'Error', 500, Schemas.Error>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/policies/';
        const query = {} as Record<string, any>;
        return actionBuilder('POST', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [
                new ValidateRule(Schemas.PolicyExtended, 'PolicyExtended', 201),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.Error, 'Error', 500)
            ]
        })
        .build();
    };
  }
  // GET /policies/{uuid}/
  // Get a policy in the tenant
  export namespace GetPolicy {
    const Uuid = z.string();
    type Uuid = z.infer<typeof Uuid>;
    export interface Params {
      uuid: Uuid;
    }

    export type Payload =
      | ValidatedResponse<'PolicyExtended', 200, Schemas.PolicyExtended>
      | ValidatedResponse<'__Empty', 401, Schemas.__Empty>
      | ValidatedResponse<'Error', 404, Schemas.Error>
      | ValidatedResponse<'Error', 500, Schemas.Error>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/policies/{uuid}/'.replace(
            '{uuid}',
            params.uuid.toString()
        );
        const query = {} as Record<string, any>;
        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Schemas.PolicyExtended, 'PolicyExtended', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.Error, 'Error', 404),
                new ValidateRule(Schemas.Error, 'Error', 500)
            ]
        })
        .build();
    };
  }
  // PUT /policies/{uuid}/
  // Update a policy in the tenant
  export namespace UpdatePolicy {
    const Uuid = z.string();
    type Uuid = z.infer<typeof Uuid>;
    export interface Params {
      uuid: Uuid;
      body: Schemas.PolicyIn;
    }

    export type Payload =
      | ValidatedResponse<'PolicyExtended', 200, Schemas.PolicyExtended>
      | ValidatedResponse<'__Empty', 401, Schemas.__Empty>
      | ValidatedResponse<'Error', 404, Schemas.Error>
      | ValidatedResponse<'Error', 500, Schemas.Error>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/policies/{uuid}/'.replace(
            '{uuid}',
            params.uuid.toString()
        );
        const query = {} as Record<string, any>;
        return actionBuilder('PUT', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [
                new ValidateRule(Schemas.PolicyExtended, 'PolicyExtended', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.Error, 'Error', 404),
                new ValidateRule(Schemas.Error, 'Error', 500)
            ]
        })
        .build();
    };
  }
  // DELETE /policies/{uuid}/
  // Delete a policy in the tenant
  export namespace DeletePolicy {
    const Uuid = z.string();
    type Uuid = z.infer<typeof Uuid>;
    export interface Params {
      uuid: Uuid;
    }

    export type Payload =
      | ValidatedResponse<'__Empty', 204, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 401, Schemas.__Empty>
      | ValidatedResponse<'Error', 404, Schemas.Error>
      | ValidatedResponse<'Error', 500, Schemas.Error>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/policies/{uuid}/'.replace(
            '{uuid}',
            params.uuid.toString()
        );
        const query = {} as Record<string, any>;
        return actionBuilder('DELETE', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Schemas.__Empty, '__Empty', 204),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.Error, 'Error', 404),
                new ValidateRule(Schemas.Error, 'Error', 500)
            ]
        })
        .build();
    };
  }
  // GET /principals/
  // List the principals for a tenant
  export namespace ListPrincipals {
    const Limit = z.number().int();
    type Limit = z.infer<typeof Limit>;
    const Offset = z.number().int();
    type Offset = z.infer<typeof Offset>;
    const MatchCriteria = z.enum([ 'partial', 'exact' ]);
    type MatchCriteria = z.infer<typeof MatchCriteria>;
    const Usernames = z.string();
    type Usernames = z.infer<typeof Usernames>;
    const SortOrder = z.enum([ 'asc', 'desc' ]);
    type SortOrder = z.infer<typeof SortOrder>;
    const Email = z.string();
    type Email = z.infer<typeof Email>;
    const Status = z.enum([ 'enabled', 'disabled', 'all' ]);
    type Status = z.infer<typeof Status>;
    const AdminOnly = z.enum([ 'true', 'false' ]);
    type AdminOnly = z.infer<typeof AdminOnly>;
    const OrderBy = z.enum([ 'username' ]);
    type OrderBy = z.infer<typeof OrderBy>;
    export interface Params {
      limit?: Limit;
      offset?: Offset;
      matchCriteria?: MatchCriteria;
      usernames?: Usernames;
      sortOrder?: SortOrder;
      email?: Email;
      status?: Status;
      adminOnly?: AdminOnly;
      orderBy?: OrderBy;
    }

    export type Payload =
      | ValidatedResponse<
          'PrincipalPagination',
          200,
          Schemas.PrincipalPagination
        >
      | ValidatedResponse<'__Empty', 401, Schemas.__Empty>
      | ValidatedResponse<'Error403', 403, Schemas.Error403>
      | ValidatedResponse<'Error', 500, Schemas.Error>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/principals/';
        const query = {} as Record<string, any>;
        if (params.limit !== undefined) {
            query.limit = params.limit;
        }

        if (params.offset !== undefined) {
            query.offset = params.offset;
        }

        if (params.matchCriteria !== undefined) {
            query.match_criteria = params.matchCriteria;
        }

        if (params.usernames !== undefined) {
            query.usernames = params.usernames;
        }

        if (params.sortOrder !== undefined) {
            query.sort_order = params.sortOrder;
        }

        if (params.email !== undefined) {
            query.email = params.email;
        }

        if (params.status !== undefined) {
            query.status = params.status;
        }

        if (params.adminOnly !== undefined) {
            query.admin_only = params.adminOnly;
        }

        if (params.orderBy !== undefined) {
            query.order_by = params.orderBy;
        }

        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(
                    Schemas.PrincipalPagination,
                    'PrincipalPagination',
                    200
                ),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.Error403, 'Error403', 403),
                new ValidateRule(Schemas.Error, 'Error', 500)
            ]
        })
        .build();
    };
  }
  // GET /roles/
  // List the roles for a tenant
  export namespace ListRoles {
    const Limit = z.number().int();
    type Limit = z.infer<typeof Limit>;
    const Offset = z.number().int();
    type Offset = z.infer<typeof Offset>;
    const Name = z.string();
    type Name = z.infer<typeof Name>;
    const System = z.boolean();
    type System = z.infer<typeof System>;
    const DisplayName = z.string();
    type DisplayName = z.infer<typeof DisplayName>;
    const NameMatch = z.enum([ 'partial', 'exact' ]);
    type NameMatch = z.infer<typeof NameMatch>;
    const Scope = z.enum([ 'account', 'principal' ]);
    type Scope = z.infer<typeof Scope>;
    const OrderBy = z.enum([ 'name', 'display_name', 'modified', 'policyCount' ]);
    type OrderBy = z.infer<typeof OrderBy>;
    const AddFields = z.array(z.enum([ 'groups_in', 'groups_in_count' ]));
    type AddFields = z.infer<typeof AddFields>;
    const Username = z.string();
    type Username = z.infer<typeof Username>;
    const Application = z.string();
    type Application = z.infer<typeof Application>;
    const Permission = z.string();
    type Permission = z.infer<typeof Permission>;
    export interface Params {
      limit?: Limit;
      offset?: Offset;
      name?: Name;
      system?: System;
      displayName?: DisplayName;
      nameMatch?: NameMatch;
      scope?: Scope;
      orderBy?: OrderBy;
      addFields?: AddFields;
      username?: Username;
      application?: Application;
      permission?: Permission;
    }

    export type Payload =
      | ValidatedResponse<
          'RolePaginationDynamic',
          200,
          Schemas.RolePaginationDynamic
        >
      | ValidatedResponse<'__Empty', 401, Schemas.__Empty>
      | ValidatedResponse<'Error403', 403, Schemas.Error403>
      | ValidatedResponse<'Error', 500, Schemas.Error>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/roles/';
        const query = {} as Record<string, any>;
        if (params.limit !== undefined) {
            query.limit = params.limit;
        }

        if (params.offset !== undefined) {
            query.offset = params.offset;
        }

        if (params.name !== undefined) {
            query.name = params.name;
        }

        if (params.system !== undefined) {
            query.system = params.system;
        }

        if (params.displayName !== undefined) {
            query.display_name = params.displayName;
        }

        if (params.nameMatch !== undefined) {
            query.name_match = params.nameMatch;
        }

        if (params.scope !== undefined) {
            query.scope = params.scope;
        }

        if (params.orderBy !== undefined) {
            query.order_by = params.orderBy;
        }

        if (params.addFields !== undefined) {
            query.add_fields = params.addFields;
        }

        if (params.username !== undefined) {
            query.username = params.username;
        }

        if (params.application !== undefined) {
            query.application = params.application;
        }

        if (params.permission !== undefined) {
            query.permission = params.permission;
        }

        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(
                    Schemas.RolePaginationDynamic,
                    'RolePaginationDynamic',
                    200
                ),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.Error403, 'Error403', 403),
                new ValidateRule(Schemas.Error, 'Error', 500)
            ]
        })
        .build();
    };
  }
  // POST /roles/
  // Create a roles for a tenant
  export namespace CreateRoles {
    export interface Params {
      body: Schemas.RoleIn;
    }

    export type Payload =
      | ValidatedResponse<'RoleWithAccess', 201, Schemas.RoleWithAccess>
      | ValidatedResponse<'__Empty', 401, Schemas.__Empty>
      | ValidatedResponse<'Error403', 403, Schemas.Error403>
      | ValidatedResponse<'Error', 500, Schemas.Error>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/roles/';
        const query = {} as Record<string, any>;
        return actionBuilder('POST', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [
                new ValidateRule(Schemas.RoleWithAccess, 'RoleWithAccess', 201),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.Error403, 'Error403', 403),
                new ValidateRule(Schemas.Error, 'Error', 500)
            ]
        })
        .build();
    };
  }
  // GET /roles/{uuid}/
  // Get a role in the tenant
  export namespace GetRole {
    const Uuid = z.string();
    type Uuid = z.infer<typeof Uuid>;
    const Scope = z.enum([ 'account', 'principal' ]);
    type Scope = z.infer<typeof Scope>;
    export interface Params {
      uuid: Uuid;
      scope?: Scope;
    }

    export type Payload =
      | ValidatedResponse<'RoleWithAccess', 200, Schemas.RoleWithAccess>
      | ValidatedResponse<'__Empty', 401, Schemas.__Empty>
      | ValidatedResponse<'Error403', 403, Schemas.Error403>
      | ValidatedResponse<'Error', 404, Schemas.Error>
      | ValidatedResponse<'Error', 500, Schemas.Error>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/roles/{uuid}/'.replace(
            '{uuid}',
            params.uuid.toString()
        );
        const query = {} as Record<string, any>;
        if (params.scope !== undefined) {
            query.scope = params.scope;
        }

        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Schemas.RoleWithAccess, 'RoleWithAccess', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.Error403, 'Error403', 403),
                new ValidateRule(Schemas.Error, 'Error', 404),
                new ValidateRule(Schemas.Error, 'Error', 500)
            ]
        })
        .build();
    };
  }
  // PUT /roles/{uuid}/
  // Update a Role in the tenant
  export namespace UpdateRole {
    const Uuid = z.string();
    type Uuid = z.infer<typeof Uuid>;
    export interface Params {
      uuid: Uuid;
      body: Schemas.RoleWithAccess;
    }

    export type Payload =
      | ValidatedResponse<'__Empty', 200, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 401, Schemas.__Empty>
      | ValidatedResponse<'Error403', 403, Schemas.Error403>
      | ValidatedResponse<'Error', 404, Schemas.Error>
      | ValidatedResponse<'Error', 500, Schemas.Error>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/roles/{uuid}/'.replace(
            '{uuid}',
            params.uuid.toString()
        );
        const query = {} as Record<string, any>;
        return actionBuilder('PUT', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [
                new ValidateRule(Schemas.__Empty, '__Empty', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.Error403, 'Error403', 403),
                new ValidateRule(Schemas.Error, 'Error', 404),
                new ValidateRule(Schemas.Error, 'Error', 500)
            ]
        })
        .build();
    };
  }
  // DELETE /roles/{uuid}/
  // Delete a role in the tenant
  export namespace DeleteRole {
    const Uuid = z.string();
    type Uuid = z.infer<typeof Uuid>;
    export interface Params {
      uuid: Uuid;
    }

    export type Payload =
      | ValidatedResponse<'__Empty', 204, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 401, Schemas.__Empty>
      | ValidatedResponse<'Error403', 403, Schemas.Error403>
      | ValidatedResponse<'Error', 404, Schemas.Error>
      | ValidatedResponse<'Error', 500, Schemas.Error>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/roles/{uuid}/'.replace(
            '{uuid}',
            params.uuid.toString()
        );
        const query = {} as Record<string, any>;
        return actionBuilder('DELETE', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Schemas.__Empty, '__Empty', 204),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.Error403, 'Error403', 403),
                new ValidateRule(Schemas.Error, 'Error', 404),
                new ValidateRule(Schemas.Error, 'Error', 500)
            ]
        })
        .build();
    };
  }
  // GET /roles/{uuid}/access/
  // Get access for a role in the tenant
  export namespace GetRoleAccess {
    const Uuid = z.string();
    type Uuid = z.infer<typeof Uuid>;
    const Limit = z.number().int();
    type Limit = z.infer<typeof Limit>;
    const Offset = z.number().int();
    type Offset = z.infer<typeof Offset>;
    export interface Params {
      uuid: Uuid;
      limit?: Limit;
      offset?: Offset;
    }

    export type Payload =
      | ValidatedResponse<'AccessPagination', 200, Schemas.AccessPagination>
      | ValidatedResponse<'__Empty', 401, Schemas.__Empty>
      | ValidatedResponse<'Error403', 403, Schemas.Error403>
      | ValidatedResponse<'Error', 404, Schemas.Error>
      | ValidatedResponse<'Error', 500, Schemas.Error>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/roles/{uuid}/access/'.replace(
            '{uuid}',
            params.uuid.toString()
        );
        const query = {} as Record<string, any>;
        if (params.limit !== undefined) {
            query.limit = params.limit;
        }

        if (params.offset !== undefined) {
            query.offset = params.offset;
        }

        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Schemas.AccessPagination, 'AccessPagination', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.Error403, 'Error403', 403),
                new ValidateRule(Schemas.Error, 'Error', 404),
                new ValidateRule(Schemas.Error, 'Error', 500)
            ]
        })
        .build();
    };
  }
  // GET /status/
  // Obtain server status
  export namespace GetStatus {
    export type Payload =
      | ValidatedResponse<'Status', 200, Schemas.Status>
      | ValidatedResponse<'Error', 500, Schemas.Error>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (): ActionCreator => {
        const path = '/status/';
        const query = {} as Record<string, any>;
        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Schemas.Status, 'Status', 200),
                new ValidateRule(Schemas.Error, 'Error', 500)
            ]
        })
        .build();
    };
  }
}
"
`;

exports[`src/cli/schema execute for ./tests/__fixtures__/rbac-openapi.json execute input file accepts path: compiled 1`] = `
"\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.Operations = exports.Schemas = void 0;
/* eslint-disable */
/**
 * Generated code, DO NOT modify directly.
 */
var z = require(\\"zod\\");
var openapi2typescript_1 = require(\\"openapi2typescript\\");
var react_fetching_library_1 = require(\\"openapi2typescript/react-fetching-library\\");
var Schemas;
(function (Schemas) {
    Schemas.Access = zodSchemaAccess();
    Schemas.AccessPagination = zodSchemaAccessPagination();
    Schemas.AdditionalGroup = zodSchemaAdditionalGroup();
    Schemas.CrossAccountRequest = zodSchemaCrossAccountRequest();
    Schemas.CrossAccountRequestByAccount = zodSchemaCrossAccountRequestByAccount();
    Schemas.CrossAccountRequestByUserId = zodSchemaCrossAccountRequestByUserId();
    Schemas.CrossAccountRequestDetail = zodSchemaCrossAccountRequestDetail();
    Schemas.CrossAccountRequestDetailByAccount = zodSchemaCrossAccountRequestDetailByAccount();
    Schemas.CrossAccountRequestDetailByUseId = zodSchemaCrossAccountRequestDetailByUseId();
    Schemas.CrossAccountRequestIn = zodSchemaCrossAccountRequestIn();
    Schemas.CrossAccountRequestOut = zodSchemaCrossAccountRequestOut();
    Schemas.CrossAccountRequestPagination = zodSchemaCrossAccountRequestPagination();
    Schemas.CrossAccountRequestPatch = zodSchemaCrossAccountRequestPatch();
    Schemas.CrossAccountRequestUpdateIn = zodSchemaCrossAccountRequestUpdateIn();
    Schemas.CrossAccountRequestWithRoles = zodSchemaCrossAccountRequestWithRoles();
    Schemas.Error = zodSchemaError();
    Schemas.Error403 = zodSchemaError403();
    Schemas.Group = zodSchemaGroup();
    Schemas.GroupOut = zodSchemaGroupOut();
    Schemas.GroupPagination = zodSchemaGroupPagination();
    Schemas.GroupPrincipalIn = zodSchemaGroupPrincipalIn();
    Schemas.GroupRoleIn = zodSchemaGroupRoleIn();
    Schemas.GroupRolesPagination = zodSchemaGroupRolesPagination();
    Schemas.GroupWithPrincipals = zodSchemaGroupWithPrincipals();
    Schemas.GroupWithPrincipalsAndRoles = zodSchemaGroupWithPrincipalsAndRoles();
    Schemas.ListPagination = zodSchemaListPagination();
    Schemas.PaginationLinks = zodSchemaPaginationLinks();
    Schemas.PaginationMeta = zodSchemaPaginationMeta();
    Schemas.Permission = zodSchemaPermission();
    Schemas.PermissionOptionsPagination = zodSchemaPermissionOptionsPagination();
    Schemas.PermissionPagination = zodSchemaPermissionPagination();
    Schemas.Policy = zodSchemaPolicy();
    Schemas.PolicyExtended = zodSchemaPolicyExtended();
    Schemas.PolicyIn = zodSchemaPolicyIn();
    Schemas.PolicyPagination = zodSchemaPolicyPagination();
    Schemas.Principal = zodSchemaPrincipal();
    Schemas.PrincipalIn = zodSchemaPrincipalIn();
    Schemas.PrincipalOut = zodSchemaPrincipalOut();
    Schemas.PrincipalPagination = zodSchemaPrincipalPagination();
    Schemas.ResourceDefinition = zodSchemaResourceDefinition();
    Schemas.ResourceDefinitionFilter = zodSchemaResourceDefinitionFilter();
    Schemas.Role = zodSchemaRole();
    Schemas.RoleIn = zodSchemaRoleIn();
    Schemas.RoleOut = zodSchemaRoleOut();
    Schemas.RoleOutDynamic = zodSchemaRoleOutDynamic();
    Schemas.RolePagination = zodSchemaRolePagination();
    Schemas.RolePaginationDynamic = zodSchemaRolePaginationDynamic();
    Schemas.RolePatch = zodSchemaRolePatch();
    Schemas.RoleWithAccess = zodSchemaRoleWithAccess();
    Schemas.Status = zodSchemaStatus();
    Schemas.Timestamped = zodSchemaTimestamped();
    Schemas.UUID = zodSchemaUUID();
    Schemas.__Empty = zodSchema__Empty();
    function zodSchemaAccess() {
        return z.object({
            permission: z.string(),
            resourceDefinitions: z.array(zodSchemaResourceDefinition())
        });
    }
    function zodSchemaAccessPagination() {
        return z.intersection(zodSchemaListPagination(), z.object({
            data: z.array(zodSchemaAccess())
        }));
    }
    function zodSchemaAdditionalGroup() {
        return z.object({
            description: z.string().optional().nullable(),
            name: z.string().optional().nullable(),
            uuid: z.string().optional().nullable()
        });
    }
    function zodSchemaCrossAccountRequest() {
        return z.object({
            created: z.string().optional().nullable(),
            end_date: z.unknown().optional().nullable(),
            request_id: z.string().optional().nullable(),
            start_date: z.unknown().optional().nullable(),
            status: z.string().optional().nullable(),
            target_account: z.string().optional().nullable()
        });
    }
    function zodSchemaCrossAccountRequestByAccount() {
        return z.intersection(zodSchemaCrossAccountRequest(), z.object({
            email: z.string().optional().nullable(),
            first_name: z.string().optional().nullable(),
            last_name: z.string().optional().nullable()
        }));
    }
    function zodSchemaCrossAccountRequestByUserId() {
        return z.intersection(zodSchemaCrossAccountRequest(), z.object({
            user_id: z.string().optional().nullable()
        }));
    }
    function zodSchemaCrossAccountRequestDetail() {
        return z.union([
            zodSchemaCrossAccountRequestDetailByAccount(),
            zodSchemaCrossAccountRequestDetailByUseId()
        ]);
    }
    function zodSchemaCrossAccountRequestDetailByAccount() {
        return z.intersection(zodSchemaCrossAccountRequestWithRoles(), z.object({
            email: z.unknown().optional().nullable(),
            first_name: z.unknown().optional().nullable(),
            last_name: z.unknown().optional().nullable()
        }));
    }
    function zodSchemaCrossAccountRequestDetailByUseId() {
        return z.intersection(zodSchemaCrossAccountRequestWithRoles(), z.object({
            user_id: z.unknown().optional().nullable()
        }));
    }
    function zodSchemaCrossAccountRequestIn() {
        return z.object({
            end_date: z.string(),
            roles: z.array(z.string()),
            start_date: z.string(),
            target_account: z.string()
        });
    }
    function zodSchemaCrossAccountRequestOut() {
        return z.intersection(zodSchemaCrossAccountRequestWithRoles(), z.object({
            user_id: z.string().optional().nullable()
        }));
    }
    function zodSchemaCrossAccountRequestPagination() {
        return z.intersection(zodSchemaListPagination(), z.object({
            data: z.array(z.union([
                zodSchemaCrossAccountRequestByAccount(),
                zodSchemaCrossAccountRequestByUserId()
            ]))
        }));
    }
    function zodSchemaCrossAccountRequestPatch() {
        return z.object({
            end_date: z.string().optional().nullable(),
            roles: z.array(z.string()).optional().nullable(),
            start_date: z.string().optional().nullable(),
            status: z
                .enum(['pending', 'approved', 'expired', 'cancelled', 'denied'])
                .optional()
                .nullable()
        });
    }
    function zodSchemaCrossAccountRequestUpdateIn() {
        return z.object({
            end_date: z.string(),
            roles: z.array(z.string()),
            start_date: z.string(),
            status: z
                .enum(['pending', 'approved', 'expired', 'cancelled', 'denied'])
                .optional()
                .nullable()
        });
    }
    function zodSchemaCrossAccountRequestWithRoles() {
        return z.object({
            created: z.string().optional().nullable(),
            end_date: z.string().optional().nullable(),
            request_id: z.string().optional().nullable(),
            roles: z
                .array(z.object({
                description: z.string().optional().nullable(),
                display_name: z.string().optional().nullable(),
                permissions: z.array(zodSchemaPermission()).optional().nullable()
            }))
                .optional()
                .nullable(),
            start_date: z.string().optional().nullable(),
            status: z.string().optional().nullable(),
            target_account: z.string().optional().nullable()
        });
    }
    function zodSchemaError() {
        return z.object({
            errors: z.array(z.object({
                detail: z.string().optional().nullable(),
                status: z.string().optional().nullable()
            }))
        });
    }
    function zodSchemaError403() {
        return z.object({
            errors: z.array(z.object({
                detail: z.string().optional().nullable(),
                source: z.string().optional().nullable(),
                status: z.string().optional().nullable()
            }))
        });
    }
    function zodSchemaGroup() {
        return z.object({
            description: z.string().optional().nullable(),
            name: z.string()
        });
    }
    function zodSchemaGroupOut() {
        return z.intersection(zodSchemaGroup(), z.intersection(zodSchemaUUID(), z.intersection(zodSchemaTimestamped(), z.object({
            platform_default: z.boolean().optional().nullable(),
            principalCount: z.number().int().optional().nullable(),
            roleCount: z.number().int().optional().nullable(),
            system: z.boolean().optional().nullable()
        }))));
    }
    function zodSchemaGroupPagination() {
        return z.intersection(zodSchemaListPagination(), z.object({
            data: z.array(zodSchemaGroupOut())
        }));
    }
    function zodSchemaGroupPrincipalIn() {
        return z.object({
            principals: z.array(zodSchemaPrincipalIn())
        });
    }
    function zodSchemaGroupRoleIn() {
        return z.object({
            roles: z.array(z.string())
        });
    }
    function zodSchemaGroupRolesPagination() {
        return z.intersection(zodSchemaListPagination(), z.object({
            data: z.array(zodSchemaRoleOut())
        }));
    }
    function zodSchemaGroupWithPrincipals() {
        return z.intersection(zodSchemaGroup(), z.intersection(zodSchemaUUID(), z.intersection(zodSchemaTimestamped(), z.object({
            principals: z.array(zodSchemaPrincipal())
        }))));
    }
    function zodSchemaGroupWithPrincipalsAndRoles() {
        return z.intersection(zodSchemaGroup(), z.intersection(zodSchemaUUID(), z.intersection(zodSchemaTimestamped(), z.object({
            principals: z.array(zodSchemaPrincipal()),
            roles: z.array(zodSchemaRoleOut())
        }))));
    }
    function zodSchemaListPagination() {
        return z.object({
            links: zodSchemaPaginationLinks().optional().nullable(),
            meta: zodSchemaPaginationMeta().optional().nullable()
        });
    }
    function zodSchemaPaginationLinks() {
        return z.object({
            first: z.string().optional().nullable(),
            last: z.string().optional().nullable(),
            next: z.string().optional().nullable(),
            previous: z.string().optional().nullable()
        });
    }
    function zodSchemaPaginationMeta() {
        return z.object({
            count: z.number().int().optional().nullable()
        });
    }
    function zodSchemaPermission() {
        return z.object({
            application: z.string().optional().nullable(),
            description: z.string().optional().nullable(),
            permission: z.string().optional().nullable(),
            resource_type: z.string().optional().nullable(),
            verb: z.string().optional().nullable()
        });
    }
    function zodSchemaPermissionOptionsPagination() {
        return z.intersection(zodSchemaListPagination(), z.object({
            data: z.array(z.string())
        }));
    }
    function zodSchemaPermissionPagination() {
        return z.intersection(zodSchemaListPagination(), z.object({
            data: z.array(zodSchemaPermission())
        }));
    }
    function zodSchemaPolicy() {
        return z.object({
            description: z.string().optional().nullable(),
            name: z.string()
        });
    }
    function zodSchemaPolicyExtended() {
        return z.intersection(zodSchemaPolicy(), z.intersection(zodSchemaUUID(), z.intersection(zodSchemaTimestamped(), z.object({
            group: zodSchemaGroupOut(),
            roles: z.array(zodSchemaRoleOut())
        }))));
    }
    function zodSchemaPolicyIn() {
        return z.intersection(zodSchemaPolicy(), z.object({
            group: z.string(),
            roles: z.array(z.string())
        }));
    }
    function zodSchemaPolicyPagination() {
        return z.intersection(zodSchemaListPagination(), z.object({
            data: z.array(zodSchemaPolicyExtended())
        }));
    }
    function zodSchemaPrincipal() {
        return z.object({
            email: z.string(),
            first_name: z.string().optional().nullable(),
            is_active: z.boolean().optional().nullable(),
            is_org_admin: z.boolean().optional().nullable(),
            last_name: z.string().optional().nullable(),
            username: z.string()
        });
    }
    function zodSchemaPrincipalIn() {
        return z.object({
            username: z.string()
        });
    }
    function zodSchemaPrincipalOut() {
        return z.intersection(zodSchemaPrincipal(), zodSchemaUUID());
    }
    function zodSchemaPrincipalPagination() {
        return z.intersection(zodSchemaListPagination(), z.object({
            data: z.array(zodSchemaPrincipal())
        }));
    }
    function zodSchemaResourceDefinition() {
        return z.object({
            attributeFilter: zodSchemaResourceDefinitionFilter()
        });
    }
    function zodSchemaResourceDefinitionFilter() {
        return z.object({
            key: z.string(),
            operation: z.enum(['equal', 'in']),
            value: z.string()
        });
    }
    function zodSchemaRole() {
        return z.object({
            description: z.string().optional().nullable(),
            display_name: z.string().optional().nullable(),
            name: z.string()
        });
    }
    function zodSchemaRoleIn() {
        return z.intersection(zodSchemaRole(), z.object({
            access: z.array(zodSchemaAccess())
        }));
    }
    function zodSchemaRoleOut() {
        return z.intersection(zodSchemaRole(), z.intersection(zodSchemaUUID(), z.intersection(zodSchemaTimestamped(), z.object({
            accessCount: z.number().int().optional().nullable(),
            applications: z.array(z.string()).optional().nullable(),
            platform_default: z.boolean().optional().nullable(),
            policyCount: z.number().int().optional().nullable(),
            system: z.boolean().optional().nullable()
        }))));
    }
    function zodSchemaRoleOutDynamic() {
        return z.intersection(zodSchemaRole(), z.intersection(zodSchemaUUID(), z.intersection(zodSchemaTimestamped(), z.object({
            accessCount: z.number().int(),
            applications: z.array(z.string()),
            groups_in: z
                .array(zodSchemaAdditionalGroup())
                .optional()
                .nullable(),
            groups_in_count: z.number().int().optional().nullable(),
            platform_default: z.boolean(),
            policyCount: z.number().int(),
            system: z.boolean()
        }))));
    }
    function zodSchemaRolePagination() {
        return z.intersection(zodSchemaListPagination(), z.object({
            data: z.array(zodSchemaRoleOut())
        }));
    }
    function zodSchemaRolePaginationDynamic() {
        return z.intersection(zodSchemaListPagination(), z.object({
            data: z.array(zodSchemaRoleOutDynamic())
        }));
    }
    function zodSchemaRolePatch() {
        return z.object({
            description: z.string().optional().nullable(),
            display_name: z.string().optional().nullable(),
            name: z.string().optional().nullable()
        });
    }
    function zodSchemaRoleWithAccess() {
        return z.intersection(zodSchemaRoleOut(), z.object({
            access: z.array(zodSchemaAccess())
        }));
    }
    function zodSchemaStatus() {
        return z.object({
            api_version: z.number().int(),
            commit: z.string().optional().nullable()
        });
    }
    function zodSchemaTimestamped() {
        return z.object({
            created: z.string(),
            modified: z.string()
        });
    }
    function zodSchemaUUID() {
        return z.object({
            uuid: z.string()
        });
    }
    function zodSchema__Empty() {
        return z.string().max(0).optional();
    }
})(Schemas = exports.Schemas || (exports.Schemas = {}));
var Operations;
(function (Operations) {
    // GET /access/
    // Get the permitted access for a principal in the tenant (defaults to principal from the identity header)
    var GetPrincipalAccess;
    (function (GetPrincipalAccess) {
        var Application = z.string();
        var Username = z.string();
        var OrderBy = z.enum(['application', 'resource_type', 'verb']);
        var Limit = z.number().int();
        var Offset = z.number().int();
        /*
     Params
    'application':Application,
    'username'?:Username,
    'orderBy'?:OrderBy,
    'limit'?:Limit,
    'offset'?:Offset
    */
        GetPrincipalAccess.actionCreator = function (params) {
            var path = '/access/';
            var query = {};
            if (params.application !== undefined) {
                query.application = params.application;
            }
            if (params.username !== undefined) {
                query.username = params.username;
            }
            if (params.orderBy !== undefined) {
                query.order_by = params.orderBy;
            }
            if (params.limit !== undefined) {
                query.limit = params.limit;
            }
            if (params.offset !== undefined) {
                query.offset = params.offset;
            }
            return (0, react_fetching_library_1.actionBuilder)('GET', path)
                .queryParams(query)
                .config({
                rules: [
                    new openapi2typescript_1.ValidateRule(Schemas.AccessPagination, 'AccessPagination', 200),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 401),
                    new openapi2typescript_1.ValidateRule(Schemas.Error, 'Error', 404),
                    new openapi2typescript_1.ValidateRule(Schemas.Error, 'Error', 500)
                ]
            })
                .build();
        };
    })(GetPrincipalAccess = Operations.GetPrincipalAccess || (Operations.GetPrincipalAccess = {}));
    // GET /cross-account-requests/
    // List the cross account requests for a user or account
    var ListCrossAccountRequests;
    (function (ListCrossAccountRequests) {
        var Limit = z.number().int();
        var Offset = z.number().int();
        var QueryBy = z.enum(['user_id', 'target_account']);
        var Account = z.string();
        var ApprovedOnly = z.enum(['true']);
        var Status = z.enum([
            'pending',
            'approved',
            'denied',
            'cancelled',
            'expired'
        ]);
        var OrderBy = z.enum([
            'request_id',
            'start_date',
            'end_date',
            'created',
            'modified',
            'status'
        ]);
        /*
     Params
    'limit'?:Limit,
    'offset'?:Offset,
    'queryBy'?:QueryBy,
    'account'?:Account,
    'approvedOnly'?:ApprovedOnly,
    'status'?:Status,
    'orderBy'?:OrderBy
    */
        ListCrossAccountRequests.actionCreator = function (params) {
            var path = '/cross-account-requests/';
            var query = {};
            if (params.limit !== undefined) {
                query.limit = params.limit;
            }
            if (params.offset !== undefined) {
                query.offset = params.offset;
            }
            if (params.queryBy !== undefined) {
                query.query_by = params.queryBy;
            }
            if (params.account !== undefined) {
                query.account = params.account;
            }
            if (params.approvedOnly !== undefined) {
                query.approved_only = params.approvedOnly;
            }
            if (params.status !== undefined) {
                query.status = params.status;
            }
            if (params.orderBy !== undefined) {
                query.order_by = params.orderBy;
            }
            return (0, react_fetching_library_1.actionBuilder)('GET', path)
                .queryParams(query)
                .config({
                rules: [
                    new openapi2typescript_1.ValidateRule(Schemas.CrossAccountRequestPagination, 'CrossAccountRequestPagination', 200),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 401),
                    new openapi2typescript_1.ValidateRule(Schemas.Error403, 'Error403', 403),
                    new openapi2typescript_1.ValidateRule(Schemas.Error, 'Error', 500)
                ]
            })
                .build();
        };
    })(ListCrossAccountRequests = Operations.ListCrossAccountRequests || (Operations.ListCrossAccountRequests = {}));
    // POST /cross-account-requests/
    // Create a cross account request
    var CreateCrossAccountRequests;
    (function (CreateCrossAccountRequests) {
        /*
     Params
    body: Schemas.CrossAccountRequestIn
    */
        CreateCrossAccountRequests.actionCreator = function (params) {
            var path = '/cross-account-requests/';
            var query = {};
            return (0, react_fetching_library_1.actionBuilder)('POST', path)
                .queryParams(query)
                .data(params.body)
                .config({
                rules: [
                    new openapi2typescript_1.ValidateRule(Schemas.CrossAccountRequestOut, 'CrossAccountRequestOut', 201),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 401),
                    new openapi2typescript_1.ValidateRule(Schemas.Error403, 'Error403', 403),
                    new openapi2typescript_1.ValidateRule(Schemas.Error, 'Error', 500)
                ]
            })
                .build();
        };
    })(CreateCrossAccountRequests = Operations.CreateCrossAccountRequests || (Operations.CreateCrossAccountRequests = {}));
    // GET /cross-account-requests/{uuid}/
    // Get a cross account request
    var GetCrossAccountRequest;
    (function (GetCrossAccountRequest) {
        var Uuid = z.string();
        var QueryBy = z.enum(['user_id', 'target_account']);
        var Account = z.string();
        var ApprovedOnly = z.enum(['true']);
        /*
     Params
    'uuid':Uuid,
    'queryBy'?:QueryBy,
    'account'?:Account,
    'approvedOnly'?:ApprovedOnly
    */
        GetCrossAccountRequest.actionCreator = function (params) {
            var path = '/cross-account-requests/{uuid}/'.replace('{uuid}', params.uuid.toString());
            var query = {};
            if (params.queryBy !== undefined) {
                query.query_by = params.queryBy;
            }
            if (params.account !== undefined) {
                query.account = params.account;
            }
            if (params.approvedOnly !== undefined) {
                query.approved_only = params.approvedOnly;
            }
            return (0, react_fetching_library_1.actionBuilder)('GET', path)
                .queryParams(query)
                .config({
                rules: [
                    new openapi2typescript_1.ValidateRule(Schemas.CrossAccountRequestDetail, 'CrossAccountRequestDetail', 200),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 401),
                    new openapi2typescript_1.ValidateRule(Schemas.Error403, 'Error403', 403),
                    new openapi2typescript_1.ValidateRule(Schemas.Error, 'Error', 404),
                    new openapi2typescript_1.ValidateRule(Schemas.Error, 'Error', 500)
                ]
            })
                .build();
        };
    })(GetCrossAccountRequest = Operations.GetCrossAccountRequest || (Operations.GetCrossAccountRequest = {}));
    // PUT /cross-account-requests/{uuid}/
    // Update a cross account request
    var PutCrossAccountRequest;
    (function (PutCrossAccountRequest) {
        var Uuid = z.string();
        /*
     Params
    'uuid':Uuid,
    body: Schemas.CrossAccountRequestUpdateIn
    */
        PutCrossAccountRequest.actionCreator = function (params) {
            var path = '/cross-account-requests/{uuid}/'.replace('{uuid}', params.uuid.toString());
            var query = {};
            return (0, react_fetching_library_1.actionBuilder)('PUT', path)
                .queryParams(query)
                .data(params.body)
                .config({
                rules: [
                    new openapi2typescript_1.ValidateRule(Schemas.CrossAccountRequestDetail, 'CrossAccountRequestDetail', 200),
                    new openapi2typescript_1.ValidateRule(Schemas.CrossAccountRequestOut, 'CrossAccountRequestOut', 201),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 401),
                    new openapi2typescript_1.ValidateRule(Schemas.Error403, 'Error403', 403),
                    new openapi2typescript_1.ValidateRule(Schemas.Error, 'Error', 404),
                    new openapi2typescript_1.ValidateRule(Schemas.Error, 'Error', 500)
                ]
            })
                .build();
        };
    })(PutCrossAccountRequest = Operations.PutCrossAccountRequest || (Operations.PutCrossAccountRequest = {}));
    // GET /groups/
    // List the groups for a tenant
    var ListGroups;
    (function (ListGroups) {
        var Limit = z.number().int();
        var Offset = z.number().int();
        var Name = z.string();
        var NameMatch = z.enum(['partial', 'exact']);
        var Scope = z.enum(['account', 'principal']);
        var Username = z.string();
        var Uuid = z.array(z.string());
        var RoleNames = z.array(z.string());
        var RoleDiscriminator = z.enum(['all', 'any']);
        var OrderBy = z.enum([
            'name',
            'modified',
            'principalCount',
            'policyCount'
        ]);
        var PlatformDefault = z.boolean();
        var System = z.boolean();
        /*
     Params
    'limit'?:Limit,
    'offset'?:Offset,
    'name'?:Name,
    'nameMatch'?:NameMatch,
    'scope'?:Scope,
    'username'?:Username,
    'uuid'?:Uuid,
    'roleNames'?:RoleNames,
    'roleDiscriminator'?:RoleDiscriminator,
    'orderBy'?:OrderBy,
    'platformDefault'?:PlatformDefault,
    'system'?:System
    */
        ListGroups.actionCreator = function (params) {
            var path = '/groups/';
            var query = {};
            if (params.limit !== undefined) {
                query.limit = params.limit;
            }
            if (params.offset !== undefined) {
                query.offset = params.offset;
            }
            if (params.name !== undefined) {
                query.name = params.name;
            }
            if (params.nameMatch !== undefined) {
                query.name_match = params.nameMatch;
            }
            if (params.scope !== undefined) {
                query.scope = params.scope;
            }
            if (params.username !== undefined) {
                query.username = params.username;
            }
            if (params.uuid !== undefined) {
                query.uuid = params.uuid;
            }
            if (params.roleNames !== undefined) {
                query.role_names = params.roleNames;
            }
            if (params.roleDiscriminator !== undefined) {
                query.role_discriminator = params.roleDiscriminator;
            }
            if (params.orderBy !== undefined) {
                query.order_by = params.orderBy;
            }
            if (params.platformDefault !== undefined) {
                query.platform_default = params.platformDefault;
            }
            if (params.system !== undefined) {
                query.system = params.system;
            }
            return (0, react_fetching_library_1.actionBuilder)('GET', path)
                .queryParams(query)
                .config({
                rules: [
                    new openapi2typescript_1.ValidateRule(Schemas.GroupPagination, 'GroupPagination', 200),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 401),
                    new openapi2typescript_1.ValidateRule(Schemas.Error403, 'Error403', 403),
                    new openapi2typescript_1.ValidateRule(Schemas.Error, 'Error', 500)
                ]
            })
                .build();
        };
    })(ListGroups = Operations.ListGroups || (Operations.ListGroups = {}));
    // POST /groups/
    // Create a group in a tenant
    var CreateGroup;
    (function (CreateGroup) {
        /*
     Params
    body: Schemas.Group
    */
        CreateGroup.actionCreator = function (params) {
            var path = '/groups/';
            var query = {};
            return (0, react_fetching_library_1.actionBuilder)('POST', path)
                .queryParams(query)
                .data(params.body)
                .config({
                rules: [
                    new openapi2typescript_1.ValidateRule(Schemas.GroupOut, 'GroupOut', 201),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 401),
                    new openapi2typescript_1.ValidateRule(Schemas.Error403, 'Error403', 403),
                    new openapi2typescript_1.ValidateRule(Schemas.Error, 'Error', 500)
                ]
            })
                .build();
        };
    })(CreateGroup = Operations.CreateGroup || (Operations.CreateGroup = {}));
    // GET /groups/{uuid}/
    // Get a group in the tenant
    var GetGroup;
    (function (GetGroup) {
        var Uuid = z.string();
        /*
     Params
    'uuid':Uuid
    */
        GetGroup.actionCreator = function (params) {
            var path = '/groups/{uuid}/'.replace('{uuid}', params.uuid.toString());
            var query = {};
            return (0, react_fetching_library_1.actionBuilder)('GET', path)
                .queryParams(query)
                .config({
                rules: [
                    new openapi2typescript_1.ValidateRule(Schemas.GroupWithPrincipalsAndRoles, 'GroupWithPrincipalsAndRoles', 200),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 401),
                    new openapi2typescript_1.ValidateRule(Schemas.Error403, 'Error403', 403),
                    new openapi2typescript_1.ValidateRule(Schemas.Error, 'Error', 404),
                    new openapi2typescript_1.ValidateRule(Schemas.Error, 'Error', 500)
                ]
            })
                .build();
        };
    })(GetGroup = Operations.GetGroup || (Operations.GetGroup = {}));
    // PUT /groups/{uuid}/
    // Update a group in the tenant
    var UpdateGroup;
    (function (UpdateGroup) {
        var Uuid = z.string();
        /*
     Params
    'uuid':Uuid,
    body: Schemas.Group
    */
        UpdateGroup.actionCreator = function (params) {
            var path = '/groups/{uuid}/'.replace('{uuid}', params.uuid.toString());
            var query = {};
            return (0, react_fetching_library_1.actionBuilder)('PUT', path)
                .queryParams(query)
                .data(params.body)
                .config({
                rules: [
                    new openapi2typescript_1.ValidateRule(Schemas.GroupOut, 'GroupOut', 200),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 401),
                    new openapi2typescript_1.ValidateRule(Schemas.Error403, 'Error403', 403),
                    new openapi2typescript_1.ValidateRule(Schemas.Error, 'Error', 404),
                    new openapi2typescript_1.ValidateRule(Schemas.Error, 'Error', 500)
                ]
            })
                .build();
        };
    })(UpdateGroup = Operations.UpdateGroup || (Operations.UpdateGroup = {}));
    // DELETE /groups/{uuid}/
    // Delete a group in the tenant
    var DeleteGroup;
    (function (DeleteGroup) {
        var Uuid = z.string();
        /*
     Params
    'uuid':Uuid
    */
        DeleteGroup.actionCreator = function (params) {
            var path = '/groups/{uuid}/'.replace('{uuid}', params.uuid.toString());
            var query = {};
            return (0, react_fetching_library_1.actionBuilder)('DELETE', path)
                .queryParams(query)
                .config({
                rules: [
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 204),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 401),
                    new openapi2typescript_1.ValidateRule(Schemas.Error403, 'Error403', 403),
                    new openapi2typescript_1.ValidateRule(Schemas.Error, 'Error', 404),
                    new openapi2typescript_1.ValidateRule(Schemas.Error, 'Error', 500)
                ]
            })
                .build();
        };
    })(DeleteGroup = Operations.DeleteGroup || (Operations.DeleteGroup = {}));
    // GET /groups/{uuid}/principals/
    // Get a list of principals from a group in the tenant
    var GetPrincipalsFromGroup;
    (function (GetPrincipalsFromGroup) {
        var Uuid = z.string();
        var PrincipalUsername = z.string();
        var Limit = z.number().int();
        var Offset = z.number().int();
        var OrderBy = z.enum(['username']);
        /*
     Params
    'uuid':Uuid,
    'principalUsername'?:PrincipalUsername,
    'limit'?:Limit,
    'offset'?:Offset,
    'orderBy'?:OrderBy
    */
        GetPrincipalsFromGroup.actionCreator = function (params) {
            var path = '/groups/{uuid}/principals/'.replace('{uuid}', params.uuid.toString());
            var query = {};
            if (params.principalUsername !== undefined) {
                query.principal_username = params.principalUsername;
            }
            if (params.limit !== undefined) {
                query.limit = params.limit;
            }
            if (params.offset !== undefined) {
                query.offset = params.offset;
            }
            if (params.orderBy !== undefined) {
                query.order_by = params.orderBy;
            }
            return (0, react_fetching_library_1.actionBuilder)('GET', path)
                .queryParams(query)
                .config({
                rules: [
                    new openapi2typescript_1.ValidateRule(Schemas.PrincipalPagination, 'PrincipalPagination', 200),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 400),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 401),
                    new openapi2typescript_1.ValidateRule(Schemas.Error, 'Error', 404),
                    new openapi2typescript_1.ValidateRule(Schemas.Error, 'Error', 500)
                ]
            })
                .build();
        };
    })(GetPrincipalsFromGroup = Operations.GetPrincipalsFromGroup || (Operations.GetPrincipalsFromGroup = {}));
    // POST /groups/{uuid}/principals/
    // Add a principal to a group in the tenant
    var AddPrincipalToGroup;
    (function (AddPrincipalToGroup) {
        var Uuid = z.string();
        /*
     Params
    'uuid':Uuid,
    body: Schemas.GroupPrincipalIn
    */
        AddPrincipalToGroup.actionCreator = function (params) {
            var path = '/groups/{uuid}/principals/'.replace('{uuid}', params.uuid.toString());
            var query = {};
            return (0, react_fetching_library_1.actionBuilder)('POST', path)
                .queryParams(query)
                .data(params.body)
                .config({
                rules: [
                    new openapi2typescript_1.ValidateRule(Schemas.GroupWithPrincipalsAndRoles, 'GroupWithPrincipalsAndRoles', 200),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 400),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 401),
                    new openapi2typescript_1.ValidateRule(Schemas.Error403, 'Error403', 403),
                    new openapi2typescript_1.ValidateRule(Schemas.Error, 'Error', 404),
                    new openapi2typescript_1.ValidateRule(Schemas.Error, 'Error', 500)
                ]
            })
                .build();
        };
    })(AddPrincipalToGroup = Operations.AddPrincipalToGroup || (Operations.AddPrincipalToGroup = {}));
    // DELETE /groups/{uuid}/principals/
    // Remove a principal from a group in the tenant
    var DeletePrincipalFromGroup;
    (function (DeletePrincipalFromGroup) {
        var Uuid = z.string();
        var Usernames = z.string();
        /*
     Params
    'uuid':Uuid,
    'usernames':Usernames
    */
        DeletePrincipalFromGroup.actionCreator = function (params) {
            var path = '/groups/{uuid}/principals/'.replace('{uuid}', params.uuid.toString());
            var query = {};
            if (params.usernames !== undefined) {
                query.usernames = params.usernames;
            }
            return (0, react_fetching_library_1.actionBuilder)('DELETE', path)
                .queryParams(query)
                .config({
                rules: [
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 204),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 400),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 401),
                    new openapi2typescript_1.ValidateRule(Schemas.Error403, 'Error403', 403),
                    new openapi2typescript_1.ValidateRule(Schemas.Error, 'Error', 404),
                    new openapi2typescript_1.ValidateRule(Schemas.Error, 'Error', 500)
                ]
            })
                .build();
        };
    })(DeletePrincipalFromGroup = Operations.DeletePrincipalFromGroup || (Operations.DeletePrincipalFromGroup = {}));
    // GET /groups/{uuid}/roles/
    // List the roles for a group in the tenant
    var ListRolesForGroup;
    (function (ListRolesForGroup) {
        var Uuid = z.string();
        var Exclude = z.boolean();
        var RoleName = z.string();
        var RoleDisplayName = z.string();
        var RoleDescription = z.string();
        var RoleSystem = z.boolean();
        var Limit = z.number().int();
        var Offset = z.number().int();
        var OrderBy = z.enum(['name', 'display_name', 'modified', 'policyCount']);
        /*
     Params
    'uuid':Uuid,
    'exclude'?:Exclude,
    'roleName'?:RoleName,
    'roleDisplayName'?:RoleDisplayName,
    'roleDescription'?:RoleDescription,
    'roleSystem'?:RoleSystem,
    'limit'?:Limit,
    'offset'?:Offset,
    'orderBy'?:OrderBy
    */
        ListRolesForGroup.actionCreator = function (params) {
            var path = '/groups/{uuid}/roles/'.replace('{uuid}', params.uuid.toString());
            var query = {};
            if (params.exclude !== undefined) {
                query.exclude = params.exclude;
            }
            if (params.roleName !== undefined) {
                query.role_name = params.roleName;
            }
            if (params.roleDisplayName !== undefined) {
                query.role_display_name = params.roleDisplayName;
            }
            if (params.roleDescription !== undefined) {
                query.role_description = params.roleDescription;
            }
            if (params.roleSystem !== undefined) {
                query.role_system = params.roleSystem;
            }
            if (params.limit !== undefined) {
                query.limit = params.limit;
            }
            if (params.offset !== undefined) {
                query.offset = params.offset;
            }
            if (params.orderBy !== undefined) {
                query.order_by = params.orderBy;
            }
            return (0, react_fetching_library_1.actionBuilder)('GET', path)
                .queryParams(query)
                .config({
                rules: [
                    new openapi2typescript_1.ValidateRule(Schemas.GroupRolesPagination, 'GroupRolesPagination', 200),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 401),
                    new openapi2typescript_1.ValidateRule(Schemas.Error403, 'Error403', 403),
                    new openapi2typescript_1.ValidateRule(Schemas.Error, 'Error', 500)
                ]
            })
                .build();
        };
    })(ListRolesForGroup = Operations.ListRolesForGroup || (Operations.ListRolesForGroup = {}));
    // POST /groups/{uuid}/roles/
    // Add a role to a group in the tenant
    var AddRoleToGroup;
    (function (AddRoleToGroup) {
        var Uuid = z.string();
        var Response200 = z.object({
            data: z.array(Schemas.RoleOut)
        });
        /*
     Params
    'uuid':Uuid,
    body: Schemas.GroupRoleIn
    */
        AddRoleToGroup.actionCreator = function (params) {
            var path = '/groups/{uuid}/roles/'.replace('{uuid}', params.uuid.toString());
            var query = {};
            return (0, react_fetching_library_1.actionBuilder)('POST', path)
                .queryParams(query)
                .data(params.body)
                .config({
                rules: [
                    new openapi2typescript_1.ValidateRule(Response200, 'unknown', 200),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 400),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 401),
                    new openapi2typescript_1.ValidateRule(Schemas.Error403, 'Error403', 403),
                    new openapi2typescript_1.ValidateRule(Schemas.Error, 'Error', 404),
                    new openapi2typescript_1.ValidateRule(Schemas.Error, 'Error', 500)
                ]
            })
                .build();
        };
    })(AddRoleToGroup = Operations.AddRoleToGroup || (Operations.AddRoleToGroup = {}));
    // DELETE /groups/{uuid}/roles/
    // Remove a role from a group in the tenant
    var DeleteRoleFromGroup;
    (function (DeleteRoleFromGroup) {
        var Uuid = z.string();
        var Roles = z.string();
        /*
     Params
    'uuid':Uuid,
    'roles':Roles
    */
        DeleteRoleFromGroup.actionCreator = function (params) {
            var path = '/groups/{uuid}/roles/'.replace('{uuid}', params.uuid.toString());
            var query = {};
            if (params.roles !== undefined) {
                query.roles = params.roles;
            }
            return (0, react_fetching_library_1.actionBuilder)('DELETE', path)
                .queryParams(query)
                .config({
                rules: [
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 204),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 400),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 401),
                    new openapi2typescript_1.ValidateRule(Schemas.Error403, 'Error403', 403),
                    new openapi2typescript_1.ValidateRule(Schemas.Error, 'Error', 404),
                    new openapi2typescript_1.ValidateRule(Schemas.Error, 'Error', 500)
                ]
            })
                .build();
        };
    })(DeleteRoleFromGroup = Operations.DeleteRoleFromGroup || (Operations.DeleteRoleFromGroup = {}));
    // GET /permissions/
    // List the permissions for a tenant
    var ListPermissions;
    (function (ListPermissions) {
        var Limit = z.number().int();
        var Offset = z.number().int();
        var OrderBy = z.enum([
            'application',
            'resource_type',
            'verb',
            'permission'
        ]);
        var Application = z.string();
        var ResourceType = z.string();
        var Verb = z.string();
        var Permission = z.string();
        var ExcludeGlobals = z.enum(['true', 'false']);
        var ExcludeRoles = z.string();
        var AllowedOnly = z.enum(['true', 'false']);
        /*
     Params
    'limit'?:Limit,
    'offset'?:Offset,
    'orderBy'?:OrderBy,
    'application'?:Application,
    'resourceType'?:ResourceType,
    'verb'?:Verb,
    'permission'?:Permission,
    'excludeGlobals'?:ExcludeGlobals,
    'excludeRoles'?:ExcludeRoles,
    'allowedOnly'?:AllowedOnly
    */
        ListPermissions.actionCreator = function (params) {
            var path = '/permissions/';
            var query = {};
            if (params.limit !== undefined) {
                query.limit = params.limit;
            }
            if (params.offset !== undefined) {
                query.offset = params.offset;
            }
            if (params.orderBy !== undefined) {
                query.order_by = params.orderBy;
            }
            if (params.application !== undefined) {
                query.application = params.application;
            }
            if (params.resourceType !== undefined) {
                query.resource_type = params.resourceType;
            }
            if (params.verb !== undefined) {
                query.verb = params.verb;
            }
            if (params.permission !== undefined) {
                query.permission = params.permission;
            }
            if (params.excludeGlobals !== undefined) {
                query.exclude_globals = params.excludeGlobals;
            }
            if (params.excludeRoles !== undefined) {
                query.exclude_roles = params.excludeRoles;
            }
            if (params.allowedOnly !== undefined) {
                query.allowed_only = params.allowedOnly;
            }
            return (0, react_fetching_library_1.actionBuilder)('GET', path)
                .queryParams(query)
                .config({
                rules: [
                    new openapi2typescript_1.ValidateRule(Schemas.PermissionPagination, 'PermissionPagination', 200),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 401),
                    new openapi2typescript_1.ValidateRule(Schemas.Error403, 'Error403', 403),
                    new openapi2typescript_1.ValidateRule(Schemas.Error, 'Error', 500)
                ]
            })
                .build();
        };
    })(ListPermissions = Operations.ListPermissions || (Operations.ListPermissions = {}));
    // GET /permissions/options/
    // List the available options for fields of permissions for a tenant
    var ListPermissionOptions;
    (function (ListPermissionOptions) {
        var Limit = z.number().int();
        var Offset = z.number().int();
        var Field = z.enum(['application', 'resource_type', 'verb']);
        var Application = z.string();
        var ResourceType = z.string();
        var Verb = z.string();
        var ExcludeGlobals = z.enum(['true', 'false']);
        var AllowedOnly = z.enum(['true', 'false']);
        /*
     Params
    'limit'?:Limit,
    'offset'?:Offset,
    'field':Field,
    'application'?:Application,
    'resourceType'?:ResourceType,
    'verb'?:Verb,
    'excludeGlobals'?:ExcludeGlobals,
    'allowedOnly'?:AllowedOnly
    */
        ListPermissionOptions.actionCreator = function (params) {
            var path = '/permissions/options/';
            var query = {};
            if (params.limit !== undefined) {
                query.limit = params.limit;
            }
            if (params.offset !== undefined) {
                query.offset = params.offset;
            }
            if (params.field !== undefined) {
                query.field = params.field;
            }
            if (params.application !== undefined) {
                query.application = params.application;
            }
            if (params.resourceType !== undefined) {
                query.resource_type = params.resourceType;
            }
            if (params.verb !== undefined) {
                query.verb = params.verb;
            }
            if (params.excludeGlobals !== undefined) {
                query.exclude_globals = params.excludeGlobals;
            }
            if (params.allowedOnly !== undefined) {
                query.allowed_only = params.allowedOnly;
            }
            return (0, react_fetching_library_1.actionBuilder)('GET', path)
                .queryParams(query)
                .config({
                rules: [
                    new openapi2typescript_1.ValidateRule(Schemas.PermissionOptionsPagination, 'PermissionOptionsPagination', 200),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 401),
                    new openapi2typescript_1.ValidateRule(Schemas.Error403, 'Error403', 403),
                    new openapi2typescript_1.ValidateRule(Schemas.Error, 'Error', 500)
                ]
            })
                .build();
        };
    })(ListPermissionOptions = Operations.ListPermissionOptions || (Operations.ListPermissionOptions = {}));
    // GET /policies/
    // List the policies in the tenant
    var ListPolicies;
    (function (ListPolicies) {
        var Limit = z.number().int();
        var Offset = z.number().int();
        var Name = z.string();
        var Scope = z.enum(['account', 'principal']);
        var GroupName = z.string();
        var GroupUuid = z.string();
        var OrderBy = z.enum(['name', 'modified']);
        /*
     Params
    'limit'?:Limit,
    'offset'?:Offset,
    'name'?:Name,
    'scope'?:Scope,
    'groupName'?:GroupName,
    'groupUuid'?:GroupUuid,
    'orderBy'?:OrderBy
    */
        ListPolicies.actionCreator = function (params) {
            var path = '/policies/';
            var query = {};
            if (params.limit !== undefined) {
                query.limit = params.limit;
            }
            if (params.offset !== undefined) {
                query.offset = params.offset;
            }
            if (params.name !== undefined) {
                query.name = params.name;
            }
            if (params.scope !== undefined) {
                query.scope = params.scope;
            }
            if (params.groupName !== undefined) {
                query.group_name = params.groupName;
            }
            if (params.groupUuid !== undefined) {
                query.group_uuid = params.groupUuid;
            }
            if (params.orderBy !== undefined) {
                query.order_by = params.orderBy;
            }
            return (0, react_fetching_library_1.actionBuilder)('GET', path)
                .queryParams(query)
                .config({
                rules: [
                    new openapi2typescript_1.ValidateRule(Schemas.PolicyPagination, 'PolicyPagination', 200),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 401),
                    new openapi2typescript_1.ValidateRule(Schemas.Error, 'Error', 500)
                ]
            })
                .build();
        };
    })(ListPolicies = Operations.ListPolicies || (Operations.ListPolicies = {}));
    // POST /policies/
    // Create a policy in a tenant
    var CreatePolicies;
    (function (CreatePolicies) {
        /*
     Params
    body: Schemas.PolicyIn
    */
        CreatePolicies.actionCreator = function (params) {
            var path = '/policies/';
            var query = {};
            return (0, react_fetching_library_1.actionBuilder)('POST', path)
                .queryParams(query)
                .data(params.body)
                .config({
                rules: [
                    new openapi2typescript_1.ValidateRule(Schemas.PolicyExtended, 'PolicyExtended', 201),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 401),
                    new openapi2typescript_1.ValidateRule(Schemas.Error, 'Error', 500)
                ]
            })
                .build();
        };
    })(CreatePolicies = Operations.CreatePolicies || (Operations.CreatePolicies = {}));
    // GET /policies/{uuid}/
    // Get a policy in the tenant
    var GetPolicy;
    (function (GetPolicy) {
        var Uuid = z.string();
        /*
     Params
    'uuid':Uuid
    */
        GetPolicy.actionCreator = function (params) {
            var path = '/policies/{uuid}/'.replace('{uuid}', params.uuid.toString());
            var query = {};
            return (0, react_fetching_library_1.actionBuilder)('GET', path)
                .queryParams(query)
                .config({
                rules: [
                    new openapi2typescript_1.ValidateRule(Schemas.PolicyExtended, 'PolicyExtended', 200),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 401),
                    new openapi2typescript_1.ValidateRule(Schemas.Error, 'Error', 404),
                    new openapi2typescript_1.ValidateRule(Schemas.Error, 'Error', 500)
                ]
            })
                .build();
        };
    })(GetPolicy = Operations.GetPolicy || (Operations.GetPolicy = {}));
    // PUT /policies/{uuid}/
    // Update a policy in the tenant
    var UpdatePolicy;
    (function (UpdatePolicy) {
        var Uuid = z.string();
        /*
     Params
    'uuid':Uuid,
    body: Schemas.PolicyIn
    */
        UpdatePolicy.actionCreator = function (params) {
            var path = '/policies/{uuid}/'.replace('{uuid}', params.uuid.toString());
            var query = {};
            return (0, react_fetching_library_1.actionBuilder)('PUT', path)
                .queryParams(query)
                .data(params.body)
                .config({
                rules: [
                    new openapi2typescript_1.ValidateRule(Schemas.PolicyExtended, 'PolicyExtended', 200),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 401),
                    new openapi2typescript_1.ValidateRule(Schemas.Error, 'Error', 404),
                    new openapi2typescript_1.ValidateRule(Schemas.Error, 'Error', 500)
                ]
            })
                .build();
        };
    })(UpdatePolicy = Operations.UpdatePolicy || (Operations.UpdatePolicy = {}));
    // DELETE /policies/{uuid}/
    // Delete a policy in the tenant
    var DeletePolicy;
    (function (DeletePolicy) {
        var Uuid = z.string();
        /*
     Params
    'uuid':Uuid
    */
        DeletePolicy.actionCreator = function (params) {
            var path = '/policies/{uuid}/'.replace('{uuid}', params.uuid.toString());
            var query = {};
            return (0, react_fetching_library_1.actionBuilder)('DELETE', path)
                .queryParams(query)
                .config({
                rules: [
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 204),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 401),
                    new openapi2typescript_1.ValidateRule(Schemas.Error, 'Error', 404),
                    new openapi2typescript_1.ValidateRule(Schemas.Error, 'Error', 500)
                ]
            })
                .build();
        };
    })(DeletePolicy = Operations.DeletePolicy || (Operations.DeletePolicy = {}));
    // GET /principals/
    // List the principals for a tenant
    var ListPrincipals;
    (function (ListPrincipals) {
        var Limit = z.number().int();
        var Offset = z.number().int();
        var MatchCriteria = z.enum(['partial', 'exact']);
        var Usernames = z.string();
        var SortOrder = z.enum(['asc', 'desc']);
        var Email = z.string();
        var Status = z.enum(['enabled', 'disabled', 'all']);
        var AdminOnly = z.enum(['true', 'false']);
        var OrderBy = z.enum(['username']);
        /*
     Params
    'limit'?:Limit,
    'offset'?:Offset,
    'matchCriteria'?:MatchCriteria,
    'usernames'?:Usernames,
    'sortOrder'?:SortOrder,
    'email'?:Email,
    'status'?:Status,
    'adminOnly'?:AdminOnly,
    'orderBy'?:OrderBy
    */
        ListPrincipals.actionCreator = function (params) {
            var path = '/principals/';
            var query = {};
            if (params.limit !== undefined) {
                query.limit = params.limit;
            }
            if (params.offset !== undefined) {
                query.offset = params.offset;
            }
            if (params.matchCriteria !== undefined) {
                query.match_criteria = params.matchCriteria;
            }
            if (params.usernames !== undefined) {
                query.usernames = params.usernames;
            }
            if (params.sortOrder !== undefined) {
                query.sort_order = params.sortOrder;
            }
            if (params.email !== undefined) {
                query.email = params.email;
            }
            if (params.status !== undefined) {
                query.status = params.status;
            }
            if (params.adminOnly !== undefined) {
                query.admin_only = params.adminOnly;
            }
            if (params.orderBy !== undefined) {
                query.order_by = params.orderBy;
            }
            return (0, react_fetching_library_1.actionBuilder)('GET', path)
                .queryParams(query)
                .config({
                rules: [
                    new openapi2typescript_1.ValidateRule(Schemas.PrincipalPagination, 'PrincipalPagination', 200),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 401),
                    new openapi2typescript_1.ValidateRule(Schemas.Error403, 'Error403', 403),
                    new openapi2typescript_1.ValidateRule(Schemas.Error, 'Error', 500)
                ]
            })
                .build();
        };
    })(ListPrincipals = Operations.ListPrincipals || (Operations.ListPrincipals = {}));
    // GET /roles/
    // List the roles for a tenant
    var ListRoles;
    (function (ListRoles) {
        var Limit = z.number().int();
        var Offset = z.number().int();
        var Name = z.string();
        var System = z.boolean();
        var DisplayName = z.string();
        var NameMatch = z.enum(['partial', 'exact']);
        var Scope = z.enum(['account', 'principal']);
        var OrderBy = z.enum(['name', 'display_name', 'modified', 'policyCount']);
        var AddFields = z.array(z.enum(['groups_in', 'groups_in_count']));
        var Username = z.string();
        var Application = z.string();
        var Permission = z.string();
        /*
     Params
    'limit'?:Limit,
    'offset'?:Offset,
    'name'?:Name,
    'system'?:System,
    'displayName'?:DisplayName,
    'nameMatch'?:NameMatch,
    'scope'?:Scope,
    'orderBy'?:OrderBy,
    'addFields'?:AddFields,
    'username'?:Username,
    'application'?:Application,
    'permission'?:Permission
    */
        ListRoles.actionCreator = function (params) {
            var path = '/roles/';
            var query = {};
            if (params.limit !== undefined) {
                query.limit = params.limit;
            }
            if (params.offset !== undefined) {
                query.offset = params.offset;
            }
            if (params.name !== undefined) {
                query.name = params.name;
            }
            if (params.system !== undefined) {
                query.system = params.system;
            }
            if (params.displayName !== undefined) {
                query.display_name = params.displayName;
            }
            if (params.nameMatch !== undefined) {
                query.name_match = params.nameMatch;
            }
            if (params.scope !== undefined) {
                query.scope = params.scope;
            }
            if (params.orderBy !== undefined) {
                query.order_by = params.orderBy;
            }
            if (params.addFields !== undefined) {
                query.add_fields = params.addFields;
            }
            if (params.username !== undefined) {
                query.username = params.username;
            }
            if (params.application !== undefined) {
                query.application = params.application;
            }
            if (params.permission !== undefined) {
                query.permission = params.permission;
            }
            return (0, react_fetching_library_1.actionBuilder)('GET', path)
                .queryParams(query)
                .config({
                rules: [
                    new openapi2typescript_1.ValidateRule(Schemas.RolePaginationDynamic, 'RolePaginationDynamic', 200),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 401),
                    new openapi2typescript_1.ValidateRule(Schemas.Error403, 'Error403', 403),
                    new openapi2typescript_1.ValidateRule(Schemas.Error, 'Error', 500)
                ]
            })
                .build();
        };
    })(ListRoles = Operations.ListRoles || (Operations.ListRoles = {}));
    // POST /roles/
    // Create a roles for a tenant
    var CreateRoles;
    (function (CreateRoles) {
        /*
     Params
    body: Schemas.RoleIn
    */
        CreateRoles.actionCreator = function (params) {
            var path = '/roles/';
            var query = {};
            return (0, react_fetching_library_1.actionBuilder)('POST', path)
                .queryParams(query)
                .data(params.body)
                .config({
                rules: [
                    new openapi2typescript_1.ValidateRule(Schemas.RoleWithAccess, 'RoleWithAccess', 201),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 401),
                    new openapi2typescript_1.ValidateRule(Schemas.Error403, 'Error403', 403),
                    new openapi2typescript_1.ValidateRule(Schemas.Error, 'Error', 500)
                ]
            })
                .build();
        };
    })(CreateRoles = Operations.CreateRoles || (Operations.CreateRoles = {}));
    // GET /roles/{uuid}/
    // Get a role in the tenant
    var GetRole;
    (function (GetRole) {
        var Uuid = z.string();
        var Scope = z.enum(['account', 'principal']);
        /*
     Params
    'uuid':Uuid,
    'scope'?:Scope
    */
        GetRole.actionCreator = function (params) {
            var path = '/roles/{uuid}/'.replace('{uuid}', params.uuid.toString());
            var query = {};
            if (params.scope !== undefined) {
                query.scope = params.scope;
            }
            return (0, react_fetching_library_1.actionBuilder)('GET', path)
                .queryParams(query)
                .config({
                rules: [
                    new openapi2typescript_1.ValidateRule(Schemas.RoleWithAccess, 'RoleWithAccess', 200),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 401),
                    new openapi2typescript_1.ValidateRule(Schemas.Error403, 'Error403', 403),
                    new openapi2typescript_1.ValidateRule(Schemas.Error, 'Error', 404),
                    new openapi2typescript_1.ValidateRule(Schemas.Error, 'Error', 500)
                ]
            })
                .build();
        };
    })(GetRole = Operations.GetRole || (Operations.GetRole = {}));
    // PUT /roles/{uuid}/
    // Update a Role in the tenant
    var UpdateRole;
    (function (UpdateRole) {
        var Uuid = z.string();
        /*
     Params
    'uuid':Uuid,
    body: Schemas.RoleWithAccess
    */
        UpdateRole.actionCreator = function (params) {
            var path = '/roles/{uuid}/'.replace('{uuid}', params.uuid.toString());
            var query = {};
            return (0, react_fetching_library_1.actionBuilder)('PUT', path)
                .queryParams(query)
                .data(params.body)
                .config({
                rules: [
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 200),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 401),
                    new openapi2typescript_1.ValidateRule(Schemas.Error403, 'Error403', 403),
                    new openapi2typescript_1.ValidateRule(Schemas.Error, 'Error', 404),
                    new openapi2typescript_1.ValidateRule(Schemas.Error, 'Error', 500)
                ]
            })
                .build();
        };
    })(UpdateRole = Operations.UpdateRole || (Operations.UpdateRole = {}));
    // DELETE /roles/{uuid}/
    // Delete a role in the tenant
    var DeleteRole;
    (function (DeleteRole) {
        var Uuid = z.string();
        /*
     Params
    'uuid':Uuid
    */
        DeleteRole.actionCreator = function (params) {
            var path = '/roles/{uuid}/'.replace('{uuid}', params.uuid.toString());
            var query = {};
            return (0, react_fetching_library_1.actionBuilder)('DELETE', path)
                .queryParams(query)
                .config({
                rules: [
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 204),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 401),
                    new openapi2typescript_1.ValidateRule(Schemas.Error403, 'Error403', 403),
                    new openapi2typescript_1.ValidateRule(Schemas.Error, 'Error', 404),
                    new openapi2typescript_1.ValidateRule(Schemas.Error, 'Error', 500)
                ]
            })
                .build();
        };
    })(DeleteRole = Operations.DeleteRole || (Operations.DeleteRole = {}));
    // GET /roles/{uuid}/access/
    // Get access for a role in the tenant
    var GetRoleAccess;
    (function (GetRoleAccess) {
        var Uuid = z.string();
        var Limit = z.number().int();
        var Offset = z.number().int();
        /*
     Params
    'uuid':Uuid,
    'limit'?:Limit,
    'offset'?:Offset
    */
        GetRoleAccess.actionCreator = function (params) {
            var path = '/roles/{uuid}/access/'.replace('{uuid}', params.uuid.toString());
            var query = {};
            if (params.limit !== undefined) {
                query.limit = params.limit;
            }
            if (params.offset !== undefined) {
                query.offset = params.offset;
            }
            return (0, react_fetching_library_1.actionBuilder)('GET', path)
                .queryParams(query)
                .config({
                rules: [
                    new openapi2typescript_1.ValidateRule(Schemas.AccessPagination, 'AccessPagination', 200),
                    new openapi2typescript_1.ValidateRule(Schemas.__Empty, '__Empty', 401),
                    new openapi2typescript_1.ValidateRule(Schemas.Error403, 'Error403', 403),
                    new openapi2typescript_1.ValidateRule(Schemas.Error, 'Error', 404),
                    new openapi2typescript_1.ValidateRule(Schemas.Error, 'Error', 500)
                ]
            })
                .build();
        };
    })(GetRoleAccess = Operations.GetRoleAccess || (Operations.GetRoleAccess = {}));
    // GET /status/
    // Obtain server status
    var GetStatus;
    (function (GetStatus) {
        GetStatus.actionCreator = function () {
            var path = '/status/';
            var query = {};
            return (0, react_fetching_library_1.actionBuilder)('GET', path)
                .queryParams(query)
                .config({
                rules: [
                    new openapi2typescript_1.ValidateRule(Schemas.Status, 'Status', 200),
                    new openapi2typescript_1.ValidateRule(Schemas.Error, 'Error', 500)
                ]
            })
                .build();
        };
    })(GetStatus = Operations.GetStatus || (Operations.GetStatus = {}));
})(Operations = exports.Operations || (exports.Operations = {}));
"
`;

exports[`src/cli/schema execute for ./tests/__fixtures__/rbac-openapi.json execute input file accepts path: generated 1`] = `
"/* eslint-disable */
/**
 * Generated code, DO NOT modify directly.
 */
import * as z from 'zod';
import { ValidateRule } from 'openapi2typescript';
import { actionBuilder } from 'openapi2typescript/react-fetching-library';

export namespace Schemas {
  export const Access = zodSchemaAccess();

  export const AccessPagination = zodSchemaAccessPagination();

  export const AdditionalGroup = zodSchemaAdditionalGroup();

  export const CrossAccountRequest = zodSchemaCrossAccountRequest();

  export const CrossAccountRequestByAccount =
    zodSchemaCrossAccountRequestByAccount();

  export const CrossAccountRequestByUserId =
    zodSchemaCrossAccountRequestByUserId();

  export const CrossAccountRequestDetail = zodSchemaCrossAccountRequestDetail();

  export const CrossAccountRequestDetailByAccount =
    zodSchemaCrossAccountRequestDetailByAccount();

  export const CrossAccountRequestDetailByUseId =
    zodSchemaCrossAccountRequestDetailByUseId();

  export const CrossAccountRequestIn = zodSchemaCrossAccountRequestIn();

  export const CrossAccountRequestOut = zodSchemaCrossAccountRequestOut();

  export const CrossAccountRequestPagination =
    zodSchemaCrossAccountRequestPagination();

  export const CrossAccountRequestPatch = zodSchemaCrossAccountRequestPatch();

  export const CrossAccountRequestUpdateIn =
    zodSchemaCrossAccountRequestUpdateIn();

  export const CrossAccountRequestWithRoles =
    zodSchemaCrossAccountRequestWithRoles();

  export const Error = zodSchemaError();

  export const Error403 = zodSchemaError403();

  export const Group = zodSchemaGroup();

  export const GroupOut = zodSchemaGroupOut();

  export const GroupPagination = zodSchemaGroupPagination();

  export const GroupPrincipalIn = zodSchemaGroupPrincipalIn();

  export const GroupRoleIn = zodSchemaGroupRoleIn();

  export const GroupRolesPagination = zodSchemaGroupRolesPagination();

  export const GroupWithPrincipals = zodSchemaGroupWithPrincipals();

  export const GroupWithPrincipalsAndRoles =
    zodSchemaGroupWithPrincipalsAndRoles();

  export const ListPagination = zodSchemaListPagination();

  export const PaginationLinks = zodSchemaPaginationLinks();

  export const PaginationMeta = zodSchemaPaginationMeta();

  export const Permission = zodSchemaPermission();

  export const PermissionOptionsPagination =
    zodSchemaPermissionOptionsPagination();

  export const PermissionPagination = zodSchemaPermissionPagination();

  export const Policy = zodSchemaPolicy();

  export const PolicyExtended = zodSchemaPolicyExtended();

  export const PolicyIn = zodSchemaPolicyIn();

  export const PolicyPagination = zodSchemaPolicyPagination();

  export const Principal = zodSchemaPrincipal();

  export const PrincipalIn = zodSchemaPrincipalIn();

  export const PrincipalOut = zodSchemaPrincipalOut();

  export const PrincipalPagination = zodSchemaPrincipalPagination();

  export const ResourceDefinition = zodSchemaResourceDefinition();

  export const ResourceDefinitionFilter = zodSchemaResourceDefinitionFilter();

  export const Role = zodSchemaRole();

  export const RoleIn = zodSchemaRoleIn();

  export const RoleOut = zodSchemaRoleOut();

  export const RoleOutDynamic = zodSchemaRoleOutDynamic();

  export const RolePagination = zodSchemaRolePagination();

  export const RolePaginationDynamic = zodSchemaRolePaginationDynamic();

  export const RolePatch = zodSchemaRolePatch();

  export const RoleWithAccess = zodSchemaRoleWithAccess();

  export const Status = zodSchemaStatus();

  export const Timestamped = zodSchemaTimestamped();

  export const UUID = zodSchemaUUID();

  export const __Empty = zodSchema__Empty();

  function zodSchemaAccess() {
      return z.object({
          permission: z.string(),
          resourceDefinitions: z.array(zodSchemaResourceDefinition())
      });
  }

  function zodSchemaAccessPagination() {
      return z.intersection(
          zodSchemaListPagination(),
          z.object({
              data: z.array(zodSchemaAccess())
          })
      );
  }

  function zodSchemaAdditionalGroup() {
      return z.object({
          description: z.string().optional().nullable(),
          name: z.string().optional().nullable(),
          uuid: z.string().optional().nullable()
      });
  }

  function zodSchemaCrossAccountRequest() {
      return z.object({
          created: z.string().optional().nullable(),
          end_date: z.unknown().optional().nullable(),
          request_id: z.string().optional().nullable(),
          start_date: z.unknown().optional().nullable(),
          status: z.string().optional().nullable(),
          target_account: z.string().optional().nullable()
      });
  }

  function zodSchemaCrossAccountRequestByAccount() {
      return z.intersection(
          zodSchemaCrossAccountRequest(),
          z.object({
              email: z.string().optional().nullable(),
              first_name: z.string().optional().nullable(),
              last_name: z.string().optional().nullable()
          })
      );
  }

  function zodSchemaCrossAccountRequestByUserId() {
      return z.intersection(
          zodSchemaCrossAccountRequest(),
          z.object({
              user_id: z.string().optional().nullable()
          })
      );
  }

  function zodSchemaCrossAccountRequestDetail() {
      return z.union([
          zodSchemaCrossAccountRequestDetailByAccount(),
          zodSchemaCrossAccountRequestDetailByUseId()
      ]);
  }

  function zodSchemaCrossAccountRequestDetailByAccount() {
      return z.intersection(
          zodSchemaCrossAccountRequestWithRoles(),
          z.object({
              email: z.unknown().optional().nullable(),
              first_name: z.unknown().optional().nullable(),
              last_name: z.unknown().optional().nullable()
          })
      );
  }

  function zodSchemaCrossAccountRequestDetailByUseId() {
      return z.intersection(
          zodSchemaCrossAccountRequestWithRoles(),
          z.object({
              user_id: z.unknown().optional().nullable()
          })
      );
  }

  function zodSchemaCrossAccountRequestIn() {
      return z.object({
          end_date: z.string(),
          roles: z.array(z.string()),
          start_date: z.string(),
          target_account: z.string()
      });
  }

  function zodSchemaCrossAccountRequestOut() {
      return z.intersection(
          zodSchemaCrossAccountRequestWithRoles(),
          z.object({
              user_id: z.string().optional().nullable()
          })
      );
  }

  function zodSchemaCrossAccountRequestPagination() {
      return z.intersection(
          zodSchemaListPagination(),
          z.object({
              data: z.array(
                  z.union([
                      zodSchemaCrossAccountRequestByAccount(),
                      zodSchemaCrossAccountRequestByUserId()
                  ])
              )
          })
      );
  }

  function zodSchemaCrossAccountRequestPatch() {
      return z.object({
          end_date: z.string().optional().nullable(),
          roles: z.array(z.string()).optional().nullable(),
          start_date: z.string().optional().nullable(),
          status: z
          .enum([ 'pending', 'approved', 'expired', 'cancelled', 'denied' ])
          .optional()
          .nullable()
      });
  }

  function zodSchemaCrossAccountRequestUpdateIn() {
      return z.object({
          end_date: z.string(),
          roles: z.array(z.string()),
          start_date: z.string(),
          status: z
          .enum([ 'pending', 'approved', 'expired', 'cancelled', 'denied' ])
          .optional()
          .nullable()
      });
  }

  function zodSchemaCrossAccountRequestWithRoles() {
      return z.object({
          created: z.string().optional().nullable(),
          end_date: z.string().optional().nullable(),
          request_id: z.string().optional().nullable(),
          roles: z
          .array(
              z.object({
                  description: z.string().optional().nullable(),
                  display_name: z.string().optional().nullable(),
                  permissions: z.array(zodSchemaPermission()).optional().nullable()
              })
          )
          .optional()
          .nullable(),
          start_date: z.string().optional().nullable(),
          status: z.string().optional().nullable(),
          target_account: z.string().optional().nullable()
      });
  }

  function zodSchemaError() {
      return z.object({
          errors: z.array(
              z.object({
                  detail: z.string().optional().nullable(),
                  status: z.string().optional().nullable()
              })
          )
      });
  }

  function zodSchemaError403() {
      return z.object({
          errors: z.array(
              z.object({
                  detail: z.string().optional().nullable(),
                  source: z.string().optional().nullable(),
                  status: z.string().optional().nullable()
              })
          )
      });
  }

  function zodSchemaGroup() {
      return z.object({
          description: z.string().optional().nullable(),
          name: z.string()
      });
  }

  function zodSchemaGroupOut() {
      return z.intersection(
          zodSchemaGroup(),
          z.intersection(
              zodSchemaUUID(),
              z.intersection(
                  zodSchemaTimestamped(),
                  z.object({
                      platform_default: z.boolean().optional().nullable(),
                      principalCount: z.number().int().optional().nullable(),
                      roleCount: z.number().int().optional().nullable(),
                      system: z.boolean().optional().nullable()
                  })
              )
          )
      );
  }

  function zodSchemaGroupPagination() {
      return z.intersection(
          zodSchemaListPagination(),
          z.object({
              data: z.array(zodSchemaGroupOut())
          })
      );
  }

  function zodSchemaGroupPrincipalIn() {
      return z.object({
          principals: z.array(zodSchemaPrincipalIn())
      });
  }

  function zodSchemaGroupRoleIn() {
      return z.object({
          roles: z.array(z.string())
      });
  }

  function zodSchemaGroupRolesPagination() {
      return z.intersection(
          zodSchemaListPagination(),
          z.object({
              data: z.array(zodSchemaRoleOut())
          })
      );
  }

  function zodSchemaGroupWithPrincipals() {
      return z.intersection(
          zodSchemaGroup(),
          z.intersection(
              zodSchemaUUID(),
              z.intersection(
                  zodSchemaTimestamped(),
                  z.object({
                      principals: z.array(zodSchemaPrincipal())
                  })
              )
          )
      );
  }

  function zodSchemaGroupWithPrincipalsAndRoles() {
      return z.intersection(
          zodSchemaGroup(),
          z.intersection(
              zodSchemaUUID(),
              z.intersection(
                  zodSchemaTimestamped(),
                  z.object({
                      principals: z.array(zodSchemaPrincipal()),
                      roles: z.array(zodSchemaRoleOut())
                  })
              )
          )
      );
  }

  function zodSchemaListPagination() {
      return z.object({
          links: zodSchemaPaginationLinks().optional().nullable(),
          meta: zodSchemaPaginationMeta().optional().nullable()
      });
  }

  function zodSchemaPaginationLinks() {
      return z.object({
          first: z.string().optional().nullable(),
          last: z.string().optional().nullable(),
          next: z.string().optional().nullable(),
          previous: z.string().optional().nullable()
      });
  }

  function zodSchemaPaginationMeta() {
      return z.object({
          count: z.number().int().optional().nullable()
      });
  }

  function zodSchemaPermission() {
      return z.object({
          application: z.string().optional().nullable(),
          description: z.string().optional().nullable(),
          permission: z.string().optional().nullable(),
          resource_type: z.string().optional().nullable(),
          verb: z.string().optional().nullable()
      });
  }

  function zodSchemaPermissionOptionsPagination() {
      return z.intersection(
          zodSchemaListPagination(),
          z.object({
              data: z.array(z.string())
          })
      );
  }

  function zodSchemaPermissionPagination() {
      return z.intersection(
          zodSchemaListPagination(),
          z.object({
              data: z.array(zodSchemaPermission())
          })
      );
  }

  function zodSchemaPolicy() {
      return z.object({
          description: z.string().optional().nullable(),
          name: z.string()
      });
  }

  function zodSchemaPolicyExtended() {
      return z.intersection(
          zodSchemaPolicy(),
          z.intersection(
              zodSchemaUUID(),
              z.intersection(
                  zodSchemaTimestamped(),
                  z.object({
                      group: zodSchemaGroupOut(),
                      roles: z.array(zodSchemaRoleOut())
                  })
              )
          )
      );
  }

  function zodSchemaPolicyIn() {
      return z.intersection(
          zodSchemaPolicy(),
          z.object({
              group: z.string(),
              roles: z.array(z.string())
          })
      );
  }

  function zodSchemaPolicyPagination() {
      return z.intersection(
          zodSchemaListPagination(),
          z.object({
              data: z.array(zodSchemaPolicyExtended())
          })
      );
  }

  function zodSchemaPrincipal() {
      return z.object({
          email: z.string(),
          first_name: z.string().optional().nullable(),
          is_active: z.boolean().optional().nullable(),
          is_org_admin: z.boolean().optional().nullable(),
          last_name: z.string().optional().nullable(),
          username: z.string()
      });
  }

  function zodSchemaPrincipalIn() {
      return z.object({
          username: z.string()
      });
  }

  function zodSchemaPrincipalOut() {
      return z.intersection(zodSchemaPrincipal(), zodSchemaUUID());
  }

  function zodSchemaPrincipalPagination() {
      return z.intersection(
          zodSchemaListPagination(),
          z.object({
              data: z.array(zodSchemaPrincipal())
          })
      );
  }

  function zodSchemaResourceDefinition() {
      return z.object({
          attributeFilter: zodSchemaResourceDefinitionFilter()
      });
  }

  function zodSchemaResourceDefinitionFilter() {
      return z.object({
          key: z.string(),
          operation: z.enum([ 'equal', 'in' ]),
          value: z.string()
      });
  }

  function zodSchemaRole() {
      return z.object({
          description: z.string().optional().nullable(),
          display_name: z.string().optional().nullable(),
          name: z.string()
      });
  }

  function zodSchemaRoleIn() {
      return z.intersection(
          zodSchemaRole(),
          z.object({
              access: z.array(zodSchemaAccess())
          })
      );
  }

  function zodSchemaRoleOut() {
      return z.intersection(
          zodSchemaRole(),
          z.intersection(
              zodSchemaUUID(),
              z.intersection(
                  zodSchemaTimestamped(),
                  z.object({
                      accessCount: z.number().int().optional().nullable(),
                      applications: z.array(z.string()).optional().nullable(),
                      platform_default: z.boolean().optional().nullable(),
                      policyCount: z.number().int().optional().nullable(),
                      system: z.boolean().optional().nullable()
                  })
              )
          )
      );
  }

  function zodSchemaRoleOutDynamic() {
      return z.intersection(
          zodSchemaRole(),
          z.intersection(
              zodSchemaUUID(),
              z.intersection(
                  zodSchemaTimestamped(),
                  z.object({
                      accessCount: z.number().int(),
                      applications: z.array(z.string()),
                      groups_in: z
                      .array(zodSchemaAdditionalGroup())
                      .optional()
                      .nullable(),
                      groups_in_count: z.number().int().optional().nullable(),
                      platform_default: z.boolean(),
                      policyCount: z.number().int(),
                      system: z.boolean()
                  })
              )
          )
      );
  }

  function zodSchemaRolePagination() {
      return z.intersection(
          zodSchemaListPagination(),
          z.object({
              data: z.array(zodSchemaRoleOut())
          })
      );
  }

  function zodSchemaRolePaginationDynamic() {
      return z.intersection(
          zodSchemaListPagination(),
          z.object({
              data: z.array(zodSchemaRoleOutDynamic())
          })
      );
  }

  function zodSchemaRolePatch() {
      return z.object({
          description: z.string().optional().nullable(),
          display_name: z.string().optional().nullable(),
          name: z.string().optional().nullable()
      });
  }

  function zodSchemaRoleWithAccess() {
      return z.intersection(
          zodSchemaRoleOut(),
          z.object({
              access: z.array(zodSchemaAccess())
          })
      );
  }

  function zodSchemaStatus() {
      return z.object({
          api_version: z.number().int(),
          commit: z.string().optional().nullable()
      });
  }

  function zodSchemaTimestamped() {
      return z.object({
          created: z.string(),
          modified: z.string()
      });
  }

  function zodSchemaUUID() {
      return z.object({
          uuid: z.string()
      });
  }

  function zodSchema__Empty() {
      return z.string().max(0).optional();
  }
}

export namespace Operations {
  // GET /access/
  // Get the permitted access for a principal in the tenant (defaults to principal from the identity header)
  export namespace GetPrincipalAccess {
    const Application = z.string();
    const Username = z.string();
    const OrderBy = z.enum([ 'application', 'resource_type', 'verb' ]);
    const Limit = z.number().int();
    const Offset = z.number().int();
    /*
 Params
'application':Application,
'username'?:Username,
'orderBy'?:OrderBy,
'limit'?:Limit,
'offset'?:Offset
*/
    export const actionCreator = (params) => {
        const path = '/access/';
        const query = {};
        if (params.application !== undefined) {
            query.application = params.application;
        }

        if (params.username !== undefined) {
            query.username = params.username;
        }

        if (params.orderBy !== undefined) {
            query.order_by = params.orderBy;
        }

        if (params.limit !== undefined) {
            query.limit = params.limit;
        }

        if (params.offset !== undefined) {
            query.offset = params.offset;
        }

        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Schemas.AccessPagination, 'AccessPagination', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.Error, 'Error', 404),
                new ValidateRule(Schemas.Error, 'Error', 500)
            ]
        })
        .build();
    };
  }
  // GET /cross-account-requests/
  // List the cross account requests for a user or account
  export namespace ListCrossAccountRequests {
    const Limit = z.number().int();
    const Offset = z.number().int();
    const QueryBy = z.enum([ 'user_id', 'target_account' ]);
    const Account = z.string();
    const ApprovedOnly = z.enum([ 'true' ]);
    const Status = z.enum([
        'pending',
        'approved',
        'denied',
        'cancelled',
        'expired'
    ]);
    const OrderBy = z.enum([
        'request_id',
        'start_date',
        'end_date',
        'created',
        'modified',
        'status'
    ]);
    /*
 Params
'limit'?:Limit,
'offset'?:Offset,
'queryBy'?:QueryBy,
'account'?:Account,
'approvedOnly'?:ApprovedOnly,
'status'?:Status,
'orderBy'?:OrderBy
*/
    export const actionCreator = (params) => {
        const path = '/cross-account-requests/';
        const query = {};
        if (params.limit !== undefined) {
            query.limit = params.limit;
        }

        if (params.offset !== undefined) {
            query.offset = params.offset;
        }

        if (params.queryBy !== undefined) {
            query.query_by = params.queryBy;
        }

        if (params.account !== undefined) {
            query.account = params.account;
        }

        if (params.approvedOnly !== undefined) {
            query.approved_only = params.approvedOnly;
        }

        if (params.status !== undefined) {
            query.status = params.status;
        }

        if (params.orderBy !== undefined) {
            query.order_by = params.orderBy;
        }

        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(
                    Schemas.CrossAccountRequestPagination,
                    'CrossAccountRequestPagination',
                    200
                ),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.Error403, 'Error403', 403),
                new ValidateRule(Schemas.Error, 'Error', 500)
            ]
        })
        .build();
    };
  }
  // POST /cross-account-requests/
  // Create a cross account request
  export namespace CreateCrossAccountRequests {
    /*
 Params
body: Schemas.CrossAccountRequestIn
*/
    export const actionCreator = (params) => {
        const path = '/cross-account-requests/';
        const query = {};
        return actionBuilder('POST', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [
                new ValidateRule(
                    Schemas.CrossAccountRequestOut,
                    'CrossAccountRequestOut',
                    201
                ),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.Error403, 'Error403', 403),
                new ValidateRule(Schemas.Error, 'Error', 500)
            ]
        })
        .build();
    };
  }
  // GET /cross-account-requests/{uuid}/
  // Get a cross account request
  export namespace GetCrossAccountRequest {
    const Uuid = z.string();
    const QueryBy = z.enum([ 'user_id', 'target_account' ]);
    const Account = z.string();
    const ApprovedOnly = z.enum([ 'true' ]);
    /*
 Params
'uuid':Uuid,
'queryBy'?:QueryBy,
'account'?:Account,
'approvedOnly'?:ApprovedOnly
*/
    export const actionCreator = (params) => {
        const path = '/cross-account-requests/{uuid}/'.replace(
            '{uuid}',
            params.uuid.toString()
        );
        const query = {};
        if (params.queryBy !== undefined) {
            query.query_by = params.queryBy;
        }

        if (params.account !== undefined) {
            query.account = params.account;
        }

        if (params.approvedOnly !== undefined) {
            query.approved_only = params.approvedOnly;
        }

        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(
                    Schemas.CrossAccountRequestDetail,
                    'CrossAccountRequestDetail',
                    200
                ),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.Error403, 'Error403', 403),
                new ValidateRule(Schemas.Error, 'Error', 404),
                new ValidateRule(Schemas.Error, 'Error', 500)
            ]
        })
        .build();
    };
  }
  // PUT /cross-account-requests/{uuid}/
  // Update a cross account request
  export namespace PutCrossAccountRequest {
    const Uuid = z.string();
    /*
 Params
'uuid':Uuid,
body: Schemas.CrossAccountRequestUpdateIn
*/
    export const actionCreator = (params) => {
        const path = '/cross-account-requests/{uuid}/'.replace(
            '{uuid}',
            params.uuid.toString()
        );
        const query = {};
        return actionBuilder('PUT', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [
                new ValidateRule(
                    Schemas.CrossAccountRequestDetail,
                    'CrossAccountRequestDetail',
                    200
                ),
                new ValidateRule(
                    Schemas.CrossAccountRequestOut,
                    'CrossAccountRequestOut',
                    201
                ),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.Error403, 'Error403', 403),
                new ValidateRule(Schemas.Error, 'Error', 404),
                new ValidateRule(Schemas.Error, 'Error', 500)
            ]
        })
        .build();
    };
  }
  // GET /groups/
  // List the groups for a tenant
  export namespace ListGroups {
    const Limit = z.number().int();
    const Offset = z.number().int();
    const Name = z.string();
    const NameMatch = z.enum([ 'partial', 'exact' ]);
    const Scope = z.enum([ 'account', 'principal' ]);
    const Username = z.string();
    const Uuid = z.array(z.string());
    const RoleNames = z.array(z.string());
    const RoleDiscriminator = z.enum([ 'all', 'any' ]);
    const OrderBy = z.enum([
        'name',
        'modified',
        'principalCount',
        'policyCount'
    ]);
    const PlatformDefault = z.boolean();
    const System = z.boolean();
    /*
 Params
'limit'?:Limit,
'offset'?:Offset,
'name'?:Name,
'nameMatch'?:NameMatch,
'scope'?:Scope,
'username'?:Username,
'uuid'?:Uuid,
'roleNames'?:RoleNames,
'roleDiscriminator'?:RoleDiscriminator,
'orderBy'?:OrderBy,
'platformDefault'?:PlatformDefault,
'system'?:System
*/
    export const actionCreator = (params) => {
        const path = '/groups/';
        const query = {};
        if (params.limit !== undefined) {
            query.limit = params.limit;
        }

        if (params.offset !== undefined) {
            query.offset = params.offset;
        }

        if (params.name !== undefined) {
            query.name = params.name;
        }

        if (params.nameMatch !== undefined) {
            query.name_match = params.nameMatch;
        }

        if (params.scope !== undefined) {
            query.scope = params.scope;
        }

        if (params.username !== undefined) {
            query.username = params.username;
        }

        if (params.uuid !== undefined) {
            query.uuid = params.uuid;
        }

        if (params.roleNames !== undefined) {
            query.role_names = params.roleNames;
        }

        if (params.roleDiscriminator !== undefined) {
            query.role_discriminator = params.roleDiscriminator;
        }

        if (params.orderBy !== undefined) {
            query.order_by = params.orderBy;
        }

        if (params.platformDefault !== undefined) {
            query.platform_default = params.platformDefault;
        }

        if (params.system !== undefined) {
            query.system = params.system;
        }

        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Schemas.GroupPagination, 'GroupPagination', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.Error403, 'Error403', 403),
                new ValidateRule(Schemas.Error, 'Error', 500)
            ]
        })
        .build();
    };
  }
  // POST /groups/
  // Create a group in a tenant
  export namespace CreateGroup {
    /*
 Params
body: Schemas.Group
*/
    export const actionCreator = (params) => {
        const path = '/groups/';
        const query = {};
        return actionBuilder('POST', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [
                new ValidateRule(Schemas.GroupOut, 'GroupOut', 201),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.Error403, 'Error403', 403),
                new ValidateRule(Schemas.Error, 'Error', 500)
            ]
        })
        .build();
    };
  }
  // GET /groups/{uuid}/
  // Get a group in the tenant
  export namespace GetGroup {
    const Uuid = z.string();
    /*
 Params
'uuid':Uuid
*/
    export const actionCreator = (params) => {
        const path = '/groups/{uuid}/'.replace(
            '{uuid}',
            params.uuid.toString()
        );
        const query = {};
        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(
                    Schemas.GroupWithPrincipalsAndRoles,
                    'GroupWithPrincipalsAndRoles',
                    200
                ),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.Error403, 'Error403', 403),
                new ValidateRule(Schemas.Error, 'Error', 404),
                new ValidateRule(Schemas.Error, 'Error', 500)
            ]
        })
        .build();
    };
  }
  // PUT /groups/{uuid}/
  // Update a group in the tenant
  export namespace UpdateGroup {
    const Uuid = z.string();
    /*
 Params
'uuid':Uuid,
body: Schemas.Group
*/
    export const actionCreator = (params) => {
        const path = '/groups/{uuid}/'.replace(
            '{uuid}',
            params.uuid.toString()
        );
        const query = {};
        return actionBuilder('PUT', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [
                new ValidateRule(Schemas.GroupOut, 'GroupOut', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.Error403, 'Error403', 403),
                new ValidateRule(Schemas.Error, 'Error', 404),
                new ValidateRule(Schemas.Error, 'Error', 500)
            ]
        })
        .build();
    };
  }
  // DELETE /groups/{uuid}/
  // Delete a group in the tenant
  export namespace DeleteGroup {
    const Uuid = z.string();
    /*
 Params
'uuid':Uuid
*/
    export const actionCreator = (params) => {
        const path = '/groups/{uuid}/'.replace(
            '{uuid}',
            params.uuid.toString()
        );
        const query = {};
        return actionBuilder('DELETE', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Schemas.__Empty, '__Empty', 204),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.Error403, 'Error403', 403),
                new ValidateRule(Schemas.Error, 'Error', 404),
                new ValidateRule(Schemas.Error, 'Error', 500)
            ]
        })
        .build();
    };
  }
  // GET /groups/{uuid}/principals/
  // Get a list of principals from a group in the tenant
  export namespace GetPrincipalsFromGroup {
    const Uuid = z.string();
    const PrincipalUsername = z.string();
    const Limit = z.number().int();
    const Offset = z.number().int();
    const OrderBy = z.enum([ 'username' ]);
    /*
 Params
'uuid':Uuid,
'principalUsername'?:PrincipalUsername,
'limit'?:Limit,
'offset'?:Offset,
'orderBy'?:OrderBy
*/
    export const actionCreator = (params) => {
        const path = '/groups/{uuid}/principals/'.replace(
            '{uuid}',
            params.uuid.toString()
        );
        const query = {};
        if (params.principalUsername !== undefined) {
            query.principal_username = params.principalUsername;
        }

        if (params.limit !== undefined) {
            query.limit = params.limit;
        }

        if (params.offset !== undefined) {
            query.offset = params.offset;
        }

        if (params.orderBy !== undefined) {
            query.order_by = params.orderBy;
        }

        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(
                    Schemas.PrincipalPagination,
                    'PrincipalPagination',
                    200
                ),
                new ValidateRule(Schemas.__Empty, '__Empty', 400),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.Error, 'Error', 404),
                new ValidateRule(Schemas.Error, 'Error', 500)
            ]
        })
        .build();
    };
  }
  // POST /groups/{uuid}/principals/
  // Add a principal to a group in the tenant
  export namespace AddPrincipalToGroup {
    const Uuid = z.string();
    /*
 Params
'uuid':Uuid,
body: Schemas.GroupPrincipalIn
*/
    export const actionCreator = (params) => {
        const path = '/groups/{uuid}/principals/'.replace(
            '{uuid}',
            params.uuid.toString()
        );
        const query = {};
        return actionBuilder('POST', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [
                new ValidateRule(
                    Schemas.GroupWithPrincipalsAndRoles,
                    'GroupWithPrincipalsAndRoles',
                    200
                ),
                new ValidateRule(Schemas.__Empty, '__Empty', 400),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.Error403, 'Error403', 403),
                new ValidateRule(Schemas.Error, 'Error', 404),
                new ValidateRule(Schemas.Error, 'Error', 500)
            ]
        })
        .build();
    };
  }
  // DELETE /groups/{uuid}/principals/
  // Remove a principal from a group in the tenant
  export namespace DeletePrincipalFromGroup {
    const Uuid = z.string();
    const Usernames = z.string();
    /*
 Params
'uuid':Uuid,
'usernames':Usernames
*/
    export const actionCreator = (params) => {
        const path = '/groups/{uuid}/principals/'.replace(
            '{uuid}',
            params.uuid.toString()
        );
        const query = {};
        if (params.usernames !== undefined) {
            query.usernames = params.usernames;
        }

        return actionBuilder('DELETE', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Schemas.__Empty, '__Empty', 204),
                new ValidateRule(Schemas.__Empty, '__Empty', 400),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.Error403, 'Error403', 403),
                new ValidateRule(Schemas.Error, 'Error', 404),
                new ValidateRule(Schemas.Error, 'Error', 500)
            ]
        })
        .build();
    };
  }
  // GET /groups/{uuid}/roles/
  // List the roles for a group in the tenant
  export namespace ListRolesForGroup {
    const Uuid = z.string();
    const Exclude = z.boolean();
    const RoleName = z.string();
    const RoleDisplayName = z.string();
    const RoleDescription = z.string();
    const RoleSystem = z.boolean();
    const Limit = z.number().int();
    const Offset = z.number().int();
    const OrderBy = z.enum([ 'name', 'display_name', 'modified', 'policyCount' ]);
    /*
 Params
'uuid':Uuid,
'exclude'?:Exclude,
'roleName'?:RoleName,
'roleDisplayName'?:RoleDisplayName,
'roleDescription'?:RoleDescription,
'roleSystem'?:RoleSystem,
'limit'?:Limit,
'offset'?:Offset,
'orderBy'?:OrderBy
*/
    export const actionCreator = (params) => {
        const path = '/groups/{uuid}/roles/'.replace(
            '{uuid}',
            params.uuid.toString()
        );
        const query = {};
        if (params.exclude !== undefined) {
            query.exclude = params.exclude;
        }

        if (params.roleName !== undefined) {
            query.role_name = params.roleName;
        }

        if (params.roleDisplayName !== undefined) {
            query.role_display_name = params.roleDisplayName;
        }

        if (params.roleDescription !== undefined) {
            query.role_description = params.roleDescription;
        }

        if (params.roleSystem !== undefined) {
            query.role_system = params.roleSystem;
        }

        if (params.limit !== undefined) {
            query.limit = params.limit;
        }

        if (params.offset !== undefined) {
            query.offset = params.offset;
        }

        if (params.orderBy !== undefined) {
            query.order_by = params.orderBy;
        }

        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(
                    Schemas.GroupRolesPagination,
                    'GroupRolesPagination',
                    200
                ),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.Error403, 'Error403', 403),
                new ValidateRule(Schemas.Error, 'Error', 500)
            ]
        })
        .build();
    };
  }
  // POST /groups/{uuid}/roles/
  // Add a role to a group in the tenant
  export namespace AddRoleToGroup {
    const Uuid = z.string();
    const Response200 = z.object({
        data: z.array(Schemas.RoleOut)
    });
    /*
 Params
'uuid':Uuid,
body: Schemas.GroupRoleIn
*/
    export const actionCreator = (params) => {
        const path = '/groups/{uuid}/roles/'.replace(
            '{uuid}',
            params.uuid.toString()
        );
        const query = {};
        return actionBuilder('POST', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [
                new ValidateRule(Response200, 'unknown', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 400),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.Error403, 'Error403', 403),
                new ValidateRule(Schemas.Error, 'Error', 404),
                new ValidateRule(Schemas.Error, 'Error', 500)
            ]
        })
        .build();
    };
  }
  // DELETE /groups/{uuid}/roles/
  // Remove a role from a group in the tenant
  export namespace DeleteRoleFromGroup {
    const Uuid = z.string();
    const Roles = z.string();
    /*
 Params
'uuid':Uuid,
'roles':Roles
*/
    export const actionCreator = (params) => {
        const path = '/groups/{uuid}/roles/'.replace(
            '{uuid}',
            params.uuid.toString()
        );
        const query = {};
        if (params.roles !== undefined) {
            query.roles = params.roles;
        }

        return actionBuilder('DELETE', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Schemas.__Empty, '__Empty', 204),
                new ValidateRule(Schemas.__Empty, '__Empty', 400),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.Error403, 'Error403', 403),
                new ValidateRule(Schemas.Error, 'Error', 404),
                new ValidateRule(Schemas.Error, 'Error', 500)
            ]
        })
        .build();
    };
  }
  // GET /permissions/
  // List the permissions for a tenant
  export namespace ListPermissions {
    const Limit = z.number().int();
    const Offset = z.number().int();
    const OrderBy = z.enum([
        'application',
        'resource_type',
        'verb',
        'permission'
    ]);
    const Application = z.string();
    const ResourceType = z.string();
    const Verb = z.string();
    const Permission = z.string();
    const ExcludeGlobals = z.enum([ 'true', 'false' ]);
    const ExcludeRoles = z.string();
    const AllowedOnly = z.enum([ 'true', 'false' ]);
    /*
 Params
'limit'?:Limit,
'offset'?:Offset,
'orderBy'?:OrderBy,
'application'?:Application,
'resourceType'?:ResourceType,
'verb'?:Verb,
'permission'?:Permission,
'excludeGlobals'?:ExcludeGlobals,
'excludeRoles'?:ExcludeRoles,
'allowedOnly'?:AllowedOnly
*/
    export const actionCreator = (params) => {
        const path = '/permissions/';
        const query = {};
        if (params.limit !== undefined) {
            query.limit = params.limit;
        }

        if (params.offset !== undefined) {
            query.offset = params.offset;
        }

        if (params.orderBy !== undefined) {
            query.order_by = params.orderBy;
        }

        if (params.application !== undefined) {
            query.application = params.application;
        }

        if (params.resourceType !== undefined) {
            query.resource_type = params.resourceType;
        }

        if (params.verb !== undefined) {
            query.verb = params.verb;
        }

        if (params.permission !== undefined) {
            query.permission = params.permission;
        }

        if (params.excludeGlobals !== undefined) {
            query.exclude_globals = params.excludeGlobals;
        }

        if (params.excludeRoles !== undefined) {
            query.exclude_roles = params.excludeRoles;
        }

        if (params.allowedOnly !== undefined) {
            query.allowed_only = params.allowedOnly;
        }

        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(
                    Schemas.PermissionPagination,
                    'PermissionPagination',
                    200
                ),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.Error403, 'Error403', 403),
                new ValidateRule(Schemas.Error, 'Error', 500)
            ]
        })
        .build();
    };
  }
  // GET /permissions/options/
  // List the available options for fields of permissions for a tenant
  export namespace ListPermissionOptions {
    const Limit = z.number().int();
    const Offset = z.number().int();
    const Field = z.enum([ 'application', 'resource_type', 'verb' ]);
    const Application = z.string();
    const ResourceType = z.string();
    const Verb = z.string();
    const ExcludeGlobals = z.enum([ 'true', 'false' ]);
    const AllowedOnly = z.enum([ 'true', 'false' ]);
    /*
 Params
'limit'?:Limit,
'offset'?:Offset,
'field':Field,
'application'?:Application,
'resourceType'?:ResourceType,
'verb'?:Verb,
'excludeGlobals'?:ExcludeGlobals,
'allowedOnly'?:AllowedOnly
*/
    export const actionCreator = (params) => {
        const path = '/permissions/options/';
        const query = {};
        if (params.limit !== undefined) {
            query.limit = params.limit;
        }

        if (params.offset !== undefined) {
            query.offset = params.offset;
        }

        if (params.field !== undefined) {
            query.field = params.field;
        }

        if (params.application !== undefined) {
            query.application = params.application;
        }

        if (params.resourceType !== undefined) {
            query.resource_type = params.resourceType;
        }

        if (params.verb !== undefined) {
            query.verb = params.verb;
        }

        if (params.excludeGlobals !== undefined) {
            query.exclude_globals = params.excludeGlobals;
        }

        if (params.allowedOnly !== undefined) {
            query.allowed_only = params.allowedOnly;
        }

        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(
                    Schemas.PermissionOptionsPagination,
                    'PermissionOptionsPagination',
                    200
                ),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.Error403, 'Error403', 403),
                new ValidateRule(Schemas.Error, 'Error', 500)
            ]
        })
        .build();
    };
  }
  // GET /policies/
  // List the policies in the tenant
  export namespace ListPolicies {
    const Limit = z.number().int();
    const Offset = z.number().int();
    const Name = z.string();
    const Scope = z.enum([ 'account', 'principal' ]);
    const GroupName = z.string();
    const GroupUuid = z.string();
    const OrderBy = z.enum([ 'name', 'modified' ]);
    /*
 Params
'limit'?:Limit,
'offset'?:Offset,
'name'?:Name,
'scope'?:Scope,
'groupName'?:GroupName,
'groupUuid'?:GroupUuid,
'orderBy'?:OrderBy
*/
    export const actionCreator = (params) => {
        const path = '/policies/';
        const query = {};
        if (params.limit !== undefined) {
            query.limit = params.limit;
        }

        if (params.offset !== undefined) {
            query.offset = params.offset;
        }

        if (params.name !== undefined) {
            query.name = params.name;
        }

        if (params.scope !== undefined) {
            query.scope = params.scope;
        }

        if (params.groupName !== undefined) {
            query.group_name = params.groupName;
        }

        if (params.groupUuid !== undefined) {
            query.group_uuid = params.groupUuid;
        }

        if (params.orderBy !== undefined) {
            query.order_by = params.orderBy;
        }

        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Schemas.PolicyPagination, 'PolicyPagination', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.Error, 'Error', 500)
            ]
        })
        .build();
    };
  }
  // POST /policies/
  // Create a policy in a tenant
  export namespace CreatePolicies {
    /*
 Params
body: Schemas.PolicyIn
*/
    export const actionCreator = (params) => {
        const path = '/policies/';
        const query = {};
        return actionBuilder('POST', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [
                new ValidateRule(Schemas.PolicyExtended, 'PolicyExtended', 201),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.Error, 'Error', 500)
            ]
        })
        .build();
    };
  }
  // GET /policies/{uuid}/
  // Get a policy in the tenant
  export namespace GetPolicy {
    const Uuid = z.string();
    /*
 Params
'uuid':Uuid
*/
    export const actionCreator = (params) => {
        const path = '/policies/{uuid}/'.replace(
            '{uuid}',
            params.uuid.toString()
        );
        const query = {};
        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Schemas.PolicyExtended, 'PolicyExtended', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.Error, 'Error', 404),
                new ValidateRule(Schemas.Error, 'Error', 500)
            ]
        })
        .build();
    };
  }
  // PUT /policies/{uuid}/
  // Update a policy in the tenant
  export namespace UpdatePolicy {
    const Uuid = z.string();
    /*
 Params
'uuid':Uuid,
body: Schemas.PolicyIn
*/
    export const actionCreator = (params) => {
        const path = '/policies/{uuid}/'.replace(
            '{uuid}',
            params.uuid.toString()
        );
        const query = {};
        return actionBuilder('PUT', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [
                new ValidateRule(Schemas.PolicyExtended, 'PolicyExtended', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.Error, 'Error', 404),
                new ValidateRule(Schemas.Error, 'Error', 500)
            ]
        })
        .build();
    };
  }
  // DELETE /policies/{uuid}/
  // Delete a policy in the tenant
  export namespace DeletePolicy {
    const Uuid = z.string();
    /*
 Params
'uuid':Uuid
*/
    export const actionCreator = (params) => {
        const path = '/policies/{uuid}/'.replace(
            '{uuid}',
            params.uuid.toString()
        );
        const query = {};
        return actionBuilder('DELETE', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Schemas.__Empty, '__Empty', 204),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.Error, 'Error', 404),
                new ValidateRule(Schemas.Error, 'Error', 500)
            ]
        })
        .build();
    };
  }
  // GET /principals/
  // List the principals for a tenant
  export namespace ListPrincipals {
    const Limit = z.number().int();
    const Offset = z.number().int();
    const MatchCriteria = z.enum([ 'partial', 'exact' ]);
    const Usernames = z.string();
    const SortOrder = z.enum([ 'asc', 'desc' ]);
    const Email = z.string();
    const Status = z.enum([ 'enabled', 'disabled', 'all' ]);
    const AdminOnly = z.enum([ 'true', 'false' ]);
    const OrderBy = z.enum([ 'username' ]);
    /*
 Params
'limit'?:Limit,
'offset'?:Offset,
'matchCriteria'?:MatchCriteria,
'usernames'?:Usernames,
'sortOrder'?:SortOrder,
'email'?:Email,
'status'?:Status,
'adminOnly'?:AdminOnly,
'orderBy'?:OrderBy
*/
    export const actionCreator = (params) => {
        const path = '/principals/';
        const query = {};
        if (params.limit !== undefined) {
            query.limit = params.limit;
        }

        if (params.offset !== undefined) {
            query.offset = params.offset;
        }

        if (params.matchCriteria !== undefined) {
            query.match_criteria = params.matchCriteria;
        }

        if (params.usernames !== undefined) {
            query.usernames = params.usernames;
        }

        if (params.sortOrder !== undefined) {
            query.sort_order = params.sortOrder;
        }

        if (params.email !== undefined) {
            query.email = params.email;
        }

        if (params.status !== undefined) {
            query.status = params.status;
        }

        if (params.adminOnly !== undefined) {
            query.admin_only = params.adminOnly;
        }

        if (params.orderBy !== undefined) {
            query.order_by = params.orderBy;
        }

        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(
                    Schemas.PrincipalPagination,
                    'PrincipalPagination',
                    200
                ),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.Error403, 'Error403', 403),
                new ValidateRule(Schemas.Error, 'Error', 500)
            ]
        })
        .build();
    };
  }
  // GET /roles/
  // List the roles for a tenant
  export namespace ListRoles {
    const Limit = z.number().int();
    const Offset = z.number().int();
    const Name = z.string();
    const System = z.boolean();
    const DisplayName = z.string();
    const NameMatch = z.enum([ 'partial', 'exact' ]);
    const Scope = z.enum([ 'account', 'principal' ]);
    const OrderBy = z.enum([ 'name', 'display_name', 'modified', 'policyCount' ]);
    const AddFields = z.array(z.enum([ 'groups_in', 'groups_in_count' ]));
    const Username = z.string();
    const Application = z.string();
    const Permission = z.string();
    /*
 Params
'limit'?:Limit,
'offset'?:Offset,
'name'?:Name,
'system'?:System,
'displayName'?:DisplayName,
'nameMatch'?:NameMatch,
'scope'?:Scope,
'orderBy'?:OrderBy,
'addFields'?:AddFields,
'username'?:Username,
'application'?:Application,
'permission'?:Permission
*/
    export const actionCreator = (params) => {
        const path = '/roles/';
        const query = {};
        if (params.limit !== undefined) {
            query.limit = params.limit;
        }

        if (params.offset !== undefined) {
            query.offset = params.offset;
        }

        if (params.name !== undefined) {
            query.name = params.name;
        }

        if (params.system !== undefined) {
            query.system = params.system;
        }

        if (params.displayName !== undefined) {
            query.display_name = params.displayName;
        }

        if (params.nameMatch !== undefined) {
            query.name_match = params.nameMatch;
        }

        if (params.scope !== undefined) {
            query.scope = params.scope;
        }

        if (params.orderBy !== undefined) {
            query.order_by = params.orderBy;
        }

        if (params.addFields !== undefined) {
            query.add_fields = params.addFields;
        }

        if (params.username !== undefined) {
            query.username = params.username;
        }

        if (params.application !== undefined) {
            query.application = params.application;
        }

        if (params.permission !== undefined) {
            query.permission = params.permission;
        }

        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(
                    Schemas.RolePaginationDynamic,
                    'RolePaginationDynamic',
                    200
                ),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.Error403, 'Error403', 403),
                new ValidateRule(Schemas.Error, 'Error', 500)
            ]
        })
        .build();
    };
  }
  // POST /roles/
  // Create a roles for a tenant
  export namespace CreateRoles {
    /*
 Params
body: Schemas.RoleIn
*/
    export const actionCreator = (params) => {
        const path = '/roles/';
        const query = {};
        return actionBuilder('POST', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [
                new ValidateRule(Schemas.RoleWithAccess, 'RoleWithAccess', 201),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.Error403, 'Error403', 403),
                new ValidateRule(Schemas.Error, 'Error', 500)
            ]
        })
        .build();
    };
  }
  // GET /roles/{uuid}/
  // Get a role in the tenant
  export namespace GetRole {
    const Uuid = z.string();
    const Scope = z.enum([ 'account', 'principal' ]);
    /*
 Params
'uuid':Uuid,
'scope'?:Scope
*/
    export const actionCreator = (params) => {
        const path = '/roles/{uuid}/'.replace(
            '{uuid}',
            params.uuid.toString()
        );
        const query = {};
        if (params.scope !== undefined) {
            query.scope = params.scope;
        }

        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Schemas.RoleWithAccess, 'RoleWithAccess', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.Error403, 'Error403', 403),
                new ValidateRule(Schemas.Error, 'Error', 404),
                new ValidateRule(Schemas.Error, 'Error', 500)
            ]
        })
        .build();
    };
  }
  // PUT /roles/{uuid}/
  // Update a Role in the tenant
  export namespace UpdateRole {
    const Uuid = z.string();
    /*
 Params
'uuid':Uuid,
body: Schemas.RoleWithAccess
*/
    export const actionCreator = (params) => {
        const path = '/roles/{uuid}/'.replace(
            '{uuid}',
            params.uuid.toString()
        );
        const query = {};
        return actionBuilder('PUT', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [
                new ValidateRule(Schemas.__Empty, '__Empty', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.Error403, 'Error403', 403),
                new ValidateRule(Schemas.Error, 'Error', 404),
                new ValidateRule(Schemas.Error, 'Error', 500)
            ]
        })
        .build();
    };
  }
  // DELETE /roles/{uuid}/
  // Delete a role in the tenant
  export namespace DeleteRole {
    const Uuid = z.string();
    /*
 Params
'uuid':Uuid
*/
    export const actionCreator = (params) => {
        const path = '/roles/{uuid}/'.replace(
            '{uuid}',
            params.uuid.toString()
        );
        const query = {};
        return actionBuilder('DELETE', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Schemas.__Empty, '__Empty', 204),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.Error403, 'Error403', 403),
                new ValidateRule(Schemas.Error, 'Error', 404),
                new ValidateRule(Schemas.Error, 'Error', 500)
            ]
        })
        .build();
    };
  }
  // GET /roles/{uuid}/access/
  // Get access for a role in the tenant
  export namespace GetRoleAccess {
    const Uuid = z.string();
    const Limit = z.number().int();
    const Offset = z.number().int();
    /*
 Params
'uuid':Uuid,
'limit'?:Limit,
'offset'?:Offset
*/
    export const actionCreator = (params) => {
        const path = '/roles/{uuid}/access/'.replace(
            '{uuid}',
            params.uuid.toString()
        );
        const query = {};
        if (params.limit !== undefined) {
            query.limit = params.limit;
        }

        if (params.offset !== undefined) {
            query.offset = params.offset;
        }

        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Schemas.AccessPagination, 'AccessPagination', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 401),
                new ValidateRule(Schemas.Error403, 'Error403', 403),
                new ValidateRule(Schemas.Error, 'Error', 404),
                new ValidateRule(Schemas.Error, 'Error', 500)
            ]
        })
        .build();
    };
  }
  // GET /status/
  // Obtain server status
  export namespace GetStatus {
    export const actionCreator = () => {
        const path = '/status/';
        const query = {};
        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Schemas.Status, 'Status', 200),
                new ValidateRule(Schemas.Error, 'Error', 500)
            ]
        })
        .build();
    };
  }
}
"
`;

exports[`src/cli/schema execute for ./tests/__fixtures__/simple-openapi.json execute accepts urls 1`] = `
"/* eslint-disable */
/**
 * Generated code, DO NOT modify directly.
 */
import * as z from 'zod';
import { ValidatedResponse } from 'openapi2typescript';
import { Action } from 'react-fetching-library';
import { ValidateRule } from 'openapi2typescript';
import {
    actionBuilder,
    ActionValidatableConfig
} from 'openapi2typescript/react-fetching-library';

export namespace Schemas {
  export const Fruit = zodSchemaFruit();
  export type Fruit = z.infer<typeof Fruit>;

  export const Message = zodSchemaMessage();
  export type Message = z.infer<typeof Message>;

  export const SetFruit = zodSchemaSetFruit();
  export type SetFruit = z.infer<typeof SetFruit>;

  function zodSchemaFruit() {
      return z.object({
          description: z.string().optional().nullable(),
          name: z.string().optional().nullable()
      });
  }

  function zodSchemaMessage() {
      return z.object({
          description: z.string().optional().nullable()
      });
  }

  function zodSchemaSetFruit() {
      return z.array(zodSchemaFruit());
  }
}

export namespace Operations {
  // GET /fruits
  export namespace GetFruits {
    export type Payload =
      | ValidatedResponse<'SetFruit', 200, Schemas.SetFruit>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (): ActionCreator => {
        const path = '/fruits';
        const query = {} as Record<string, any>;
        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [ new ValidateRule(Schemas.SetFruit, 'SetFruit', 200) ]
        })
        .build();
    };
  }
  // POST /fruits
  export namespace PostFruits {
    export interface Params {
      body: Schemas.Fruit;
    }

    export type Payload =
      | ValidatedResponse<'SetFruit', 200, Schemas.SetFruit>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/fruits';
        const query = {} as Record<string, any>;
        return actionBuilder('POST', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [ new ValidateRule(Schemas.SetFruit, 'SetFruit', 200) ]
        })
        .build();
    };
  }
  // DELETE /fruits
  export namespace DeleteFruits {
    export interface Params {
      body: Schemas.Fruit;
    }

    export type Payload =
      | ValidatedResponse<'SetFruit', 200, Schemas.SetFruit>
      | ValidatedResponse<'Message', 400, Schemas.Message>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/fruits';
        const query = {} as Record<string, any>;
        return actionBuilder('DELETE', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [
                new ValidateRule(Schemas.SetFruit, 'SetFruit', 200),
                new ValidateRule(Schemas.Message, 'Message', 400)
            ]
        })
        .build();
    };
  }
}
"
`;

exports[`src/cli/schema execute for ./tests/__fixtures__/simple-openapi.json execute input file accepts path: compiled 1`] = `
"\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.Operations = exports.Schemas = void 0;
/* eslint-disable */
/**
 * Generated code, DO NOT modify directly.
 */
var z = require(\\"zod\\");
var openapi2typescript_1 = require(\\"openapi2typescript\\");
var react_fetching_library_1 = require(\\"openapi2typescript/react-fetching-library\\");
var Schemas;
(function (Schemas) {
    Schemas.Fruit = zodSchemaFruit();
    Schemas.Message = zodSchemaMessage();
    Schemas.SetFruit = zodSchemaSetFruit();
    function zodSchemaFruit() {
        return z.object({
            description: z.string().optional().nullable(),
            name: z.string().optional().nullable()
        });
    }
    function zodSchemaMessage() {
        return z.object({
            description: z.string().optional().nullable()
        });
    }
    function zodSchemaSetFruit() {
        return z.array(zodSchemaFruit());
    }
})(Schemas = exports.Schemas || (exports.Schemas = {}));
var Operations;
(function (Operations) {
    // GET /fruits
    var GetFruits;
    (function (GetFruits) {
        GetFruits.actionCreator = function () {
            var path = '/fruits';
            var query = {};
            return (0, react_fetching_library_1.actionBuilder)('GET', path)
                .queryParams(query)
                .config({
                rules: [new openapi2typescript_1.ValidateRule(Schemas.SetFruit, 'SetFruit', 200)]
            })
                .build();
        };
    })(GetFruits = Operations.GetFruits || (Operations.GetFruits = {}));
    // POST /fruits
    var PostFruits;
    (function (PostFruits) {
        /*
     Params
    body: Schemas.Fruit
    */
        PostFruits.actionCreator = function (params) {
            var path = '/fruits';
            var query = {};
            return (0, react_fetching_library_1.actionBuilder)('POST', path)
                .queryParams(query)
                .data(params.body)
                .config({
                rules: [new openapi2typescript_1.ValidateRule(Schemas.SetFruit, 'SetFruit', 200)]
            })
                .build();
        };
    })(PostFruits = Operations.PostFruits || (Operations.PostFruits = {}));
    // DELETE /fruits
    var DeleteFruits;
    (function (DeleteFruits) {
        /*
     Params
    body: Schemas.Fruit
    */
        DeleteFruits.actionCreator = function (params) {
            var path = '/fruits';
            var query = {};
            return (0, react_fetching_library_1.actionBuilder)('DELETE', path)
                .queryParams(query)
                .data(params.body)
                .config({
                rules: [
                    new openapi2typescript_1.ValidateRule(Schemas.SetFruit, 'SetFruit', 200),
                    new openapi2typescript_1.ValidateRule(Schemas.Message, 'Message', 400)
                ]
            })
                .build();
        };
    })(DeleteFruits = Operations.DeleteFruits || (Operations.DeleteFruits = {}));
})(Operations = exports.Operations || (exports.Operations = {}));
"
`;

exports[`src/cli/schema execute for ./tests/__fixtures__/simple-openapi.json execute input file accepts path: generated 1`] = `
"/* eslint-disable */
/**
 * Generated code, DO NOT modify directly.
 */
import * as z from 'zod';
import { ValidateRule } from 'openapi2typescript';
import { actionBuilder } from 'openapi2typescript/react-fetching-library';

export namespace Schemas {
  export const Fruit = zodSchemaFruit();

  export const Message = zodSchemaMessage();

  export const SetFruit = zodSchemaSetFruit();

  function zodSchemaFruit() {
      return z.object({
          description: z.string().optional().nullable(),
          name: z.string().optional().nullable()
      });
  }

  function zodSchemaMessage() {
      return z.object({
          description: z.string().optional().nullable()
      });
  }

  function zodSchemaSetFruit() {
      return z.array(zodSchemaFruit());
  }
}

export namespace Operations {
  // GET /fruits
  export namespace GetFruits {
    export const actionCreator = () => {
        const path = '/fruits';
        const query = {};
        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [ new ValidateRule(Schemas.SetFruit, 'SetFruit', 200) ]
        })
        .build();
    };
  }
  // POST /fruits
  export namespace PostFruits {
    /*
 Params
body: Schemas.Fruit
*/
    export const actionCreator = (params) => {
        const path = '/fruits';
        const query = {};
        return actionBuilder('POST', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [ new ValidateRule(Schemas.SetFruit, 'SetFruit', 200) ]
        })
        .build();
    };
  }
  // DELETE /fruits
  export namespace DeleteFruits {
    /*
 Params
body: Schemas.Fruit
*/
    export const actionCreator = (params) => {
        const path = '/fruits';
        const query = {};
        return actionBuilder('DELETE', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [
                new ValidateRule(Schemas.SetFruit, 'SetFruit', 200),
                new ValidateRule(Schemas.Message, 'Message', 400)
            ]
        })
        .build();
    };
  }
}
"
`;
